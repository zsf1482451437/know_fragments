# 1 项目搭建规范

## 1.1 代码规范

### .browserslistrc文件

这个文件是给浏览器做适配的

```
> 1%
last 2 version
not dead
```

`> 1%` 是大于1%**市场份额**的浏览器；

`last 2 version`是那些浏览器最新两个**版本**；

`not dead`是依然**维护**的浏览器；

### .editorconfig配置

editorconfig有助于为不同编辑器上处理同一项目的多个开发人员维护**一致的编码风格**；

```yaml
root = true

[*] # 所有文件适用
charset = utf-8 # 设置文件字符集
indent_style = space # 缩进风格
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型
trim_trailing_whitespace = true # 去除行首的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # .md文件适用
max_line_length = off
trim_trailing_whitespace = false # 去除行首的任意空白字符
```

默认情况vs code不会读取这个文件，需要安装**EditorConfig for vs code**插件；

### prettier工具

一款强大的代码格式化工具，支持多种语言；

vs code有个插件**Prettier-Code formatter**，可以格式化；

要是不使用vs code呢？那就需要安装prettier这一第三包了；

**安装**

`npm install prettier -D`

**配置.prettierrc文件**

useTabs：使用tab键**缩进**还是空格，选择false；

tabWidth：tab是空格的情况下，是几个空格，选择2个；

printWidth：当行字符的长度，推荐80；

singleQuote：使用单引号还是双引号，选择true，单引号；

trailingComma：在多行输入尾逗号是否添加，设置none；

semi：语句末尾是否要加分号，选择false，不加；

```json
{
    "useTabs": false,
    "tabWidth": 2,
    "printWidth": 80,
    "singleQuote": true,
    "trailingComma": "none",
    "semi": false
}
```

同时有些代码不需要格式化，这时需要**配置.prettierignore文件**；

```
/dist/*
.local
.output.js
/node_modules/**

**/*.svg
**/*.sh

/public/*
```

**格式化所有文件**

新增一个脚本；

package.json

```json
"scripts": {
  ...
  "prettier": "prettier --write ."
}
```

执行 `npm run prettier` 就可以格式化所有代码啦

如果eslint和prettier存在冲突，那就需要安装两个第三方包，其实在选择eslint+prettier时应该已经安装了；

`npm install eslint-plugin-prettier eslint-config-prettier -D`

然后配置一下**.eslintrc.js文件**,在extends里新加一项

```js
module.exports = {
    ...
    extends: [
    	...
    	'plugin:prettier/recommended'
	]
}
```

### git Husky和eslint

git hasky是通过**拦截git commit**，检查代码**是否符合eslint**；

如果符合就执行**git commit**；

如果不符合就执行 `eslint --fix`**修复代码**，使其符合eslint，再执行git commit；

1.使用**自动配置命令**；

`npx husky-init && npm install`

这个命令做了三件事：

**安装**husky相关**依赖**；

在项目根目录下创建**.husky文件夹**；

在**package.json**中添加一个**脚本**；

如果node版本不支持，两个命令分开执行~

2.修改.husky文件夹下的**pre-commit**

```
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npm run lint
```

### 代码提交风格

可以使用一个工具：**commitizen** ;

这工具可以规范提交信息，让可以更好管理代码版本；

**安装**

`npm install commitizen -D`

**再安装**

`npx commitizen init cz-conventional-changelog --save-dev --save-exact`

以后执行**git commit**之前，先执行**npx cz**；

然后会有提交类型可以选择：

| Type     | 作用                                                       |
| -------- | ---------------------------------------------------------- |
| feat     | 新增特性（feature）                                        |
| fix      | 修复bug（bug fix）                                         |
| docs     | 修改文档（documentation）                                  |
| style    | 代码格式修改                                               |
| refactor | 代码重构（refactor）                                       |
| perf     | 改善性能（A code change that improves performance）        |
| test     | 测试（when adding missing tests）                          |
| build    | 变更项目构建或外部依赖（例如scopes：webpack、gulp、npm等） |
| ci       | 更改持续集成软件的配置文件和package中的scripts命令         |
| chore    | 变更构建流程或辅助工具（比如更改测试环境）                 |
| revert   | 代码回退                                                   |

还可以选择此次提交的作用域

### 代码提交验证

虽然使用cz这个工具规范了提交风格；

但是还是不能防止有些提交不按照提交风格；

此时还需要使用**commitlint**来限制提交；

需要安装两个包；

`npm install @commitlint/config-conventional @commitlint/cli -D`

然后在根目录创建commitlint.config.js文件，配置commitlint；

```js
module.exports = {
    extends: ['@commitlint/config-conventional']
}
```

然后实现husky生成的commit-msg文件，验证提交信息

```
npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"
```

然后再新增一个脚本

```json
"scripts": {
  ...
  "commit": "cz"
}
```

用 **npm run commit** 替代 **git commit**

### ts配置文件

当项目中有ts代码时，就会有**tsconfig.json**；

该文件可以给ts转化成js时提供选项、转化规则；

# 2 第三方集成

## 2.1 集成Vue Router

**安装**

```
npm install vue-router@next 
```

**配置路由**

```js
import { createRouter, createWebHashHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    redirect: 'login'
  },
  {
    path: '/login',
    component: () => import('views/login/login.vue')
  },
  {
    path: '/main',
    component: () => import('views/login/main.vue')
  }
]

const router = createRouter({
  routes,
  history: createWebHashHistory()
})

export default router
```

**main.ts**

```tsx
import { createApp } from 'vue'
import App from './App.vue'

import router from './router'

const app = createApp(App)
app.use(router)
app.mount('#app')
```



## 2.2 集成Vuex

**安装**

```
npm install vuex@next
```

**使用**

```tsx
import { createStore } from 'vuex'

const store = createStore({
  state: () => {
    return {
      name: 'zsf'
    }
  }
})

export default store
```

**main.ts**

```tsx
...
import store from './store'

const app = createApp(App)
...
app.use(store)
app.mount('#app')
```

## 2.3 集成Element-plus

基于Vue3的桌面端组件库

**安装**

```
npm install element-plus
```

**全局引入**

全局引入**集成比较简单**，但有的组件没用到，但也被打包了；

全局引入的原理是，**app.use(ElementPlus)** 时，那些组件已经**全局注册**了，引入时就不需要局部注册了，所以集成比较简单；

```tsx
import { createApp } from 'vue'
import App from './App.vue'

...
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)
...
app.use(ElementPlus)
app.mount('#app')
```

**按需引入**

按需引入集成起来相对麻烦；

不过官网提供了自动导入的功能，推荐，直接使用组件，内部自动局部注册和导入样式；

需要安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件；

```
npm install unplugin-vue-components unplugin-auto-import -D
```

然后在webpack.config.js配置他们

```js
const AutoImport = require('unplugin-auto-import/webpack')
const Components = require('unplugin-vue-components/webpack')
const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')

module.exports = {
  configureWebpack: {
    ...
    plugins: [
      AutoImport({
        resolvers: [ElementPlusResolver()]
      }),
      Components({
        resolvers: [ElementPlusResolver()]
      })
    ]
  }
}
```

## 2.4 集成Axios

**安装**

```
npm install axios
```

**区分不同的环境变量**

开发中，有时需要根据**不同环境**设置不同的**环境变量**，常见的有三种环境：

开发环境：development

生成环境：producttion

测试环境：test

**如何修改环境变量？**常见有3种：

- 手动修改，不太好；
- 根据process.env.NODE_ENV;
- 编写不同的环境变量配置文件；

比如一个环境变量**BASE_URL**，开发环境的值是dev；

当切换到生产环境时，要手动修改；

```tsx
const BASE_URL = 'http://zsf.org/dev'
```

要是环境变量多，手动修可能会很麻烦，而且你也可能忘记改了~所以不推荐；

第二种根据process.env.NODE_ENV自动切换；

```tsx
if (process.env.NODE_ENV === 'development') {
  const BASE_URL = 'http://zsf.org/dev'
} else if (process.env.NODE_ENV === 'production') {
  const BASE_URL = 'http://zsf.org/prod'
} else if (process.env.NODE_ENV === 'test') {
  const BASE_URL = 'http://zsf.org/tset'
}
```

第三种，在项目根目录下创建三个文件：

- .env_development
- .env_production
- .env_test

然后在里面定义对应的环境变量即可；

某些环境变量的名字是固定，比如**BASE_URL**；

要是想自定义环境变量名称，需要在前面加上**VUE_APP_** ;

### 封装到类里

1.在**services/request**下新建一个**index.ts**

```tsx
import axios from 'axios'
import type { AxiosInstance, AxiosRequestConfig } from 'axios'

class SFRequest {
  instance: AxiosInstance
  constructor(config: AxiosRequestConfig) {
    this.instance = axios.create(config)
  }

  request(config: AxiosRequestConfig): void {
    this.instance.request(config).then((res) => {
      console.log(res)
    })
  }
}

export default SFRequest

```

其中axios的实例**instance**有对应的类型**AxiosInstance**，不能自己定义，源码中可看到；

同时**axios.create()**的参数config也有对的类型**AxiosRequestConfig**，不能自己定义；



想**baseURL**这种公共属性，并且可能随着开发环境变化，可以使用配置文件改；

2.在**services/request**下新建一个**config.ts**；

```tsx
let BASE_URL = ''
const TIME_OUT = 10000

if (process.env.NODE_ENV === 'development') {
  BASE_URL = 'xxx'
} else if (process.env.NODE_ENV === 'production') {
  BASE_URL = 'http://zsf.org/prod'
} else if (process.env.NODE_ENV === 'test') {
  BASE_URL = 'http://zsf.org/tset'
}

export { BASE_URL, TIME_OUT }
```

3.在services下新建个统一出口**inedx.ts**

```tsx
import SFRequest from './request'
import { BASE_URL, TIME_OUT } from './request/config'

const sfRequest = new SFRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT
})

export default sfRequest
```

4.测试

```tsx
import sfRequest from './services'

sfRequest.request({
    url: '/home/multidata',
    method: 'GET'
})
```

封装到这里还没完；

### 粒度化封装

实现这三种封装：

- 针对**所有实例**
- 针对**某个实例**
- 针对**某个请求**

这么粒度化的封装是为了能够**精准的控制**网络请求；

一般地，大部分请求都需要**携带token**（除登陆请求外）和**loading动画**；

这时就需要**拦截器**了；

还需要考虑一个问题：axios实例需要拦截的东西可能是不一样的；

比如有些只需要loading动画，而有些需要携带token和loading动画；

需要什么样的拦截，应该在**new SFRequest()**时传进来，比如；

```tsx
const sfRequest = new SFRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    ...
  }
})
```

但原来的**constructor()**只支持**AxiosRequestConfig类型**，而AxiosRequestConfig类型没有拦截器相关的类型；

这时我们需要给**使用继承**给AxiosRequestConfig类型**拓展**一种拦截器相关的类型；

```tsx
interface SFRequestConfig extends AxiosRequestConfig {
  interceptors?: SFRequestInterceptors
}
```

而拦截器相关的类型需要自定义，叫SFRequestConfig吧；

```tsx
interface SFRequestInterceptors {
  // 可选的请求和响应拦截
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
  requestInterceptorCatch?: (error: any) => any
  responseInterceptor?: (res: AxiosResponse) => AxiosResponse
  responseInterceptorCatch?: (error: any) => any
}
```

这样，constructor()传进来的config的类型就可以使用**SFRequestConfig类型**了；

```tsx
constructor(config: SFRequestConfig) {
  this.instance = axios.create(config)
  this.interceptors = config.interceptors
  // 可选的请求拦截
  this.instance.interceptors.request.use(
    this.interceptors?.requestInterceptor,
    this.interceptors?.requestInterceptorCatch
  )
  // 可选的响应拦截
  this.instance.interceptors.response.use(
    this.interceptors?.responseInterceptor,
    this.interceptors?.responseInterceptorCatch
  )
}
```

刚刚所做的，是让原来constructor()传的config有可扩展性；

让别人不仅可以在新建**axios实例**时传入一些基本的属性，还可以传入拦截器；

还可以将**封装部分**和**类型定义**部分分离开，这样看起来不会乱；

services/request下的**type.ts**

```tsx
import type { AxiosRequestConfig, AxiosResponse } from 'axios'

export interface SFRequestInterceptors {
  // 可选的请求和响应拦截
  requestInterceptor?: (config: any) => any
  requestInterceptorCatch?: (error: any) => any
  responseInterceptor?: (res: AxiosResponse) => AxiosResponse
  responseInterceptorCatch?: (error: any) => any
}

export interface SFRequestConfig extends AxiosRequestConfig {
  interceptors?: SFRequestInterceptors
}

```

services/request下的**index.ts**

```tsx
import axios from 'axios'
import type { AxiosInstance, AxiosRequestConfig } from 'axios'
import type { SFRequestInterceptors, SFRequestConfig } from './type'

class SFRequest {
  instance: AxiosInstance
  // 可选的拦截器
  interceptors?: SFRequestInterceptors

  constructor(config: SFRequestConfig) {
    this.instance = axios.create(config)
    this.interceptors = config.interceptors
    // 可选的请求拦截
    this.instance.interceptors.request.use(
      this.interceptors?.requestInterceptor,
      this.interceptors?.requestInterceptorCatch
    )
    // 可选的响应拦截
    this.instance.interceptors.response.use(
      this.interceptors?.responseInterceptor,
      this.interceptors?.responseInterceptorCatch
    )
  }

  request(config: AxiosRequestConfig): void {
    this.instance.request(config).then((res) => {
      console.log(res)
    })
  }
}

export default SFRequest

```

services下的**index.ts**

```tsx
const sfRequest = new SFRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      console.log('请求成功的拦截')
      return config
    },
    requestInterceptorCatch: (err) => {
      console.log('请求失败的拦截')
      return err
    },
    responseInterceptor: (res) => {
      console.log('响应成功的拦截')
      return res
    },
    responseInterceptorCatch: (err) => {
      console.log('响应失败的拦截')
      return err
    }
  }
})
```

测试

```tsx
sfRequest.request({
  url: '/home/multidata',
  method: 'GET'
})
```

这是针对**某个axios实例**的封装，要是换个axios实例，拦截器又不一样了；

接下来继续封装一个针对**所有axios实例**都有的拦截器；

```tsx
class SFRequest {
  instance: AxiosInstance

  constructor(config: SFRequestConfig) {
    this.instance = axios.create(config)
    // 添加所有的实例都有的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        return config
      },
      (err) => {
        return err
      }
    )

    this.instance.interceptors.response.use(
      (res) => {
        return res
      },
      (err) => {
        return err
      }
    )
  }
}
```

还可以针对**某个请求**添加拦截器；

```tsx
// 针对某个请求的拦截
request(config: SFRequestConfig): void {
  if (config.interceptors?.requestInterceptor) {
    config = config.interceptors.requestInterceptor(config)
  }

  this.instance.request(config).then((res) => {
    if (config.interceptors?.responseInterceptor) {
      res = config.interceptors.responseInterceptor(res)
    }
    console.log(res)
  })
}
```

你可能不理解为什么要这么封装，那是因为还没见过某些复杂的业务；

比如一个项目有几十个请求，有的处理需要放到所有请求，这时就需要将这处理放到**所有实例**里；

有的处理**某个实例**才有，而有的处理**某个请求**才有；

慢慢去体会吧；

### 针对某个实例的拦截

携带token

```tsx
const sfRequest = new SFRequest({
  ...
  interceptors: {
    requestInterceptor: (config) => {
      // 携带token的拦截
      const token = 'xxx'
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      console.log('请求成功的拦截')
      return config
    }
    ...
  }
})

export default sfRequest

```

### 针对所有实例的拦截

当你在控制台打印响应数据，你会发现有这些属性：

- config
- data
- headers
- request
- statusText

这是因为axios对响应数据做了一层封装，其实你想要的不过是**data**属性里面的数据；

所以我们需要对**所有请求的响应**做一个拦截，只拿data，其它属性不拿；

```tsx
this.instance.interceptors.response.use(
  (res) => {
    return res.data
  },
  (err) => {
    return err
  }
)
```

### 添加一个请求是否显示loading动画的功能

目标：某个请求可以控制showLoading属性是否显示loading动画

```tsx
sfRequest.request({
  url: '/home/multidata',
  method: 'GET',
  showLoaing: false
})
```

首先，得在SFRequestConfig类型再加一个属性**showLoaing: boolean**,并且是可选的;

```tsx
interface SFRequestConfig extends AxiosRequestConfig {
  ...
  showLoading?: boolean
}
```

然后引入loading相关的组件和类型;

```tsx
import { ElLoading } from 'element-plus'
import { LoadingInstance } from 'element-plus/es/components/loading/src/loading'


class SFRequest {
  ...
  // loading相关类型
  showLoading: boolean
  loading?: LoadingInstance
}

```

```tsx
// 常量保存初始值
const DEFAULT_LOADING = true

class SFRequest {
  ...
  constructor(config: SFRequestConfig) {
    ...
    this.showLoading = config.showLoading ?? DEFAULT_LOADING
    // 添加所有的实例都有的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        if (this.showLoading) {
          this.loading = ElLoading.service({
            lock: true,
            text: '加载中...',
            background: 'rgba(0, 0, 0, 0.5)'
          })
        }
        return config
      }
    )
  }
}
```

当响应成功或失败都要移除loading

```tsx
this.instance.interceptors.response.use(
  (res) => {
    // 拿到数据则移除loading
    this.loading?.close()
    ...
  },
  (err) => {
    // 失败也要移除loading
    this.loading?.close()
	...
  }
)
```

针对每个请求

```tsx
request(config: SFRequestConfig): void {
  ...
  if (config.showLoading === false) {
    this.showLoading = config.showLoading
  }
  this.instance
    .request(config)
    .then((res) => {
      if (config.interceptors?.responseInterceptor) {
        res = config.interceptors.responseInterceptor(res)
      }
      console.log(res)
      this.showLoading = DEFAULT_LOADING
    })
    .catch((err) => {
      // 设置为默认值，这样不会影响下一个请求
      this.showLoading = DEFAULT_LOADING
      return err
  	})
}
```

### 使用Promis重构

```tsx
request<T>(config: SFRequestConfig): Promise<T> {
    return new Promise((resolve, reject) => {
      // 单个请求对config的处理
      if (config.interceptors?.requestInterceptor) {
        config = config.interceptors.requestInterceptor(config)
      }
      // 判断是否需要loading
      if (config.showLoading === false) {
        this.showLoading = config.showLoading
      }

      this.instance
        .request<any, T>(config)
        .then((res) => {
          // 单个请求对数据的处理
          if (config.interceptors?.responseInterceptor) {
            // res = config.interceptors.responseInterceptor(res)
          }
          this.showLoading = DEFAULT_LOADING
          resolve(res)
        })
        .catch((err) => {
          // 设置为默认值，这样不会影响下一个请求
          this.showLoading = DEFAULT_LOADING
          reject(err)
          return err
        })
    })
  }
```

```tsx
get<T>(config: SFRequestConfig): Promise<T> {
  return this.request<T>({ ...config, method: 'GET' })
}

post<T>(config: SFRequestConfig): Promise<T> {
  return this.request<T>({ ...config, method: 'POST' })
}

delete<T>(config: SFRequestConfig): Promise<T> {
  return this.request<T>({ ...config, method: 'Delete' })
}

patch<T>(config: SFRequestConfig): Promise<T> {
  return this.request<T>({ ...config, method: 'PATCH' })
}
```

使用

```tsx
interface DataType {
  data: any
  returnCode: string
  success: boolean
}
sfRequest
  .get<DataType>({
    url: '/home/multidata',
    showLoading: true
  })
  .then((res) => {
    console.log(res.data)
  })
```

# 3 项目内容

## 3.1 defineComponent

以前vue文件的script部分是这样的

```vue
<script>
    export default {
        
    }
</script>
```

现在变成了

```vue
<script lang="ts">
    import { defineComponent } from 'vue'
    export default defineComponent({
  		
	})
</script>
```

`lang="ts"` 表示可以写ts1代码；

**defineComponent()**的功能是传入什么对象就返回什么对象，在js的角度，这是没什么意义的；

但在ts角度，defineComponent()定义许多**类型声明**、**泛型**以及类型的默认值；

这样在该对象内就严格限制了该写什么属性，以及一些**类型推导**；

## 3.2 项目样式初始化

安装一个 **normalize.css**；

```
npm install normalize.css
```

自己也写点

**base.less**

```css
body {
  padding: 0;
  margin: 0;
}

html, body, #app {
  width: 100%;
  height: 100%;
}
```

统一出口**index.less**

```css
@import './base.less';
```

**main.ts**中引入；

```js
import 'normalize.css'
import './assets/css/index.less'
```

## 3.3 登陆组件

### 背景

```html
<div class="login"></div>
```

```css
.login {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
  background: url('../../assets/img/login-bg.svg');
}
```

### **login-panel.vue**

```html
<div class="login-panel">
  <h1 class="title">后台管理系统</h1>
  <el-tabs type="border-card" stretch>
    <el-tab-pane>
      <template #label>
        <el-icon><User /></el-icon>
        <span>账号登录</span>
      </template>
      <login-account></login-account>
    </el-tab-pane>
    <el-tab-pane>
      <template #label>
        <el-icon><Cellphone /></el-icon>
        <span>手机登录</span>
      </template>
      <login-phone></login-phone>
    </el-tab-pane>
  </el-tabs>
  <div class="account-control">
    <el-checkbox v-model="isKeepPassword">记住密码</el-checkbox>
    <el-link type="primary">忘记密码</el-link>
  </div>
  <el-button type="primary" class="login-btn" @click="login">立即登录</el-button>
</div>
```

```tsx
import { defineComponent, ref } from 'vue'
import { User, Cellphone } from '@element-plus/icons'
import LoginAccount from './login-account.vue'
import LoginPhone from './login-phone.vue'

components: {
  User,
  Cellphone,
  LoginAccount,
  LoginPhone
},
setup() {
  const isKeepPassword = ref(false)
  return {
    isKeepPassword
  }
}
```

```css
.login-panel {
  width: 320px;

  .title {
    text-align: center;
  }
  
  .account-control {
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
  }
    
  .login-btn {
    width: 100%;
    margin-top: 10px;
  }
}
```

isKeepPassword记录**是否记住密码**；

**ref()**对**isKeepPassword**进行响应式处理；

### 按需引入图标

element-plus改用了svg图标，不再是通过使用**i元素**，然后**修改类名**对应不同图标的方式；

安装 **@element-plus/icons**

```
npm install @element-plus/icons
```

在想用的vue文件中引入

```js
import { MoreFilled } from '@element-plus/icons'
```

局部注册

```js
components: {
  MoreFilled
}
```

结合el-icon使用

```html
<el-icon><MoreFilled /></el-icon>
```

### login-account.vue

```html
<div class="login-account">
  <el-form label-width="60px" :rules="rules" :model="account">
    <el-form-item label="账号" prop="name">
      <el-input v-model="account.name" />
    </el-form-item>
    <el-form-item label="密码" prop="password">
      <el-input v-model="account.password" show-password />
    </el-form-item>
  </el-form>
</div>
```

```tsx
import { defineComponent, reactive } from 'vue'
import { rules } from '../config/account-config'

setup() {
  // 用户信息
  const account = reactive({
    name: '',
    password: ''
  })
  return {
    account,
    rules
  }
}
```

使用**reactive()**对**account对象**进行**响应式处理**；

使用el-input的**v-model**实现**双向数据绑定**；

编写输入规则验证**rules**；

### account-config.ts

```js
// 输入校验规则
const rules = {
  name: [
    {
      required: true,
      message: '用户名是必传内容',
      trigger: 'blur'
    },
    {
      pattern: /^[a-z0-9]{5,10}$/,
      message: '用户名必须是5-10个字母或数字',
      trigger: 'blur'
    }
  ],
  password: [
    {
      required: true,
      message: '密码是必传内容',
      trigger: 'blur'
    },
    {
      pattern: /^[a-z0-9]{3,}$/,
      message: '密码必须是3位以上字母或数字',
      trigger: 'blur'
    }
  ]
}
```



### 配置文件和hook函数的抽离经验

如果使用到了**ref**、**reactive**、**useStore**、**onMounted**等等API，应该把相关代码抽离成一个**hook函数**；

而像rules这种输入校验规则应该抽离成**配置文件**；

### login-phone.vue

```html
<div class="login-phone">
  <el-form label-width="60px">
    <el-form-item label="手机号" prop="num">
      <el-input v-model="phone.num" />
    </el-form-item>
    <el-form-item label="验证码" prop="code">
      <div class="get-code">
        <el-input v-model="phone.code" />
        <el-button type="primary" class="get-btn">获取验证码</el-button>
      </div>
    </el-form-item>
  </el-form>
</div>
```

```tsx
import { defineComponent, reactive } from 'vue'

setup() {
  const phone = reactive({
    num: '',
    code: ''
  })

  return {
    phone
  }
}
```

```css
.get-code {
  display: flex;
}

.get-btn {
  margin-left: 8px;
}
```

### 登陆前逻辑

**登陆事件**login在login-panel组件；

而**账号和密码信息**在login-account或login-phone组件；

如果将**登陆逻辑**写在父组件login-panel里，可以通过**refs*获取子组件信息；

但是，login-panel将管理**2套**登陆逻辑：一套是**login-account**的，一套是**login-phone**的；

所以登陆逻辑子组件**各自负责**，才更为优雅~；

**login-panel.vue**

```html
<login-account ref="accountRef"></login-account>
```

使用**ref**获取子组件信息；

```tsx
import { defineComponent, ref } from 'vue'
import LoginAccount from './login-account.vue'

setup() {
  ...
  const accountRef = ref<InstanceType<typeof LoginAccount>>()

  const login = () => {
    accountRef.value?.loginAction()
  }
  return {
    ...
    accountRef,
    login
  }
}                                    
```

通过typeof LoginAccount获取组件**LoginAccount**的类型；

通过`<InstanceType<typeof LoginAccount>>`**泛型**限制accountRef的类型；

`accountRef.value?.loginAction()`可选链调用子组件的方法**loginAction()**；

而子组件的login-accoun的登陆逻辑是：

1. 验证数据是否符合规则；
2. 执行登陆逻辑；

#### **数据格式校验**

```html
<el-form ... ref="formRef">
  ...
</el-form>
```

```tsx
import { ElForm } from 'element-plus/lib/components'
import { ref } from 'vue'

setup() {
...
const formRef = ref<InstanceType<typeof ElForm>>()
const loginAction = () => {
  formRef.value?.validate((valid) => {
    if (valid) {
      ...
    }
  })
}
return {
  ...
  formRef,
  loginAction
}
```

使用**ref**获取子组件ElForm的信息；

**ElForm**组件有个**validate()**方法，它返回一个Boolean值；

验证通过则返回true，可以通过一个**回调函数的参数**接收这个Boolean值；

同样，通过`<InstanceType<typeof ElForm>>`泛型限制**formRef**的类型；



#### **记住密码**

如果验证通过，根据用户选择是否记住密码；

**login-account.vue**

```tsx
import { ElForm } from 'element-plus/lib/components'
import { reactive, ref } from 'vue'
import localCache from '@/utils/cache'

setup() {
  // 用户信息
  const account = reactive({
    name: localCache.getCache('name') ?? '',
    password: localCache.getCache('password') ?? ''
  })
  const formRef = ref<InstanceType<typeof ElForm>>()
  const loginAction = (isKeepPassword: boolean) => {
    formRef.value?.validate((valid) => {
      if (valid) {
        // 1.是否记住密码
        if (isKeepPassword) {
          // 本地缓存
          localCache.setCache('name', account.name)
          localCache.setCache('password', account.password)
        } else {
          localCache.deleteCache('name')
          localCache.deleteCache('password')
        }
        // 2.登陆验证
      }
    })
  }
  return {
    account,
    rules,
    formRef,
    loginAction
  }
}
```

**login-panel.vue**

```html
<el-checkbox v-model="isKeepPassword">记住密码</el-checkbox>
```

```tsx
import { ref } from 'vue'

setup() {
  const isKeepPassword = ref(false)
  const login = () => {
    accountRef.value?.loginAction(isKeepPassword.value)
  }
  return {
    isKeepPassword,
    login
  }
}
```

#### 登陆验证

发生网络请求

```tsx
import { useStore } from 'vuex'
import { ref } from 'vue'

setup() {
// 保存在Vuex的用户信息
const store = useStore()
...
const formRef = ref<InstanceType<typeof ElForm>>()
const loginAction = (isKeepPassword: boolean) => {
  formRef.value?.validate((valid) => {
    if (valid) {
      // 1.是否记住密码
      ...
      // 2.登陆验证
      store.dispatch('login/accountLoginAction', { ...account })
    }
  })
}
return {
  formRef,
  loginAction
}
```



### 两种登陆的判断

login-panel.vue

```html
<el-tabs type="border-card" stretch v-model="currentTab">
  <!-- 账号密码登陆 -->
  <el-tab-pane name="account">
    ...
  </el-tab-pane>
  <!-- 手机验证码登陆 -->
  <el-tab-pane name="phone">
    ...
  </el-tab-pane>
</el-tabs>
```

```tsx
setup() {
  // 属性
  // 记住密码
  const isKeepPassword = ref(false)
  // 当前登陆方式
  const accountRef = ref<InstanceType<typeof LoginAccount>>()
  const phoneRef = ref<InstanceType<typeof LoginAccount>>()
  // 当前登陆方式
  const currentTab = ref('account')
  // 方法
  const login = () => {
    if (currentTab.value === 'account') {
      accountRef.value?.loginAction(isKeepPassword.value)
    } else {
      // 手机验证码登陆的逻辑
    }
  }                       
  return {
    isKeepPassword,
    accountRef,
    phoneRef,
    currentTab,
    login
  }
}
```

el-tabs组件的**v-model**绑定**currentTab**；

el-tab-pane的name属性分别命名为**account**和**phone**；

使用ref分别**login-account**和**login-phone**的信息；

### cache.ts

封装一个缓存的工具

```tsx
class LocalCache {
  setCache(key: string, value: any) {
    // obj => string
    window.localStorage.setItem(key, JSON.stringify(value))
  }

  getCache(key: string) {
    // string => obj
    const value = window.localStorage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }

  deleteCache(key: string) {
    window.localStorage.removeItem(key)
  }

  clearCache() {
    window.localStorage.clear()
  }
}

export default new LocalCache()
```



### 获取一个组件的类型

组件都会`export default {}`导出一个**对象**；

另外的组件并**不是直接使用**这个对象，这个对象可以理解为**组件描述**；

而是根据这个对象创建出一个该对象的**组件实例**；

有点**类似一个类**的情况，我们使用类也是使用这个类的实例；

看这一行代码

```tsx
const formRef = ref<InstanceType<typeof ElForm>>()
```

**如果直接使用 ElForm 当泛型可以吗？**

**不行**，ElForm 是一个值，并不是一个类型；

所以要通过 **typeof** 获取 ElForm 的类型；

而 **InstanceType** 是ts中的语法， 它可以获取某个类型 **拥有构造函数的实例** ；

这样，就可以限制 **formRef** 获取到的是 **ElForm** 的**实例的类型**；

## 3.4 Vuex集成ts

### 登陆后逻辑

- **数据保存**到某一位置；
- 发生**其它网络请求**（比如请求当前用户的信息）；
- 拿到**用户的菜单**；
- **跳到首页**；

这些逻辑放**登陆组件**并不合适；

可以将这些逻辑放到**Vuex的actions**中；

#### login模块的状态管理

**login.ts**

```tsx
import { Module } from 'vuex'
import { ILoginState } from './type'
import { IRootState } from '../type'

const loginModule: Module<ILoginState, IRootState> = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: {}
    }
  },
  actions: {
    accountLoginAction({ commit }, payload: any) {
      console.log(commit, payload)
    },
    phoneLoginAction({ commit }, payload: any) {
      console.log(commit, payload)
    }
  }
}
```

Module需要两个泛型：

一个是**模块**中的state的类型；

另一个是**根模块**中的state类型；

login.ts同级目录下的**type.ts**

```tsx
export interface ILoginState {
  token: string
  userInfo: any
}
```

store/index.ts同级目录下的**type.ts**

```tsx
export interface IRootState {
  name: string
  age: number
}

```

store/**index.ts**

```tsx
import { createStore } from 'vuex'
import { IRootState } from './type'
import login from './login/login'

const store = createStore<IRootState>({
  state() {
    return {
      name: 'zsf',
      age: 18
    }
  },
  modules: {
    login
  }
})
```

#### 登陆的网络请求

该网络请求在Vuex中的actions中完成；

为了让异步请求的结果是顺序的，使用**async**和**await**关键字；

store/login/**login.ts**

```tsx
import { accountLoginRequest } from '@/services/login/login'
import { IAccount } from '@/services/login/type'

actions: {
  async accountLoginAction({ commit }, payload: IAccount) {
    // 1.登陆逻辑
    const loginResult = await accountLoginRequest(payload)
    console.log(loginResult)
  }
}
```

services/login/**login.ts**

```tsx
import sfRequest from '../index'

import { IAccount } from './type'
enum LoginAPI {
  AccountLogin = '/login'
}

export function accountLoginRequest(account: IAccount) {
  return sfRequest.post<IDataType<ILoginResult>>({
    url: LoginAPI.AccountLogin,
    data: account
  })
}
```

sfRequest.post()要求传入的是一个泛型，**传IDataType类型**；

而IDataType类型中的data也是泛型，传**ILoginResult类型**；

使用**枚举类型**切换不同登陆类型；

services/login/**type.ts**

```tsx
export interface IAccount {
  name: string
  password: string
}
export interface ILoginResult {
  id: number
  name: string
  token: string
}
export interface IDataType<T = any> {
  code: number
  data: T
}
```

已经拿到登陆成功后的数据了，需要**修改state**了，通过**mutations**；

#### 修改登陆相关state

store/login/**login.ts**

```tsx
mutations: {
  changeToken(state, token: string) {
    state.token = token
  }
}
actions: {
  async accountLoginAction({ commit }, payload: IAccount) {
    // 1.登陆逻辑
    const loginResult = await accountLoginRequest(payload)
    const { id, token } = loginResult.data
    commit('changeToken', token)
    // 将token保存到本地缓存
    localCache.setCache('token', state.token)
  }
}
```

#### 请求拦截

除登陆外的**其它请求**，需要拦截，拿到token，并根据token处理一下请求头的**Authorization**；

services/**index.ts**

```tsx
import SFRequest from './request'
import { BASE_URL, TIME_OUT } from './request/config'
import localCache from '@/utils/cache'

const sfRequest = new SFRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      // 携带token的拦截
      const token = localCache.getCache('token')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      console.log('请求成功的拦截')
      return config
    }
  }
})
```

#### 请求用户信息

services/login/**login.ts**

```tsx
import sfRequest from '../index'
import { IDataType } from './type'
enum LoginAPI {
  LoginUserInfo = '/users/' // 用法: /users/1
}
// 根据用户查询用户信息
export function requestUserInfoById(id: number) {
  return sfRequest.get<IDataType>({
    url: LoginAPI.LoginUserInfo + id,
    showLoading: false
  })
}
```

store/login/**login.ts**

```tsx
import {
  requestUserInfoById
} from '@/services/login/login'
import localCache from '@/utils/cache'

mutations: {
  changeUserInfo(state, userInfo: any) {
    state.userInfo = userInfo
  }
},
actions: {
  async accountLoginAction({ commit }, payload: IAccount) {
    // 1.登陆逻辑
    ...

    // 2.请求用户信息
    const userInfoResult = await requestUserInfoById(id)
    const userInfo = userInfoResult.data
    commit('changeUserInfo', userInfo)
    // 将userInfo保存到本地缓存
    localCache.setCache('userInfo', userInfo)
  }
}
```

#### 请求用户菜单

services/login/**login.ts**

```tsx
import sfRequest from '../index'
import { IDataType } from './type'
enum LoginAPI {
  UserMenus = '/role/' // 用法: role/1/menu
}
// 根据用户id请求菜单
export function requestUserMenusByRoleId(id: number) {
  return sfRequest.get<IDataType>({
    url: LoginAPI.UserMenus + id + '/menu',
    showLoading: false
  })
}

```

store/login/**login.ts**

```tsx
import { Module } from 'vuex'
import { ILoginState } from './type'
import { IRootState } from '../type'
import {
  requestUserMenusByRoleId
} from '@/services/login/login'
import localCache from '@/utils/cache'

const loginModule: Module<ILoginState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userMenus: []
    }
  },
  mutations: {
    // 修改用户菜单
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus
    }
  },
  actions: {
    async accountLoginAction({ commit }, payload: IAccount) {
      // 1.登陆逻辑
      ...

      // 2.请求用户信息
      ...

      // 3.请求用户菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      // 将userMenus保存到本地缓存
      localCache.setCache('userMenus', userMenus)
    }
  }
}

```

#### 跳到首页

store/login/**login.ts**

```tsx
import router from '@/router'

actions: {
  async accountLoginAction({ commit }, payload: IAccount) {
    // 1.登陆逻辑
    ...

    // 2.请求用户信息
    ...

    // 3.请求用户菜单
    ...

    // 4.跳到首页
    router.push('/main')
  }
}
```

如果登陆成功，则跳到首页；

如果登陆失败，则跳到登陆也；

这时需要**路由导航守卫**；

router/**index.ts**

```tsx

```

Vuex保存的数据在**内存**中，当用户刷新网页时，这些数据会消失掉；

**如何防止这一现象？**

store/**index.ts**

```tsx
export function setupStore() {
  store.dispatch('login/loadlocalLogin')
}
```

**main.ts**

```tsx
import { setupStore } from './store'

setupStore()
```

每次重新运行代码都会执行**setupStore()**;

store/login/**login.ts**

```tsx
import localCache from '@/utils/cache'

actions: {
  loadLocalLogin({ commit }) {
    const token = localCache.getCache('token')
    if (token) {
      commit('changeToken', token)
    }
    const userInfo = localCache.getCache('userInfo')
    if (userInfo) {
      commit('changeUserInfo', userInfo)
    }
    const userMenus = localCache.getCache('userMenus')
    if (userMenus) {
      commit('changeUserMenus', userMenus)
    }
  }
}
```

执行setupStore()后，Vuex中会**重新加载**用户数据；

## 3.5 首页内容

### 菜单组件

#### **main.vue**

```html
<div class="main">
  <el-container class="main-content">
    <el-aside>
      <nav-menu />
    </el-aside>
    <el-container class="page">
      <el-header class="page-header">
        <nav-header />
      </el-header>
      <el-main class="page-content">
        <div class="page-info">
          <router-view></router-view>
        </div>
      </el-main>
    </el-container>
  </el-container>
</div>
```

```css
.main {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.main-content,
.page {
  height: 100%;
}

.page-content {
  height: calc(100% - 48px);

  .page-info {
    background-color: #fff;
    border-radius: 5px;
  }
}

.el-header,
.el-footer {
  display: flex;
  color: #333;
  text-align: center;
  align-items: center;
}

.el-header {
  height: 48px !important;
}

.el-aside {
  overflow-x: hidden;
  overflow-y: auto;
  line-height: 200px;
  text-align: left;
  cursor: pointer;
  background-color: #001529;
  transition: width 0.3s linear;
  scrollbar-width: none; /* firefox */
  -ms-overflow-style: none; /* IE 10+ */

  &::-webkit-scrollbar {
    display: none;
  }
}

.el-main {
  color: #333;
  text-align: center;
  background-color: #f0f2f5;
}
```

components/nav-menu/src下的

#### **nav-menu.vue**

```html
<div class="nav-menu">
  <div class="logo">
    <img class="img" src="~@/assets/img/logo.svg" alt="logo" />
    <span class="title">Vue3+TS</span>
  </div>
  <el-menu
    :default-active="2"
    class="el-menu-vertical"
    background-color="#0c2135"
    text-color="#b7bdc3"
    active-text-color="#0a60bd"
    :unique-opened="true"
  >
    <template v-for="item in userMenus" :key="item.id">
      <!-- 二级菜单 -->
      <template v-if="item.type === 1">
        <!-- 二级菜单可以展开的标题 -->
        <el-sub-menu :index="item.id + ''">
          <template #title>
            <i v-if="item.icon" :class="item.icon"></i>
            <span>{{ item.name }}</span>
          </template>
          <!-- 遍历里面的item -->
          <template v-for="subitem in item.children" :key="subitem.id">
            <el-menu-item :index="subitem.id + ''">
              <i v-if="subitem.icon" :class="subitem.icon"></i>
              <span>{{ subitem.name }}</span>
            </el-menu-item>
          </template>
        </el-sub-menu>
      </template>
      <!-- 一级菜单 -->
      <template v-else-if="item.type === 2">
        <el-menu-item :index="item.id + ''">
          <i v-if="item.icon" :class="item.icon"></i>
          <span>{{ item.name }}</span>
        </el-menu-item>
      </template>
    </template>
  </el-menu>
</div>
```

```tsx
import { computed } from 'vue'
import { useStore } from '@/store'

setup() {
  const store = useStore()
  const userMenus = computed(() => store.state.login.userMenus)
  return {
    userMenus
  }
}
```

```css
.nav-menu {
  height: 100%;
  background-color: #001529;

  .logo {
    display: flex;
    height: 28px;
    padding: 12px 10px 8px 10px;
    flex-direction: row;
    justify-content: flex-start;
    align-items: center;

    .img {
      height: 100%;
      margin: 0 10px;
    }

    .title {
      font-size: 16px;
      font-weight: 700;
      color: white;
    }
    // 目录
    .el-submenu {
      background-color: #001529 !important;
      // 二级菜单 ( 默认背景 )
      .el-menu-item {
        padding-left: 50px !important;
        background-color: #0c2135 !important;
      }
    }

    ::v-deep .el-submenu__title {
      background-color: #001529 !important;
    }

    // hover 高亮
    .el-menu-item:hover {
      color: #fff !important; // 菜单
    }

    .el-menu-item.is-active {
      color: #fff !important;
      background-color: #0a60bd !important;
    }
  }

  .el-menu-vertical:not(.el-menu--collapse) {
    width: 100%;
    height: calc(100% - 48px);
  }
}
```

不建议直接在template中使用Vuex中的数据，写法很长，可以使用**计算属性**；

components/nav-menu下的

#### **index.ts**

```tsx
import NavMenu from './src/nav-menu.vue'

export default NavMenu

```

#### useStore()

Vuex对Ts的支持不太好，特别是**useStore()**;

自己来封装一个**useStore()**;

store/index.ts

```tsx
import { Store, useStore as useVuexStore } from 'vuex'
import { IStoreType } from './type'

export function useStore(): Store<IStoreType> {
  return useVuexStore()
}
```

封装的useStore()依然使用Vuex的**useStore()**实现，但对**类型的处理**更加友好；

防止useStore()重名，导入时起个**别名**；

store/type.ts

```tsx
import { ILoginState } from './login/type'
export interface IRootWithModule {
  login: ILoginState
}
export type IStoreType = IRootState & IRootWithModule

```

使用**交叉**类型拓展**IStoreType**类型；

components/nav-header下的

#### index.ts

```tsx
import NavHeader from './src/nav-header.vue'

export default NavHeader
```



#### 菜单栏的折叠

components/nav-header/src下的

**nav-header.vue**

```html
<div class="nav-header">
  <el-icon class="fold-menu" @click="handleFoldClick"><Expand /></el-icon>
</div>
```

```tsx
import { defineComponent, ref } from 'vue'
import { Expand } from '@element-plus/icons'

components: {
    Expand
  },
  emits: ['foldChange'],
  setup(props, { emit }) {
    const isFold = ref(false)
    const handleFoldClick = () => {
      isFold.value = !isFold.value
      // 发射事件通知父组件
      emit('foldChange', isFold.value)
    }
    return {
      isFold,
      handleFoldClick
    }
  }
```

```css
.nav-header {
  .fold-menu {
    font-size: 30px;
    cursor: pointer;
  }
}
```

监听**el-icon组件**的点击事件，当发生点击，会**发射事件**通知nav-menu组件是否折叠；

可以采用**事件总线**；

但**nav-menu**和**nav-header**组件有共同的父组件**main**;

nav-header组件**发射事件**给父组件main,通知main改变**isFold**；

选择这种做法还有一个重要原因，就是是否折叠会改变**父组件main.vue的里菜单栏**的宽度；

views/main下的**main.vue**

```html
<el-container class="main-content">
  <el-aside :width="isCollapse ? '60px' : '210px'">
    <nav-menu :collapse="isCollapse"/>
  </el-aside>
  <el-container class="page">
    <el-header class="page-header">
      <nav-header @foldChange="handleFoldChange" />
    </el-header>
    ...
  </el-container>
</el-container>
```

```tsx
import { ref } from 'vue'

setup() {
  // 菜单栏的折叠
  const isCollapse = ref(false)
  const handleFoldChange = (isFold: boolean) => {
    isCollapse.value = isFold
  }

  return {
    isCollapse,
    handleFoldChange
  }
}
```

同时nav-menu需要接收main传过来的**props**；

而菜单的文字折叠的时候，需要隐藏；

同时折叠时有个竖线，控制.el-menu的**border-right**去掉；

components/nav-menu/src下的

**nav-menu.vue**

```html
<div class="logo">
  ...
  <span v-if="!collapse" class="title">Vue3+TS</span>
</div>
<el-menu
  :collapse="collapse"
  ...
>
  ...
</el-menu>
```

```tsx
props: {
  collapse: {
    type: Boolean,
    default: false
  }
}
```

```css
.el-menu {
   border-right: none;
 }
```

### 权限控制

根据登陆角色的不同，菜单的内容是不同的，也就是说，**路由配置是动态的**；

当然，也可以把所有路由都注册，写死，但是有个**隐患**；

比如**普通用户**kobe，没有**商品管理**这个路由的**访问权限**，但是kobe要是**手动**地在浏览器输入商品管理对应的路由，它是能够看到**商品管理组件**中的内容的，这是不希望出现的；

还有一种做法，就是前端提前写好**不同角色**的所有路由，当用户登陆之后，根据**用户信息**中的**role**数据去注册该角色对应的路由；

但是这种方式还有一个**弊端**：当后端**新增角色**时，要修改前端的代码，然后**重新部署**；

还有一种方式，**动态注册路由**；

后端返回的用户信息里面包含role数据，前端拿到**role数据**后，菜单动态的生成；

### 动态注册路由

main的子路由是动态的，是根据**用户信息**的userMenus来决定的；

动态注册路由可以放在**路由导航守卫**里，也可以放在**Vuex的mutations**中；

utils下的

**map-routes.ts**

```tsx
import { RouteRecordRaw } from 'vue-router'

export function mapMenuToRoutes(userMenus: any[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = []
  // 1.先去加载默认所有的routes
  const allRoutes: RouteRecordRaw[] = []
  const routeFiles = require.context('../router/main', true, /\.ts/)
  routeFiles.keys().forEach((key) => {
    // 处理拿到的路径
    const route = require('../router/main' + key.split('.')[1])
    allRoutes.push(route.default)
  })
  console.log(allRoutes)

  // 2.根据菜单获取需要的添加的routes

  // 递归获取routes
  const _recurseGetRoute = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 2) {
        const route = allRoutes.find((route) => route.path === menu.url)
        if (route) routes.push(route)
      } else {
        _recurseGetRoute(menu.children)
      }
    }
  }

  _recurseGetRoute(userMenus)

  return routes
}

```

**递归**地匹配**某个目录**下**符合条件**的文件；

这里使用了webpack的request.**context()**，context()方法接收3个参数：第1个是**目录**，第2个是是否**递归**，第3个是**正则表达式**;

然后使用**split()**处理一下拿到的路径，再放进**allRoutes**；

遍历**userMenus**，如果是二级路由，就使用**find()**在所有路由中筛选出**符合条件**的路由，放进**routes**中；

如果是不是二级路由，就从它的**子路由**开始递归；

store/login下的

**login.ts**

```tsx
import { mapMenuToRoutes } from '@/utils/map-menus'

mutations: {
  // 修改用户菜单
  changeUserMenus(state, userMenus: any) {
    state.userMenus = userMenus

    // userMenus映射成routes
    const routes = mapMenuToRoutes(userMenus)

    // routes放进main的子路由中
    routes.forEach((route) => {
      router.addRoute('main', route)
    })
  }
}
```

使用router的**addRoute()**,将路由添加进main的子路由；

监听菜单项的点击，进行路由跳转；

**nav-menu.vue**

```html
<el-menu-item
  :index="subitem.id + ''"
  @click="handleMenuItemClick(subitem)"
>
  <i v-if="subitem.icon" :class="subitem.icon"></i>
  <span>{{ subitem.name }}</span>
</el-menu-item>
```

```tsx
import { useRouter } from 'vue-router'

setup() {
  // router
  const router = useRouter()

  // event handle
  const handleMenuItemClick = (item: any) => {
    router.push({
      path: item.url ?? '/not-found'
    })
  }
  return {
    handleMenuItemClick
  }
}
```

最后记得加**路由占位符**

views/main下的

**main.vue**

```html
<el-main class="page-content">
  <div class="page-info">
    <router-view></router-view>
  </div>
</el-main>
```



### 自动生成路由配置和生成组件工具

使用coderwhy这个工具，快速生成组件和对应路由配置；

**全局安装**

```
npm install coderwhy -g
```

使用命令创建组件和路由配置

```
coderwhy add3page [组件名] -d [目录]
```

例如，`coderwhy add3page user -d src/views/main/system/user`

后面是目录

### not found

路由配置

```tsx
{
  path: '/:pathMatch(.*)*',
  name: 'not-found',
  component: () => import('@/views/not-found/not-found.vue')
}
```

views/not-found下的

**not-found.vue**

```
<div>
  <h2>Not Found</h2>
</div>
```

### 用户信息

components/nav-header/src下的

**nav-header.vue**

```html
<div class="content">
  <user-info></user-info>
</div>
```

```tsx
import UserInfo from './user-info.vue'

components: {
  UserInfo
}
```

```css
.nav-header {
  display: flex;
  width: 100%;
  
  .content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex: 1;
    padding: 0 20px;
  }
}
```

components/nav-header/src下的

**user-info.vue**

```html
<div class="user-info">
  <el-dropdown>
    <span class="el-dropdown-link">
      <el-avatar
        size="small"
        src="https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png"
      ></el-avatar>
      <span>{{ name }}</span>
    </span>
    <template #dropdown>
      <el-dropdown-menu>
        <el-dropdown-item icon="el-icon-circle-close"
          >退出登录</el-dropdown-item
        >
        <el-dropdown-item divided>用户信息</el-dropdown-item>
        <el-dropdown-item>系统管理</el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</div>
```

```tsx
import { computed } from 'vue'
import { useStore } from '@/store'

setup() {
    const store = useStore()
    const name = computed(() => store.state.login.userInfo.name)
    return {
      name
    }
  }
```

```css
.el-dropdown-link {
  cursor: pointer;
  display: flex;
  align-items: center;
}
```

### 面包屑

如何拿到面包屑中的**路径和对应名字**呢？

components/nav-header下的

**nav-header.vue**

```html
<div class="content">
  <sf-breadcrumb :breadcrumbs="breadcrumbs"></sf-breadcrumb>
</div>
```

```tsx
import { computed, ref } from 'vue'
import SfBreadcrumb from '@/base-ui/breadcrumb'
import { useStore } from 'vuex'
import { useRoute } from 'vue-router'
import { pathMapBreadcrumbs } from '@/utils/map-menus'

components: {
  ...
  SfBreadcrumb
},
setup(props, { emit }) {
  ...
  // 面包屑数据
  const store = useStore()
  const breadcrumbs = computed(() => {
    const userMenus = store.state.login.userMenus
    const route = useRoute()
    const currentPath = route.path
    return pathMapBreadcrumbs(userMenus, currentPath)
  })

  return {
    ...
    breadcrumbs
  }
}
```

utils下的

**map-menus.ts**

```tsx
import { IBreadcrumb } from '@/base-ui/breadcrumb/types'

// 根据currenPath和userMenu匹配出面包屑
export function pathMapBreadcrumbs(userMenus: any[], currentPath: string) {
  const breadcrumbs: IBreadcrumb[] = []
  pathMapToMenu(userMenus, currentPath, breadcrumbs)
  return breadcrumbs
}

// 根据路径转化成菜单
export function pathMapToMenu(
  userMenus: any[],
  currentPath: string,
  breadcrumbs?: IBreadcrumb[]
): any {
  // 遍历userMenus
  for (const menu of userMenus) {
    // 如果是一级菜单
    if (menu.type === 1) {
      const findMenu = pathMapToMenu(menu.children ?? [], currentPath)
      if (findMenu) {
        // 将一级菜单和二级菜单的名字和对应路径放进breadcrumbs
        breadcrumbs?.push({ name: menu.name, path: menu.url })
        breadcrumbs?.push({ name: findMenu.name, path: findMenu.url })
        return findMenu
      }
      // 如果是二级菜单并且是当前菜单项
    } ...
  }
}
```

base-ui/breadcrumb下的

**index.ts**

```tsx
import SfBreadcrumb from './src/breadcrumb.vue'

export * from './types'

export default SfBreadcrumb
```

base-ui/breadcrumb/src下的

**breadcrumb.vue**

```html
<div class="nav-breadcrumb">
  <el-breadcrumb separator="/">
    <template v-for="item in breadcrumbs" :key="item.name">
      <el-breadcrumb-item :to="{ path: item.path }">{{
        item.name
      }}</el-breadcrumb-item>
    </template>
  </el-breadcrumb>
</div>
```

```tsx
import { PropType } from 'vue'
import { IBreadcrumb } from '../types'

props: {
  breadcrumbs: {
    type: Array as PropType<IBreadcrumb[]>,
    default: () => []
  }
}
```

base-ui/breadcrumb/types下的

**index.ts**

```tsx
export interface IBreadcrumb {
  name: string
  path?: string
}
```



## 3.6 用户管理

### 封装page-search组件

封装一个**搜索框**，很多组件都用的到，而且可以通过**配置**快速生成不同的内容的搜索框；

#### 基本封装

view/main/system/user下的

**user.vue**

```html
<div class="user">
  <div class="search">
    <sf-form :formItems="formItems"></sf-form>
  </div>
</div>
```

```tsx
import SfForm, { IFormItem } from '@/base-ui/form'

components: {
  SfForm
},
setup() {
  const formItems: IFormItem[] = [
    {
      type: 'input',
      label: '用户名',
      placeholder: '请输入用户名'
    },
    {
      type: 'password',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      type: 'select',
      label: '喜欢的运动',
      placeholder: '请选择喜欢的运动',
      options: [
        { title: '篮球', value: 'baseketball' },
        { title: '足球', value: 'football' }
      ]
    },
    {
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
  return {
    formItems
  }
}
```

user组件的**搜索框部分**使用自己封装的**组件sf-form**；

遍历formItems，生成表单项；

其中，formItems就像**配置**一样，想生成不同的表单项，只要修改formItems相关内容；

base-ui/form下的

**index.ts** 统一出口

```tsx
import SfForm from './src/form.vue'
export * from './types'
export default SfForm
```

base-ui/form/types下的

**index.ts**

```tsx
type IFormType = 'input' | 'password' | 'select' | 'datepicker'
export interface IFormItem {
  type: IFormType
  label: string
  rules?: any[]
  placeholder?: any
  // 针对select
  options?: any[]
  // 针对特殊的属性
  otherOptions?: any
}

```

base-ui/form/src下的

**form.vue**

```html
<div class="sf-form">
  <el-form label-width="100px">
    <el-row>
      <template v-for="item in formItems" :key="item.label">
        <el-col :span="8">
          <el-form-item :label="item.label">
            <template
              v-if="item.type === 'input' || item.type === 'password'"
            >
              <el-input
                :placeholder="item.placeholder"
                v-bind="item.otherOptions"
                :show-password="item.type === 'password'"
              />
            </template>
            <template v-else-if="item.type === 'select'">
              <el-select
                :placeholder="item.placeholder"
                v-bind="item.otherOptions"
                style="width: 100%"
              >
                <el-option
                  v-for="option in item.options"
                  :key="option.value"
                  :value="option.value"
                  >{{ option.title }}</el-option
                >
              </el-select>
            </template>
            <template v-else-if="item.type === 'datepicker'">
              <el-date-picker
                style="width: 100%"
                v-bind="item.otherOptions"
              ></el-date-picker>
            </template>
          </el-form-item>
        </el-col>
      </template>
    </el-row>
  </el-form>
</div>
```

```tsx
import { PropType } from 'vue'
import { IFormItem } from '../types'

props: {
  formItems: {
    type: Array as PropType<IFormItem[]>,
    dafault: () => []
  }
}

```

使用el-row和el-col实现**栅格布局**，一行最多三个表单项；

props中的默认值要是数组或对象，需要写成**箭头函数**；

#### 新增几个可传属性

base-ui/form/src下的

**form.vue**

```html
<el-form :label-width="labelWidth" :itemStyle="itemStyle">
  ...
</el-form>
```

```tsx
props: {
  labelWidth: {
    type: String,
    default: '100px'
  },
  itemStyle: {
    type: Object,
    default: () => ({ padding: '10px 40px' })
  }
}
```

view/main/system/user下的

**user.vue**

```html
<sf-form :labelWidth="labelWidth" :itemStyle="itemStyle"></sf-form>
```

```tsx
setup() {
  const labelWidth = '120px'
  const itemStyle = {
    padding: '20px 60px'
  }
  return {
    labelWidth,
    itemStyle
  }
}
```

#### 布局响应式处理

现在存在一个问题，由于设置了一行最多三个表单项，当将页面宽度很小时，表单项的输入框会变得非常小，难以输入；

所以el-col中的span属性不能写死，而是根据屏幕自动变化；

base-ui/form/src下的

**form.vue**

```html
<el-col v-bind="colLayout">
  ...
</el-col>
```

```tsx
props: {
  colLayout: {
    type: Object,
    default: () => ({
      xl: 6, // >1920px 4个
      lg: 8,
      md: 12,
      sm: 24,
      xs: 24
    })
  }
}
```

#### 合并属性

base-ui/form/types下的

**index.ts**

```tsx
export interface IForm {
  formItems: IFormItem[]
  labelWidth?: string
  colLayout?: any
  itemLayout?: any
}
```

view/main/system/user下的

**user.vue**

```html
<sf-form v-bind="formConfig"></sf-form>
```

```tsx
import { IForm } from '@/base-ui/form'

setup() {
  const formConfig: IForm = {
    labelWidth: '120px',
    itemLayout: {
      padding: '10px 40px'
    },
    formItems: [
      {
        type: 'input',
        label: '用户名',
        placeholder: '请输入用户名'
      },
      {
        type: 'password',
        label: '密码',
        placeholder: '请输入密码'
      },
      {
        type: 'select',
        label: '喜欢的运动',
        placeholder: '请选择喜欢的运动',
        options: [
          { title: '篮球', value: 'baseketball' },
          { title: '足球', value: 'football' }
        ]
      },
      {
        type: 'datepicker',
        label: '创建时间',
        otherOptions: {
          startPlaceholder: '开始时间',
          endPlaceholder: '结束时间',
          type: 'daterange'
        }
      }
    ]
  }
  return {
    formConfig
  }
}
```

#### 抽离属性成配置文件

views/main/system/user/config下的

**search.config.ts**

```tsx
import { IForm } from '@/base-ui/form'

export const searchFormConfig: IForm = {
  labelWidth: '120px',
  itemLayout: {
    padding: '10px 40px'
  },
  formItems: [
    {
      type: 'input',
      label: '用户名',
      placeholder: '请输入用户名'
    },
    {
      type: 'password',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      type: 'select',
      label: '喜欢的运动',
      placeholder: '请选择喜欢的运动',
      options: [
        { title: '篮球', value: 'baseketball' },
        { title: '足球', value: 'football' }
      ]
    },
    {
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
}

```

view/main/system/user下的

**user.vue**

```html
<sf-form v-bind="searchFormConfig"></sf-form>
```

```tsx
import { searchFormConfig } from './config/search.config'

setup() {
  return {
    searchFormConfig
  }
}
```

#### 使用v-model获取用户数据

需要收集数据在组件form里，而组件user使用了组件form；

父组件**user**应该将用户信息收集起来，放进一个对象中；

view/main/system/user下的

**user.vue**

```html
<div class="user">
  <sf-form v-bind="searchFormConfig" :formData="formData"></sf-form>
</div>
```

```tsx
import { reactive } from 'vue'

setup() {
  const formData = reactive({
    id: '',
    name: '',
    password: '',
    sport: '',
    createTime: ''
  })
  return {
    formData
  }
}
```

配置文件的**formItems**多加一项**field**；

view/main/system/user/config下的

**search.config.ts**

```js
{
  field: 'id',
  type: 'input',
  label: 'id',
  placeholder: '请输入id'
}
```

IForm类型多加一项限制；

base-ui/form/types下的

**index.ts**

```tsx
export interface IFormItem {
  field: string
  ...
}
```

base-ui/form/src下的

**form.vue**

```html
<el-input
  ...
  v-model="formData[`${item.field}`]"
/>
```

```tsx
props: {
  formData: {
    type: Object,
    required: true
  }
  ...
}
```

虽然这种方式可以获取到组件form中的用户数据，但是**不推荐子组件通过props去修改props里面的属性**；

这违反了**单向数据流**的设计思想，**子组件**的数据变化会导致**父组件**的数据发生变化；

组件**user**将**formData**的引用传给了子组件**form**，不推荐**子组件修改父组件的formData**；

而是应该子组件**发射事件通知**父组件去修改**formData**；

view/main/system/user下的

**user.vue**

```html
<div class="user">
  <sf-form v-bind="searchFormConfig" v-model="formData"></sf-form>
</div>
```



base-ui/form/src下的

**form.vue**

```html
<el-input
  ...
  v-model="formData[`${item.field}`]"
/>
```

```tsx
import { ref, watch } from 'vue'

props: {
  modelValue: {
    type: Object,
    required: true
  }
  ...
},
emits: ['update:modelValue'],
setup(props, { emit }) {
  const formData = ref({ ...props.modelValue })

  watch(
    formData,
    (newValue) => {
      emit('update:modelValue', newValue)
    },
    {
      deep: true
    }
  )
  return {
    formData
  }
}
```

父组件使用**sf-form**使用v-model绑定**formData**；

子组件**form**使用**props的modelValue**接收父组件sf-form传过来的formData；

然后利用**对象的展开语法**，复制一份formData的内容（这里不再是对父组件数据的引用啦）；

然后使用watch监听子组件的formData的改变，还要深度监听，因为改的是formData的属性；

当有值变化时就使用**emit**发射**update:modelValue**事件，通知父组件**sf-form**,修改父组件的**formData**；

#### 优化搜索表单

有些页面的表单可能有header或者搜索按钮，有些没有，所以需要**灵活切换**；

所以需要**插槽**，使用者可以**灵活拓展**；

base-ui/form/src下的

**form.vue**

```html
<div class="sf-form">
  <div class="header">
    <slot name="header"></slot>
  </div>
  <el-form :label-width="labelWidth">
    ...
  </el-form>
  <div class="footer">
    <slot name="footer"></slot>
  </div>
</div>
```

views/main/system/user下的

**user.vue**

```html
<sf-form v-bind="searchFormConfig" v-model="formData">
  <template #header>
    <h1 class="header">高级检索</h1>
  </template>
  <template #footer>
    <div class="handle-btns">
      <el-button>重置</el-button>
      <el-button type="primary">搜索</el-button>
    </div>
  </template>
</sf-form>
```

```css
.handle-btns {
  text-align: right;
  padding: 0 50px 20px 0;
}
```

两个靠的很近，margin会穿透，所以用padding；

#### 进一步封装

views/main/system/user下的

**user.vue**

```html
<div class="user">
  <page-search :searchFormConfig="searchFormConfig"></page-search>
</div>
```

```tsx
import { searchFormConfig } from './config/search.config'
import PageSearch from '@/components/page-search'

components: {
  PageSearch
},
setup() {
  return {
    searchFormConfig
  }
}
```

这样你会发现：我们开发这些**高可复用性**的组件，只需要**注册使用**并**传配置**就可以了；

components/page-search/src下的

**page-search.vue**

```html
<div class="page-search">
  <sf-form v-bind="searchFormConfig" v-model="formData">
    <template #header>
      <h1 class="header">高级检索</h1>
    </template>
    <template #footer>
      <div class="handle-btns">
        <el-button>重置</el-button>
        <el-button type="primary">搜索</el-button>
      </div>
    </template>
  </sf-form>
</div>
```

```tsx
import { ref } from 'vue'
import SfForm from '@/base-ui/form'

components: {
  SfForm
},
props: {
  searchFormConfig: {
    type: Object,
    required: true
  }
},
setup() {
  const formData = ref({
    id: '',
    name: '',
    password: '',
    sport: '',
    createTime: ''
  })
  return {
    formData
  }
}
```

```css
.handle-btns {
  text-align: right;
  padding: 0 50px 20px 0;
}
```

components/page-search下的

**index.ts**

```tsx
import PageSearch from './src/page-search.vue'
export default PageSearch
```



### 解决刷新notFound

在路由守卫导航打印**to**时，发现路径匹配到notFound;

所以：**路径和组件匹配不正确**;

路径是没问题的，但是匹配到的组件不对;

为什么出现这样的结果？

刷新页面时，代码重新执行，当执行**app.use(router)**时，或执行router的**install()**;

install()会获取**当前的path**，获取到path之后，就会去**router.routes**里去匹配；

但是，由于我们是**动态注册路由**的，此时还没有对应的路由，所以是**notFound**；

当我们执行**setupStore()**后,已经注册动态路由了，此时所有的**routes**已经全部有了；

所以调换一下**setupStore()**和**app.use(router)**的执行顺序就行，setupStore()在前，app.use(router)在后；

### 解决刷新后菜单的选中问题

使用**el-menu**时，设置了属性**default-active="2"**，所以刷新后菜单项的选中会第二个；

所以这属性**不能设置为确定的值**；

当刷新页面后，可以拿到**路径**，然后根据路径匹配menu，然后拿到**menu.id**作为**defaultValue**；

utils下的

**map-menus.ts**

```tsx
// 根据路径转化成菜单
export function pathMapToMenu(userMenus: any[], currentPath: string): any {
  // 遍历userMenus
  for (const menu of userMenus) {
    // 如果是一级菜单
    if (menu.type === 1) {
      const findMenu = pathMapToMenu(menu.children ?? [], currentPath)
      if (findMenu) {
        return findMenu
      }
      // 如果是二级菜单并且是当前菜单项
    } else if (menu.type === 2 && menu.url === currentPath) {
      return menu
    }
  }
}
```

component/nav-menu/src下的

**nav-menu.vue**

```tsx
import { useRoute } from 'vue-router'
import { pathMapToMenu } from '@/utils/map-menus'

setup() {
    const route = useRoute()
    const currentPath = route.path
    
    // data
    const menu = pathMapToMenu(userMenus.value, currentPath)
    const defaultValue = ref(menu.id + '')
    
    return {
      userMenus,
      handleMenuItemClick,
      defaultValue
    }
}
```

### 解决刚进来menu为空的问题

当路由匹配到**'/'**时，重定向到**'/main'**，此时单独的main没有匹配到菜单，menu是**undefined**；

所以当路径是**'/main'**时，还需要**重定向**，一般默认重定向到二级菜单的第一项；

怎么样才能拿到**二级菜单的第一项**呢？

**mapMenuToRoutes()**中遍历**userMenus**时，可以拿到二级菜单，此时可以将这些**二级菜单**保留下来；

要在哪里使用**firstMenu**呢？

**路由导航守卫**的to；

utils下的

**map-menus.ts**

```tsx
// 保留userMenus的二级菜单
let firstMenu: any = null

// 递归获取routes
const _recurseGetRoute = (menus: any[]) => {
  for (const menu of menus) {
    if (menu.type === 2) {
      ...
      // 保留二级菜单的第一项
      if (!firstMenu) {
        firstMenu = menu
      }
    } else {
      _recurseGetRoute(menu.children)
    }
  }
}
```

router下的

**index.ts**

```tsx
import { firstMenu } from '@/utils/map-menus'

// 导航守卫
router.beforeEach((to) => {
  ...

  if (to.path === '/main') {
    return firstMenu.url
  }
})
```

### 封装page-content组件

#### Vuex中的system模块

store/main/system下的

**system.ts**

```tsx
import { Module } from 'vuex'
import { IRootState } from '@/store/types'
import { ISystemState } from './types'
const systemModule: Module<ISystemState, IRootState> = {
  state() {
    return {
      userList: [],
      userCount: 0
    }
  }
}

export default systemModule
```

store/main/system下的

**types.ts**

```tsx
export interface ISystemState {
  userList: any[]
  userCount: number
}
```

store下的

**index.ts**

```tsx
import { createStore } from 'vuex'
import { IRootState } from './types'
import system from './main/system/system'

const store = createStore<IRootState>({
  state() {
    return {
      ...
    }
  },
  modules: {
    ...
    system
  }
})
```

store下的

**types.ts**

```tsx
import { ISystemState } from './main/system/types'

export interface IRootWithModule {
  system: ISystemState
}
```

#### 获取列表数据

views/main/system/user下的

**user.vue**

```tsx
import { useStore } from 'vuex'

setup() {
  const store = useStore()
  store.dispatch('system/getPageListAction', {
    pageUrl: '/users/list',
    queryInfo: {
      offset: 0,
      size: 10
    }
  })
}
```

store/main/system下的

**system.ts**

```tsx
import { getPageListData } from '@/services/main/system/system'

mutations: {
  changeUserList(state, userList: any[]) {
    state.userList = userList
  },
  changeUserCount(state, userCount: number) {
    state.userCount = userCount
  }
},
actions: {
  async getPageListAction({ commit }, payload: any) {
    // 1.发送页面请求
    const pageResult = await getPageListData(
      payload.pageUrl,
      payload.queryInfo
    )
    const { list, totalCount } = pageResult.data
    commit('changeUserList', list)
    commit('changeserCount', totalCount)
  }
}
```

services/main/system下的

**system.ts**

```tsx
import { IDataType } from '@/services/types'
import sfRequest from '@/services'

export function getPageListData(url: string, queryInfo: any) {
  return sfRequest.post<IDataType>({
    url: url,
    data: queryInfo
  })
}
```

services下的

**types.ts**

```tsx
export interface IDataType<T = any> {
  code: number
  data: T
}
```

#### 展示列表数据

views/main/system/user下的

**user.vue**

```html
<!-- 列表部分 -->
<div class="content">
  <el-table :data="userList" border style="width: 100%">
    <template v-for="propItem in propList" :key="propItem.prop">
      <el-table-column v-bind="propItem" align="center"></el-table-column>
    </template>
  </el-table>
</div>
```

```tsx
import { computed } from 'vue'

setup() {    
  const userList = computed(() => store.state.system.userList)
  const propList = [
    { prop: 'name', label: '用户名', minwidth: '100' },
    { prop: 'realname', label: '真实姓名', minwidth: '100' },
    { prop: 'cellphone', label: '手机号码', minwidth: '100' },
    { prop: 'enable', label: '状态', minwidth: '100' },
    { prop: 'creatAt', label: '创建时间', minwidth: '250' },
    { prop: 'updateAt', label: '更新时间', minwidth: '250' }
  ]
  return {
    userList,
    propList
  }
}
```

用配置化的属性**propList**替代重复的组件**el-table-column**，然后用**v-bind**属性绑定；

不然就会有大量的组件**el-table-column**；

#### 封装

views/main/system/user下的

**user.vue**

```html
<!-- 列表部分 -->
<div class="content">
  <sf-table :listData="userList" :propsList="propList"></sf-table>
</div>
```

```tsx
import SfTable from '@/base-ui/table'

components: {
  SfTable
}
```

base-ui/table/src下的

**table.vue**

```html
<div class="sf-table">
  <el-table :data="listData" border style="width: 100%">
    <template v-for="propItem in propsList" :key="propItem.prop">
      <el-table-column v-bind="propItem" align="center"></el-table-column>
    </template>
  </el-table>
</div>
```

```tsx
props: {
  listData: {
    type: Array,
    required: true
  },
  propsList: {
    type: Array,
    required: true
  }
}
```

base-ui/table下的

**index.ts**

```tsx
import SfTable from './src/table.vue'

export default SfTable

```

#### 处理某些列表数据

比如状态那一栏，显示是1，要显示成状态按钮；

这时需要**转化**，所以在**作用域插槽**的数据不能写死；

再在作用域插槽里面放**命名插槽**；

也可以有默认值**scope.row[propItem.prop]**；

而**插槽名**也不能写死，因为**有些列**的数据才需要转化，这时需要用到**动态插槽**；

所以列表项要多加一个属性**slotName**；

这样想改哪个插槽，就只会针对那个插槽，这样就实现了**按需转化**；

base-ui/table/src下的

**table.vue**

```html
<template v-for="propItem in propsList" :key="propItem.prop">
  <el-table-column v-bind="propItem" align="center">
    <template #default="scope">
      <slot :name="propItem.slotName" :row="scope.row">
        {{ scope.row[propItem.prop] }}
      </slot>
    </template>
  </el-table-column>
</template>
```



```html
<sf-table :listData="userList" :propsList="propList">
  <template #status="scope"
    ><el-button
      >{{ scope.row.enable ? '启用' : '禁用' }}
    </el-button></template
  >
  <template #createAt="scope">
    <strong>{{ scope.row.createAt }}</strong>
  </template>
</sf-table>
```

views/main/system/user下的

**user.vue**

```tsx
const propList = [
  { prop: 'name', label: '用户名', minwidth: '100' },
  { prop: 'realname', label: '真实姓名', minwidth: '100' },
  { prop: 'cellphone', label: '手机号码', minwidth: '100' },
  { prop: 'enable', label: '状态', minwidth: '100', slotName: 'status' },
  {
    prop: 'createAt',
    label: '创建时间',
    minwidth: '250',
    slotName: 'createAt'
  },
  {
    prop: 'updateAt',
    label: '更新时间',
    minwidth: '250',
    slotName: 'updateAt'
  }
]
```

#### 格式化时间

添加一个全局对象，$fiters,该对象有格式化时间的方法，这样任何地方都可使用；

views/main/system/user下的

**user.vue**

```html
<strong>{{ $filters.formatTime(scope.row.createAt) }}</strong>
```

global下的

**index.ts**

```tsx
import { App } from 'vue'
import { registerProperties } from './register-properties'

export function globalRegister(app: App): void {
  app.use(registerProperties)
}
```

global下的

**register-properties.ts**

```tsx
import { formatUtcString } from '@/utils/data-format'
import { App } from 'vue'

export function registerProperties(app: App) {
  app.config.globalProperties.$filters = {
    formatTime(value: string) {
      return formatUtcString(value)
    }
  }
}
```

**main.ts**

```tsx
import { globalRegister } from './global'

app.use(globalRegister)
```

使用dayjs第三方库；

utils下的**date-format.ts**

```tsx
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

dayjs.extend(utc)

const DATE_TIME_FORMAT = 'YYYY-MM-DD HH:mm:ss'
export function formatUtcString(
  utcString: string,
  format: string = DATE_TIME_FORMAT
) {
  return dayjs.utc(utcString).format(format)
}

```

#### 是否要序号列

base-ui/table/src下的

**table.vue**

```html
<el-table :data="listData" border style="width: 100%">
  <el-table-column
    v-if="showIndexColum"
    type="index"
    label="序号"
    align="center"
    width="80"
  ></el-table-column>
</el-table>
```

```tsx
props: {
  showIndexColumn: {
    type: Boolean,
    default: false
  }
}
```

#### 是否可选中列

base-ui/table/src下的

**table.vue**

```html
<el-table @selection-change="handleSelectionChange">
  <el-table-column
    v-if="showSelectColumn"
    type="selection"
    align="center"
    width="80"
  ></el-table-column> 
</el-table>
```

```tsx
props: {
  showSelectColumn: {
    type: Boolean,
    default: false
  }
},
emit: ['selectionChange'],
setup() {
  const handleSelectionChange = (value: any) => {
    emit('selectionChange', value)
  }
  return {
    handleSelectionChange
  }
}
```

**el-table**的**selection-change**事件能拿到的选中行的数据，传递给**handleSelectionChange**()；

但是拿到数据这个操作是在**子组件table**中进行的，一般都需要发出去给父组件处理；

#### 操作列

views/main/system/user下的

**user.vue**

```html
<template #handler>
  <div class="handle-btns">
    <el-button size="small" type="primary">编辑</el-button>
    <el-button size="small" type="danger">删除</el-button>
  </div>
</template>
```

```tsx
const propList = [
  ...
  { label: '操作', minWidth: '120', slotName: 'handler' }
]
```

#### 头部插槽

给头部加标题和新建用户按钮；

base-ui/table/src下的

**table.vue**

```html
<div class="sf-table">
  <div class="header">
    <slot name="header">
      <div class="title">{{ title }}</div>
      <div class="handler">
        <slot name="headerHandler"></slot>
      </div>
    </slot>
  </div>
  <el-table>
    ...
  </el-table>
</div>
```

```tsx
props: {
  title: {
    type: String,
    default: ''
  }
}
```

```css
.header {
  display: flex;
  height: 45px;
  padding: 0 5px;
  justify-content: space-between;
  align-items: center;

  .title {
    font-size: 20px;
    font-weight: 700;
  }

  .handler {
    align-items: center;
  }
}

.footer {
  margin-top: 15px;
}
```

views/main/system/user下的

**user.vue**

```html
<sf-table :title="title">
  <!-- 头部插槽 -->
  <template #headerHandler>
    <el-button type="primary" szie="default">新建用户</el-button>
  </template>
  <!-- 列中的插槽 -->
  ...
</sf-table>
```

```tsx
setup() {
    const title = '用户列表'
    return {
      title
    }
}
```

#### 底部插槽

底部用分页器

base-ui/table/src下的

**table.vue**

```html
<div class="footer">
  <slot name="footer">
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :page-size="100"
      :page-sizes="[10, 20, 30]"
      layout="total, sizes, prev, pager, next, jumper"
      :total="400"
    >
    </el-pagination>
  </slot>
</div>
```

#### 语言国际化

element-plus的组件默认显示英文，此时需要简单的**国际化**；

用组件**el-config-provider**包裹根组件，然后传入一个**locale属性**即可；

**App.vue**

```html
<div class="app">
  <el-config-provider :locale="locale"
    ><router-view></router-view
  ></el-config-provider>
</div>
```

```tsx
import { zhCn } from 'element-plus/lib/locale'

setup() {
  return {
    locale: zhCn
  }
}
```

#### 列表的配置化封装

将一些列表**固定的属性**抽离到配置文件里，**变化的属性**由使用者传递；

views/main/system/user下的

**user.vue**

```html
<page-content :contentTableConfig="contentTableConfig"></page-content>
```

```tsx
import { contentTableConfig } from './config/content.config'
```

views/main/system/user/config下的

**content.config.ts**

```tsx
export const contentTableConfig = {
  title: '用户列表',
  propsList: [
    { prop: 'name', label: '用户名', minWidth: '100' },
    { prop: 'realname', label: '真实姓名', minWidth: '100' },
    { prop: 'cellphone', label: '手机号码', minWidth: '100' },
    { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
    {
      prop: 'createAt',
      label: '创建时间',
      minWidth: '250',
      slotName: 'createAt'
    },
    {
      prop: 'updateAt',
      label: '更新时间',
      minWidth: '250',
      slotName: 'updateAt'
    },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],
  showIndexColumn: true,
  showSelectColumn: true
}

```

components/page-content/src下的

**page-content.vue**

```html
<sf-table v-bind="contentTableConfig"></sf-table>
```

```tsx
import SfTable from '@/base-ui/table'

components: {
  SfTable
},
props: {
  contentTableConfig: {
    type: Object,
    require: true
  }
},
setup() {
  const store = useStore()
  store.dispatch('system/getPageListAction', {
    pageUrl: '/users/list',
    queryInfo: {
      offset: 0,
      size: 10
    }
  })
  const userList = computed(() => store.state.system.userList)
  return {
    userList
  }
}
```

```css
.page-content {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
```

#### 根据页面名称，发送不同的网络请求

views/main/system/user下的

**user.vue**

```html
<page-content pageName="users"></page-content>
```

components/page-content/src下的

**page-content.vue**

```tsx
props: {
  pageName: {
    type: String,
    require: true
  }
}
setup(props) {
  const store = useStore()
  store.dispatch('system/getPageListAction', {
    pageName: props.pageName,
    queryInfo: {
      offset: 0,
      size: 10
    }
  })
}
```

store/main/system下的

**system.ts**

```tsx
import { getPageListData } from '@/services/main/system/system'

state() {
  return {
    roleList: [],
    roleCount: 0
  }
},
mutations: {
  changeRoleList(state, list: any[]) {
    state.roleList = list
  },
  changeRoleCount(state, count: number) {
    state.roleCount = count
  }
},
actions: {
  async getPageListAction({ commit }, payload: any) {
    // 1.获取页面url
    const pageName = payload.pageName
    const pageUrl = `/${pageName}/list`

    // 2.发送页面请求
    const pageResult = await getPageListData(pageUrl, payload.queryInfo)

    // 3.将数据存储在state中
    const { list, totalCount } = pageResult.data
    switch (pageName) {
      case 'users':
        commit(`changeUserList`, list)
        commit(`changeUserCount`, totalCount)
        break
      case 'role':
        commit(`changeRoleList`, list)
        commit(`changeRoleCount`, totalCount)
        break
    }
  }
}

```

### 用户按钮权限管理

有些用户，是不具备**新建、删除、修改**权限的，所以这些按钮需要**隐藏或禁用**；

#### 方案一

从**userMenus**获取到的字段，全放进一个**权限数组**里面；

新建一个**hook函数**，接收连两个参数，1页面名称，2权限，返回**Boolean**值；

当该权限在权限数组里面存在，方可显示**按钮**；

**如何从userMenus里拿到所有权限？**

utils下的**map-menus.ts**

```tsx
export function mapMenuToPermission(userMenus: any[]) {
  const permissions: string[] = []

  const _recurseGetPermisstion = (menus: any[]) => {
    // 找到第三层才有权限，然后将所有第三层的权限都收集起来
    for (const menu of menus) {
      if (menu.type === 1 || menu.type === 2) {
        _recurseGetPermisstion(menu.children ?? [])
      } else if (menu.type === 3) {
        permissions.push(menu.permission)
      }
    }
  }
  _recurseGetPermisstion(userMenus)

  return permissions
}
```

store下的**login.ts**

```tsx
state() {
  return {
    ...
    permissions: []
  }
},
mutations: {
  ...
  // 修改用户菜单
  changeUserMenus(state, userMenus: any) {
    ...
    // 获取用户按钮权限
    const permissions = mapMenuToPermission(userMenus)
    state.permissions = permissions
  }
}
```

对应类型文件

```tsx
export interface ILoginState {
  ...
  permissions: string[]
}
```

**hook函数？**

hooks下的**use-permission.ts**

```tsx
import { useStore } from '@/store'

export function usePermission(pageName: string, handleName: string) {
  const store = useStore()
  const permissions = store.state.login.permissions
  const verifyPermission = `system:${pageName}:${handleName}`

  return !!permissions.find((item) => item === verifyPermission)
}

```

**page-content.vue**

```html
 <!-- 头部插槽 -->
<template #headerHandler>
  <el-button ... v-if="isCreate"
    >新建{{ contentTableConfig.title }}</el-button
  >
</template>
...
<!-- 操作列 -->
<template #handler>
  <div class="handle-btns">
    <el-button v-if="isUpdate" ...
      >编辑</el-button
    >
    <el-button v-if="isDelete" ...>删除</el-button>
  </div>
</template>
```

```js
// 0.获取操作权限
const isCreate = usePermission(props.pageName, 'create')
const isUpdate = usePermission(props.pageName, 'update')
const isDelete = usePermission(props.pageName, 'delete')
const isQuery = usePermission(props.pageName, 'query')
...
// 2.发送网络请求
const getPageData = (queryInfo: any = {}) => {
  if (!isQuery) return
  ...
}
```

#### 删除

page-content.vue

```html
<!-- 操作列 -->
<template #handler="scope">
  <div class="handle-btns">
    ...
    <el-button
      ..
      @click="deleteClick(scope)"
      >删除</el-button
    >
  </div>
</template>
```

```js
// 5.删除、新建、编辑
const deleteClick = (item: any) => {
  store.dispatch(`system/deletePageDataAction`, {
    pageName: props.pageName,
    id: item.row.id
  })
}
```

services下的**system.ts**

```tsx
// 删除某条列表数据 url: /users/id
export function deletePageData(url: string) {
  return sfRequest.delete<IDataType>({
    url: url
  })
}
```

store下的**system.ts**

```tsx
actions: {
    ...

    async deletePageDataAction({ dispatch }, payload) {
      // 1.获取pageName和id
      const { pageName, id } = payload
      const pageUrl = `/${pageName}/${id}`
      // 2.发起删除网络请求
      await deletePageData(pageUrl).then((res) => {
        ElMessage({
          message: res.data,
          type: 'warning'
        })
      })
      // 3.重新请求最新的数据
      dispatch('getPageListAction', {
        pageName,
        queryInfo: {
          offset: 0,
          size: 10
        }
      })
    }
  }
```

对于第三步重新发起查询请求，其实是需要根据页面获取到**queryInfo**的，包括**查询条件**和**分页参数**；

可以将查询条件和分页参数**共享到store中**，这样就可以在store中获取；

这里重新发起查询请求，暂时写死queryInfo；

#### 新建

新建弹出框，复用之前封装过的表单，配置即可；

暂时写成在一个页面中；

**user.vue**

```html
<!-- 新建弹出框 -->
<div class="page-modal">
  <el-dialog v-model="dialogVisible" title="新建用户" width="30%" center>
    <sf-form v-bind="modelConfig" v-model="formData"></sf-form>
    <template #footer>
      <span class="dialog-footer">
        <el-button @click="dialogVisible = false">取消</el-button>
        <el-button type="primary" @click="dialogVisible = false"
          >确认</el-button
        >
      </span>
    </template>
  </el-dialog>
</div>
```

```js
import { modelConfig } from './config/model.config'

const dialogVisible = ref(true)
```

对应配置文件

```tsx
export const modelConfig = {
  formItems: [
    {
      field: 'name',
      type: 'input',
      label: '用户名',
      placeholder: '请输入用户名'
    },
    {
      field: 'realname',
      type: 'input',
      label: '真实姓名',
      placeholder: '请输入真实姓名'
    },
    {
      field: 'password',
      type: 'input',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      field: 'cellphone',
      type: 'input',
      label: '电话号码',
      placeholder: '请输入电话号码'
    }
  ],
  colLayout: { span: 24 },
  itemStyle: {}
}

```

#### 封装对话框

**page-model.vue**

```html
<template>
  <!-- 新建弹出框 -->
  <div class="page-modal">
    <el-dialog v-model="dialogVisible" title="新建用户" width="30%" center destroy-on-close>
      <sf-form v-bind="modelConfig" v-model="formData"></sf-form>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="dialogVisible = false">取消</el-button>
          <el-button type="primary" @click="dialogVisible = false"
            >确认</el-button
          >
        </span>
      </template>
    </el-dialog>
  </div>
</template>
```

```js
import SfForm from '@/base-ui/form'

components: {
  SfForm
},
props: {
  modelConfig: {
    type: Object,
    required: true
  }
},
setup() {
  const dialogVisible = ref(true)
  const formData = ref({})

  return {
    dialogVisible,
    formData
  }
}
```

#### 对话框与父组件的通信

对话框的显示与隐藏由父组件**user.vue**控制；

子组件需要**发射事件**通知父组件修改；

点击新建按钮时，父组件**user.vue**需要获取子组件**page-model.vue**的属性**dialogVisible**；

此时需要ref

**page-content.vue**

```html
<!-- 头部插槽 -->
<template #headerHandler>
  <el-button
    ...
    @click="createClick"
    >新建{{ contentTableConfig.title }}</el-button
  >
</template>
...
<!-- 操作列 -->
<template #handler="scope">
  <div class="handle-btns">
    <el-button
      ...
      @click="editClick(scope.row)"
      >编辑</el-button
    >
  </div>
</template>
```

```tsx
// 5.删除、新建、编辑
...

const createClick = () => {
  emit('creatBtn')
}

const editClick = (item: any) => {
  emit('editBtn', item)
}
```

**user.vue**

```html
<!-- 列表部分 -->
<page-content
  ref="pageContentRef"
  :contentTableConfig="contentTableConfig"
  pageName="users"
  @creatBtn="create"
  @editBtn="edit"
></page-content>
<!-- 新建对话框 -->
<page-model ref="pageModelRef" :modelConfig="modelConfig"></page-model>
```

```tsx
const pageModelRef = ref<InstanceType<typeof PageModel>>()

const create = () => {
  if (pageModelRef.value) {
    pageModelRef.value.dialogVisible = true
  }
}

const edit = (item: any) => {
  if (pageModelRef.value) {
    pageModelRef.value.dialogVisible = true
  }
}
```

**编辑数据回显**

点击编辑之后，可以拿到一行数据**item**；

需要将item传给page-model.vue的**formData**；

子组件设置一个props（defaultInfo）接收传来的**item**；

子组件page-model.vue监听props中的defaultInfo,当defaultInfo发生改变时就设置formData；

**user.vue**

```html
<page-model
  ref="pageModelRef"
  :modelConfig="modelConfig"
  ...
></page-model>
```

```tsx
const pageModelRef = ref<InstanceType<typeof PageModel>>()
const defaultInfo = ref({})

const edit = (item: any) => {
  defaultInfo.value = { ...item }
  if (pageModelRef.value) {
    pageModelRef.value.dialogVisible = true
  }
}
```

**page-model.vue**

```tsx
props: {
  ...
  defaultInfo: {
    type: Object,
    default: () => ({})
  }
},
setup(props) {
  ...
  const formData = ref<any>({})

  watch(
    () => props.defaultInfo,
    (newValue) => {
      for (const item of props.modelConfig.formItems) {
        formData.value[`${item.field}`] = newValue[`${item.field}`]
      }
    }
  )
}
```

#### 抽取公共逻辑

hooks下的

**usePageModel.ts**

```tsx
import { ref } from 'vue'
import PageModel from '@/components/page-model'

export function usePageModel() {
  const pageModelRef = ref<InstanceType<typeof PageModel>>()
  const defaultInfo = ref({})
  // 新建
  const create = () => {
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
  }
  // 编辑
  const edit = (item: any) => {
    defaultInfo.value = { ...item }
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
  }

  return [pageModelRef, defaultInfo, create, edit]
}

```

**user.vue**

```tsx
import { usePageModel } from '@/hooks/use-page-model'
const [pageModelRef, defaultInfo, create, edit] = usePageModel()
```

#### 解决新建时的小问题

当点击新建时，对话框用的还是默认值，需要将默认值置空；

hooks下的

**usePageModel.ts**

```tsx
import { ref } from 'vue'
import PageModel from '@/components/page-model'

export function usePageModel() {
  const pageModelRef = ref<InstanceType<typeof PageModel>>()
  const defaultInfo = ref({})
  // 新建
  const create = () => {
  	// 新建时置空
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
  }
  // 编辑
  const edit = (item: any) => {
  	// 编辑时赋值
    defaultInfo.value = { ...item }
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
  }

  return [pageModelRef, defaultInfo, create, edit]
}

```

### 选择性隐藏表单项

不同页面，需要隐藏的表单项是不一样的，比如新建和编辑需要的表单项就不一样，需要隐藏某些表单项；

这种隐藏逻辑，就不应该写在公共代码里面；

给每个**formItem**再加个类型isHidden，**遍历**表单项时加个**判断**是否隐藏；

这时只需要在每个页面的对应**配置文件**里，就可以控制显示和隐藏啦；

**formItem对应的类型声明文件**

```tsx
export interface IFormItem {
  field: string
  type: IFormType
  label: string
  rules?: any[]
  placeholder?: any
  // 针对select
  options?: any[]
  // 针对特殊的属性
  otherOptions?: any
  // 是否隐藏
  isHidden?: boolean
}
```

**form.vue**

```html
<el-form :label-width="labelWidth">
  <el-row>
    <template ...>
      <el-col v-bind="colLayout">
        <el-form-item
          v-if="!item.isHidden"
          ...
        >
          ...
        </el-form-item>
      </el-col>
    </template>
  </el-row>
</el-form>
```

对话框对应的配置文件

**model.config.ts**

```tsx
export const modelConfig = {
  formItems: [
    ...
    {
      field: 'password',
      type: 'input',
      label: '密码',
      placeholder: '请输入密码',
      isHidden: true
    },
    ...
  ],
  ...
}

```

当某个页面**新建时需要显示，而编辑时需要隐藏**的话，就需要在该页面编写控制逻辑；

在usePageModel()里面接收两个参数，当需要对某一表单项进一步控制显示与隐藏，就可以传入;

**user.vue**

```tsx
// pageModel相关的hooks逻辑
const newCallback = () => {
  // 拿到密码表单项的属性
  const passwordItem = modelConfig.formItems.find(
    (item) => item.field === 'password'
  )
  passwordItem!.isHidden = false
}
const editCallback = () => {
  // 拿到密码表单项的属性
  const passwordItem = modelConfig.formItems.find(
    (item) => item.field === 'password'
  )
  passwordItem!.isHidden = true
}
const [pageModelRef, defaultInfo, create, edit] = usePageModel(
  newCallback,
  editCallback
)
```

hooks下的

usePageModel

```tsx
...

type CallbackFn = () => void

export function usePageModel(newCb?: CallbackFn, editCb?: CallbackFn) {
  const pageModelRef = ref<InstanceType<typeof PageModel>>()
  const defaultInfo = ref({})
  // 新建
  const create = () => {
    // 新建时置空
    defaultInfo.value = {}
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
    // newCb有值时调用
    newCb && newCb()
  }
  // 编辑
  const edit = (item: any) => {
    // 编辑时赋值
    defaultInfo.value = { ...item }
    if (pageModelRef.value) {
      pageModelRef.value.dialogVisible = true
    }
    // editCb有值时调用
    editCb && editCb()
  }

  return [pageModelRef, defaultInfo, create, edit]
}

```

### 处理数据是动态的表单项

新建时，部门和角色的数据是动态的，选项不应该写死；

而且**部门和角色的数据**不能使用角色管理里面的数据，因为**角色管理**里面的数据是**有条件**的，比如某个用户没有某个**权限**，就不能看到某些部门；

别的地方可能也需要部门和角色的数据，应该保存到vuex中；

#### 请求部门和角色数据

vuex的根

```tsx
...
import { getPageListData } from '@/services/main/system/system'
...

const store = createStore<IRootState>({
  state() {
    return {
      ...
      entireDepartment: [],
      entireRole: []
    }
  },
  mutations: {
    changeEntireDepartment(state, list) {
      state.entireDepartment = list
    },
    changeEntireRole(state, list) {
      state.entireRole = list
    }
  },
  actions: {
    async getInitialDataAction({ commit }) {
      // 1.请求部门和角色数据
      const departmentResult = await getPageListData('/department/list', {
        offset: 0,
        size: 1000
      })
      const { list: departmentList } = departmentResult.data
      const roleResult = await getPageListData('/role/list', {
        offset: 0,
        size: 1000
      })
      const { list: roleList } = roleResult.data
      // 2.保存数据
      commit('changeEntireDepartment', departmentList)
      commit('changeEntireRole', roleList)
    }
  },
  ...
})
export function setupStore() {
  ...
  store.dispatch('getInitialDataAction')
}
...

export default store

```

**根对应的配置文件**

```tsx
export interface IRootState {
  ...
  entireDepartment: any[]
  entireRole: any[]
}
```

#### 显示数据

将请求到的数据放到**model.config.ts**中部门和角色的option中；

#### 解决部门和角色数据不是响应式的问题

第一次进入用户管理的新建用户时，部门和角色的数据不存在；

让这些**数据发生改变**的时候，有一个**副作用**的函数，执行完这副作用的函数后，可能会返回一个结果，返回的结果能让对这结果**有依赖**的地方重新刷新，从而获取到最新的数据；

user.vue

```html
<!-- 新建对话框 -->
<page-model
  ...
  :modelConfig="modelConfigRef"
  ...
></page-model>
```

```tsx
// 动态添加部门和角色的选项
const store = useStore()

const modelConfigRef = computed(() => {
  let departmentItem: any = null
  modelConfig.formItems.map((item) => {
    if (item.field === 'departmentId') {
      departmentItem = item
    }
  })
  // 给对应配置文件的options添加数据
  departmentItem!.options = store.state.entireDepartment.map((item) => {
    return {
      title: item.name,
      value: item.name
    }
  })
  let roleItem: any = null
  modelConfig.formItems.map((item) => {
    if (item.field === 'roleId') {
      roleItem = item
    }
  })
  roleItem!.options = store.state.entireRole.map((item) => {
    return {
      title: item.name,
      value: item.name
    }
  })
  // 获得最新的配置文件
  return modelConfig
})
```

对应的配置文件**model.config.ts**

```tsx
import { IForm } from '@/base-ui/form'

export const modelConfig: IForm = {
  formItems: [
    ...
    {
      field: 'departmentId',
      type: 'select',
      label: '部门',
      placeholder: '请选择部门',
      options: []
    },
    {
      field: 'roleId',
      type: 'select',
      label: '角色',
      placeholder: '请选择角色',
      options: []
    }
  ],
  ...
}

```

### 新建与编辑用户

填好数据，点击确认发送网络请求；

services下的**system.ts**

```tsx
// 新增用户
export function createPageData(url: string, newData: any) {
  return sfRequest.post<IDataType>({
    url: url,
    data: newData
  })
}

// 编辑用户
export function editPageData(url: string, editData: any) {
  return sfRequest.patch<IDataType>({
    url: url,
    data: editData
  })
}
```

store下的**system.ts**

```tsx
// 新增
async createPageDataAction({ dispatch }, payload: any) {
  // 1.创建数据的请求
  const { pageName, newData } = payload
  const pageUrl = `/${pageName}`
  await createPageData(pageUrl, newData).then(() =>
    ElMessage({
      message: '新建成功！',
      type: 'success'
    })
  )
  // 2.请求最新的数据
  dispatch('getPageListAction', {
    pageName,
    queryInfo: {
      offset: 0,
      size: 10
    }
  })
},
// 编辑
async editPageDataAction({ dispatch }, payload: any) {
  // 1.编辑数据的请求
  const { pageName, editData, id } = payload
  const pageUrl = `/${pageName}/${id}}`
  await editPageData(pageUrl, editData).then(() =>
    ElMessage({
      message: '修改成功！',
      type: 'success'
    })
  )

  // 2.请求最新的数据
  dispatch('getPageListAction', {
    pageName,
    queryInfo: {
      offset: 0,
      size: 10
    }
  })
}
```

**user.vue**

```html
<!-- 新建对话框 -->
<page-model
  ...
  pageName="users"
></page-model>
```

**page-model.vue**

```html
<el-button type="primary" @click="confirm">确认</el-button>
```

```tsx
props: {
  ...
  pageName: {
    type: String,
    required: true
  }
},
    
// 点击确定按钮
const store = useStore()
const confirm = () => {
  dialogVisible.value = false
  if (Object.keys(props.defaultInfo).length) {
    // 编辑
    store.dispatch('system/editPageDataAction', {
      pageName: props.pageName,
      editData: { ...formData.value },
      id: props.defaultInfo.id
    })
  } else {
    // 新建
    store.dispatch('system/createPageDataAction', {
      pageName: props.pageName,
      newData: { ...formData.value }
    })
  }
}
```

### 处理时间问题

由于服务器使用的是utc格式的时间，使用的是0时区；

而我们是东8区，所以时间会晚8个小时；

调用utc的utcoffset()即可；

**data-format.ts**

```tsx
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

dayjs.extend(utc)

const DATE_TIME_FORMAT = 'YYYY-MM-DD HH:mm:ss'
export function formatUtcString(
  utcString: string,
  format: string = DATE_TIME_FORMAT
) {
  return dayjs.utc(utcString).utcOffset(8).format(format)
}
```



## 3.7 角色管理

### 配置角色列表

写个配置文件即可

**content.config.ts**

```tsx
export const contentTableConfig = {
  title: '角色列表',
  propsList: [
    { prop: 'name', label: '角色名', minWidth: '100' },
    { prop: 'intro', label: '权限介绍', minWidth: '100' },
    {
      prop: 'createAt',
      label: '创建时间',
      minWidth: '250',
      slotName: 'createAt'
    },
    {
      prop: 'updateAt',
      label: '更新时间',
      minWidth: '250',
      slotName: 'updateAt'
    },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],
  showIndexColumn: true,
  showSelectColumn: true
}

```

**role.vue**

```html
<div class="role">
  <page-content :contentTableConfig="contentTableConfig" pageName="role"></page-content>
</div>
```

```js
import PageContent from '@/components/page-content'
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  name: 'role',
  components: {
    PageContent
  },
  setup() {
    return {
      contentTableConfig
    }
  }
})
```

### **修改获取数据的方式**

之前是直接在store中的**state**获取到数据，再**拼接**；

修改成在store中的**getters**中获取，使用一个**函数**，参数接收**页面名字**；

store下的**system.ts**

```tsx
getters: {
    pageListData(state) {
      return (pageName: string) => {
        switch (pageName) {
          case 'users':
            return state.userList
          case 'role':
            return state.roleList
        }
      }
    }
  }
```

可以采用拼接做优化，暂时使用switch；

components下的**page-content.vue**

```html
<sf-table :listData="dataList" ...>
  ...
</sf-table>
```

```js
const dataList = computed(() =>
  store.getters['system/pageListData'](props.pageName)
)
```

为什么**getters['system/pageListData']**这样访问getters？

因为分**模块**了，得先知道哪个模块的哪个属性；

### 配置角色搜索

views下system部分的role下的

**search.config.ts**

```tsx
import { IForm } from '@/base-ui/form'

export const searchFormConfig: IForm = {
  labelWidth: '120px',
  formItems: [
    {
      field: 'name',
      type: 'input',
      label: '角色名称',
      placeholder: '请输入角色名称'
    },
    {
      field: 'intro',
      type: 'input',
      label: '权限介绍',
      placeholder: '请输入权限介绍'
    },
    {
      field: 'createTime',
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
}

```

### 新建角色

**role.vue**

```html
<page-content
  ...
  @createBtn="create"
  @editBtn="edit"
></page-content>
<page-model
  ref="pageModelRef"
  :defaultInfo="defaulInfo"
  :modelConfig="modelConfig"
  pageName="role"
></page-model>
```

```tsx
import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'
import { modelConfig } from './config/model.config'

import { usePageModel } from '@/hooks/use-page-model'

const [pageModelRef, defaulInfo, create, edit] = usePageModel()
```

对应的配置文件

```tsx
import { IForm } from '@/base-ui/form'

export const modelConfig: IForm = {
  formItems: [
    {
      field: 'name',
      type: 'input',
      label: '角色',
      placeholder: '请输入角色'
    },
    {
      field: 'intro',
      type: 'input',
      label: '角色介绍',
      placeholder: '请输入角色介绍'
    }
  ],
  colLayout: { span: 24 },
  itemStyle: {}
}
```

### **分配角色权限**

这个内容只有**角色管理页**需要，可以在**page-model.vue**预留一个**插槽**;

**page-model.vue**

```html
<sf-form ...></sf-form>
<slot></slot>
<template #footer>
  ...
</template>
```

**role.vue**

```html
<page-model
  ...
>
  <el-tree
    :data="menus"
    show-checkbox
    node-key="id"
    :props="{ children: 'children', label: 'name' }"
  ></el-tree>
</page-model>
```

```tsx
import { useStore } from '@/store'

const store = useStore()
const menus = computed(() => store.state.entireMenu)
```

#### **获取菜单列表**

store下的index.ts

```tsx
state() {
  return {
    ...
    entireMenu: []
  }
},
mutations: {
    ...
    changeEntireMenu(state, list) {
      state.entireMenu = list
    }
  },
actions: {
  async getInitialDataAction({ commit }) {
    ...
    const menuResult = await getPageListData('/menu/list', {})
    const { list: menuList } = menuResult.data
    // 2.保存数据
    ...
    commit('changeEntireMenu', menuList)
  }
},
```

对应的类型声明文件

```tsx
export interface IRootState {
  ...
  entireMenu: any[]
}
```

#### 整合不同组件的请求参数

发送分配角色请求需要三个字段：name、intro、menuList；

而name和intro可以在**page-model.vue**中的**formData**属性获得；

而menuList需要在**role.vue**中获得；

需要将这三个字段数据整合成一个**对象**，然后当成请求参数发送请求；

实际发送请求是在**page-model.vue**中进行的；

所以需要将menuList**传递**给**page-model.vue**;

之前不管编辑或者新建，传递的**参数**只是从formData获得，现在新加一个props，otherInfo；

**page-model.vue**

```tsx
otherInfo: {
  type: Object,
  default: () => ({})
},
    
// 点击确定按钮
const store = useStore()
const confirm = () => {
  dialogVisible.value = false
  if (Object.keys(props.defaultInfo).length) {
    // 编辑
    store.dispatch('system/editPageDataAction', {
      pageName: props.pageName,
      editData: { ...formData.value, ...props.otherInfo },
      id: props.defaultInfo.id
    })
  } else {
    // 新建
    store.dispatch('system/createPageDataAction', {
      pageName: props.pageName,
      newData: { ...formData.value, ...props.otherInfo }
    })
  }
}
```

**role.vue**

```html
<el-tree
  :data="menus"
  show-checkbox
  node-key="id"
  :props="{ children: 'children', label: 'name' }"
  @check="handleCheckChange"
></el-tree>
```

```tsx
const otherInfo = ref({})
const handleCheckChange = (data1: any, data2: any) => {
  const checkedKeys = data2.checkedKeys
  const halfCheckedKeys = data2.halfCheckedKeys
  const menuList = [...checkedKeys, ...halfCheckedKeys]
  otherInfo.value = { menuList }
}
```

#### 编辑时回显

点击编辑时需要拿到当前条数据，即是item；

**usePageModel**这个hook中的**edit()**可以拿到item;

然后将**item**传递给role.vue,让**role.vue**去设置这些数据；

只设置叶子节点；

需要设计一个工具函数：获取树形结构的叶子；

使用el-tree的方法时，还需要使用**nextTick**，因为使用**editCallback()**这回调函数的时候，**el-tree**还没加载到组件对象中；

utils下的**map-menus.ts**

```tsx
// 获取菜单所有叶子节点
export function getMenuLeafKeys(menuList: any) {
  const leafKeys: number[] = []

  const _recurseGetLeaf = (menuList: any[]) => {
    for (const menu of menuList) {
      if (menu.children) {
        _recurseGetLeaf(menu.children)
      } else {
        leafKeys.push(menu.id)
      }
    }
  }
  _recurseGetLeaf(menuList)

  return leafKeys
}
```

**role.vue**

```html
 <el-tree
   ref="elTreeRef"
   :data="menus"
   show-checkbox
   node-key="id"
   :props="{ children: 'children', label: 'name' }"
   @check="handleCheckChange"
 ></el-tree>
```

```tsx
import { getMenuLeafKeys } from '@/utils/map-menus'
import { ElTree } from 'element-plus'

const elTreeRef = ref<InstanceType<typeof ElTree>>()
const editCallback = (item: any) => {
  const leafKeys = getMenuLeafKeys(item.menuList)
  nextTick(() => {
    elTreeRef.value?.setCheckedKeys(leafKeys, false)
  })
}
const [pageModelRef, defaulInfo, create, edit] = usePageModel(
  undefined,
  editCallback
)
```



## 3.8 page-search组件优化

### 搜索部分

#### 动态双向数据绑定

双向绑定的属性，应该由**配置文件的field**来决定；

components下的**page-search.vue**

```js
setup(props) {
    // 双向绑定的属性，应该由配置文件的field来决定
    const formItems = props.searchFormConfig?.formItems ?? []
    const formOriginData: any = {}
    for (const item of formItems) {
      formOriginData[item.field] = ''
    }

    const formData = ref(formOriginData)

    return {
      formData
    }
  }
```

#### 重置

components下的**page-search.vue**

```js
// 重置
const reset = () => {
  for (const key in formOriginData) {
    formData.value[`${key}`] = formOriginData[key]
  }
}
```

#### **搜索**

**page-search组件**发送搜索事件到**user组件**；

user组件再调用**page-content组件**获取数据的方法；

重置同理；

components下的**page-search.vue**

```html
<el-button @click="reset">重置</el-button>
<el-button ... @click="query">搜索</el-button>
```

```js
emits: ['resetClick', 'queryClick'],
setup(props, { emit }) {
  ...
  // 重置
  const reset = () => {
    for (const key in formOriginData) {
      formData.value[`${key}`] = formOriginData[key]
    }
    emit('resetClick')
  }
  // 搜索
  const query = () => {
    emit('queryClick', formData.value)
  }
  return {
    formData,
    reset,
    query
  }
}
```

**user.vue**

```html
<!-- 搜索部分 -->
<page-search
  ...
  @resetClick="reset"
  @queryClick="query"
></page-search>
<!-- 列表部分 -->
<page-content
  ref="pageContentRef"
  ...
></page-content>
```

```js
const pageContentRef = ref<InstanceType<typeof PageContent>>()
const reset = () => {
  pageContentRef.value?.getPageData()
}

const query = (queryInfo: any) => {
  pageContentRef.value?.getPageData(queryInfo)
}
```

components下的**page-content.vue**

```js
// 发送网络请求
const getPageData = (queryInfo: any = {}) => {
  store.dispatch('system/getPageListAction', {
    pageName: props.pageName,
    queryInfo: {
      offset: 0,
      size: 10,
      ...queryInfo
    }
  })
}
getPageData()
```

### 抽离重置和搜索逻辑

src/hooks下的**use-page-search.ts**

```tsx
import { ref } from 'vue'
import PageContent from '@/components/page-content'

export function usePageSearch() {
  const pageContentRef = ref<InstanceType<typeof PageContent>>()
  const reset = () => {
    pageContentRef.value?.getPageData()
  }
  const query = (queryInfo: any) => {
    pageContentRef.value?.getPageData(queryInfo)
  }
  return [pageContentRef, reset, query]
}
```

**user.vue**

```js
import { usePageSearch } from '@/hooks/use-page-search'
const [pageContentRef, reset, query] = usePageSearch()
```

## 3.9 page-content组件优化

### 分页器底部属性

#### 总条数

components下的**table.vue**

```html
<el-pagination
  ...
  :total="listCount"
>
</el-pagination>
```

```
props: {
  listCount: {
    type: Number,
    default: 0
  }
}
```

store下的**system.ts**

```js
pageListCount(state) {
  return (pageName: string) => {
    return (state as any)[`${pageName}Count`]
  }
}
```

components下的**page-content.vue**

```html
<sf-table
  :listCount="listCount"
  ...
>
  ...
</sf-table>
```

```js
const listCount = computed(() =>
  store.getters[`system/pageListCount`](props.pageName)
)
```

#### 其它属性

**当前页**和**一页大小**发生改变时，需要重新发送网络请求；

当pageInfo发生改变时，再调一下getPageData，所以需要监听**pageInfo**；

components下的**table.vue**

```html
<el-pagination
  :current-page="page.currentPage"
  :page-size="page.pageSize"
  @size-change="handleSizeChange"
  @current-change="handleCurrentChange"
  ...
>
</el-pagination>
```

```js
props: {
  ...
  page: {
    type: Object,
    default: () => ({ currentPage: 0, pageSize: 10 })
  }
},
emit: ['selectionChange', 'updata:page'],
```

```js
setup(props, { emit }) {
  ...
  // 页号发生变化
  const handleSizeChange = (pageSize: number) => {
    emit('updata:page', { ...props.page, pageSize })
  }
  // 当前页发生变化
  const handleCurrentChange = (currentPage: number) => {
    emit('updata:page', { ...props.page, currentPage })
  }
}
```

components下的**page-content.vue**

```html
<sf-table
  ...
  v-model:page="pageInfo"
>
  ...
</sf-table>
```

```js
const pageInfo = ref({ currentPage: 0, pageSize: 10 })
watch(
  pageInfo,
  () => getPageData()
)
// 发送网络请求
const getPageData = (queryInfo: any = {}) => {
  store.dispatch('system/getPageListAction', {
    pageName: props.pageName,
    queryInfo: {
      offset: pageInfo.value.currentPage * pageInfo.value.pageSize,
      size: pageInfo.value.pageSize,
      ...queryInfo
    }
  })
}
```

### 动态列的插槽

表单的列应该显示什么应该是**动态**的；

```html
<!-- 在page-content中动态插入剩余插槽 -->
<template
  v-for="item in otherPropSlots"
  :key="item.prop"
  #[item.slotName]="scope"
>
  <template v-if="item.slotName">
    <slot :name="item.slotName" :row="scope.row"></slot>
  </template>
</template>
```

```js
// 4.获取其它动态插槽
const otherPropSlots = props.contentTableConfig?.propsList.filter(
  (item: any) => {
    if (item.slotName === 'status') return false
    if (item.slotName === 'createAt') return false
    if (item.slotName === 'updateAt') return false
    if (item.slotName === 'handle') return false
    return true
  }
)
```



## 3.10 商品信息

### 结构部分

view/main/product/goods下的**goods.vue**

```html
<div class="goods">
  <page-content
      :contentTableConfig="contentTableConfig"
      pageName="goods"
    ></page-content>
</div>
```

```js
import PageContent from '@/components/page-content'
import { contentTableConfig } from './config/content.config'
```

对应配置文件**content.config.ts**

```tsx
export const contentTableConfig = {
  title: '商品',
  propsList: [
    { prop: 'name', label: '商品名称', minWidth: '80' },
    { prop: 'oldPrice', label: '原价格', minWidth: '80' },
    { prop: 'newPrice', label: '现价格', minWidth: '80' },
    { prop: 'imgUrl', label: '商品图片', minWidth: '100' },
    { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
    {
      prop: 'createAt',
      label: '创建时间',
      minWidth: '250',
      slotName: 'createAt'
    },
    {
      prop: 'updateAt',
      label: '更新时间',
      minWidth: '250',
      slotName: 'updateAt'
    },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],
  showIndexColumn: true,
  showSelectColumn: true
}
```

### 数据部分

store下的**system.ts**

```js
state() {
  return {
    ...
    goodsList: [],
    goodsCount: 0
  }
},
mutations: {
  ...
  changeGoodsList(state, list: any[]) {
    state.goodsList = list
  },
  changeGoodsCount(state, count: number) {
    state.goodsCount = count
  }
},
getters: {
  pageListData(state) {
    return (pageName: string) => {
      return (state as any)[`${pageName}List`]
    }
  },
  pageListCount(state) {
    return (pageName: string) => {
      return (state as any)[`${pageName}Count`]
    }
  }
},
actions: {
  async getPageListAction({ commit }, payload: any) {
    // 1.获取页面url
    ...

    // 2.发送页面请求
    ...

    // 3.将数据存储在state中
    const { list, totalCount } = pageResult.data
    const changePageName =
      pageName.slice(0, 1).toUpperCase() + pageName.slice(1)
    commit(`change${changePageName}List`, list)
    commit(`change${changePageName}Count`, totalCount)
  }
}
```

对应类型文件

```tsx
export interface ISystemState {
  ...
  goodsList: any[]
  goodsCount: number
}
```

#### 图片列

**goods.vue**

```html
<page-content :contentTableConfig="contentTableConfig" pageName="goods">
  <template #image="scope">
    <el-image
      style="width: 60px; height: 60px"
      :src="scope.row.imgUrl"
      :preview-src-list="[scope.row.imgUrl]"
    ></el-image>
  </template>
</page-content>
```

对应配置文件

```tsx
export const contentTableConfig = {
  title: '商品',
  propsList: [
    { prop: 'imgUrl', label: '商品图片', minWidth: '100', slotName: 'image' },
    ...
  ],
  ..
}
```

#### 人民币符号

**goods.vue**

```html
<template #oldPrice="scope">{{ `￥${scope.row.oldPrice}` }} </template>
```

对应配置文件

```tsx
export const contentTableConfig = {
  title: '商品',
  propsList: [
    { prop: 'oldPrice', label: '原价格', minWidth: '80', slotName: 'oldPrice' },
    ...
  ],
  ..
}
```

## 3.11 菜单管理

### **结构部分**

**menu.vue**

```html
<div class="menu">
  <page-content
    :contentTableConfig="contentTableConfig"
    pageName="menu"
  ></page-content>
</div>
```

```js
import PageContent from '@/components/page-content'
import { contentTableConfig } from './config/content.config'
```

对应的配置文件

```tsx
export const contentTableConfig = {
  title: '菜单',
  propsList: [
    { prop: 'name', label: '菜单名称', minWidth: '100' },
    { prop: 'type', label: '类型', minWidth: '60' },
    { prop: 'url', label: '菜单url', minWidth: '100' },
    { prop: 'icon', label: '菜单icon', minWidth: '100' },
    {
      prop: 'permission',
      label: '按钮权限',
      minWidth: '100'
    },
    {
      prop: 'createAt',
      label: '创建时间',
      minWidth: '220',
      slotName: 'createAt'
    },
    {
      prop: 'updateAt',
      label: '更新时间',
      minWidth: '220',
      slotName: 'updateAt'
    },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],
  showIndexColumn: false,
  showSelectColumn: false
}

```

### 数据部分

store下的**system.ts**

```
state() {
  return {
    ...
    menuList: [],
    menuCount: 0
  }
},
mutations: {
  ...
  changeMenuList(state, list: any[]) {
    state.menuList = list
  },
  changeMenuCount(state, count: number) {
    state.menuCount = count
  }
},
```

对应类型文件

```tsx
export interface ISystemState {
  ...
  menuList: any[]
  menuCount: number
}
```

### 树形菜单

base-ui下的**table.vue**

```html
<el-table v-bind="childrenProps">...</el-table>
```

```js
props: {
    ...
    childrenProps: {
      type: Object,
      default: () => ({})
    }
  },
```

menu.vue对应的配置文件

```tsx
export const contentTableConfig = {
  ...
  childrenProps: {
    rowKey: 'id',
    treeProp: {
      children: 'children'
    }
  }
}
```

### 去掉底部分页器

base-ui下的**table.vue**

```html
<div class="footer" v-if="showFooter">...</div>
```

```
props: {
    ...
    showFooter: {
      type: Boolean,
      default: true
    }
  },
```

menu.vue对应的配置文件

```tsx
export const contentTableConfig = {
  ...
  showFooter: false
}
```

## 3.12 商品统计

### 请求数据

这些请求放vuex里，分在一个单独模块analysis；

store里analysis下的

**dashboard.ts**

```tsx
import {
  getAddressGoodsSale,
  getCategoryGoodsCount,
  getCategoryGoodsFavor,
  getCategoryGoodsSale
} from '@/services/main/analysis/dashboard'
import { IRootState } from '@/store/types'
import { Module } from 'vuex'
import { IDashboardState } from './type'

const dashboardModule: Module<IDashboardState, IRootState> = {
  namespaced: true,
  state() {
    return {
      categoryGoodsCount: [],
      categoryGoodsSale: [],
      categoryGoodsFavor: [],
      addressGoodsSale: []
    }
  },
  mutations: {
    changeCategoryGoodsCount(state, list) {
      state.categoryGoodsCount = list
    },
    changeCategoryGoodsSale(state, list) {
      state.categoryGoodsSale = list
    },
    changeCategoryGoodsFavor(state, list) {
      state.categoryGoodsFavor = list
    },
    changeAddressGoodsSale(state, list) {
      state.addressGoodsSale = list
    }
  },
  actions: {
    async getDashboardDataAction({ commit }) {
      const categoryCountResult = await getCategoryGoodsCount()
      commit('changeCategoryGoodsCount', categoryCountResult.data)

      const categorySaleResult = await getCategoryGoodsSale()
      commit('changeCategoryGoodsSale', categorySaleResult.data)

      const categoryFavorResult = await getCategoryGoodsFavor()
      commit('changeCategoryGoodsFavor', categoryFavorResult.data)

      const addressGoodsResult = await getAddressGoodsSale()
      commit('changeAddressGoodsSale', addressGoodsResult.data)
    }
  }
}

export default dashboardModule
```

对应的类型声明文件

```tsx
export interface IDashboardState {
  categoryGoodsCount: any[]
  categoryGoodsSale: any[]
  categoryGoodsFavor: any[]
  addressGoodsSale: any[]
}
```

store下的

**index.ts**

```tsx
import dashboard from './main/analysis/dashboard'

const store = createStore<IRootState>({
  ...
  modules: {
    ...
    dashboard
  }
})
```

services里analysis下的

**dashboard.ts**

```tsx
import sfRequest from '@/services'

enum DashboardAPI {
  categoryGoodsCount = '/goods/category/count',
  categoryGoodsSale = '/goods/category/sale',
  categoryGoodsFavor = '/goods/category/favor',
  addressGoodsSale = '/goods/address/sale'
}

export function getCategoryGoodsCount() {
  return sfRequest.get({
    url: DashboardAPI.categoryGoodsCount
  })
}

export function getCategoryGoodsSale() {
  return sfRequest.get({
    url: DashboardAPI.categoryGoodsSale
  })
}

export function getCategoryGoodsFavor() {
  return sfRequest.get({
    url: DashboardAPI.categoryGoodsFavor
  })
}

export function getAddressGoodsSale() {
  return sfRequest.get({
    url: DashboardAPI.addressGoodsSale
  })
}
```

**dashboard.vue**

```tsx
import { useStore } from 'vuex'

const store = useStore()
store.dispatch('dashboard/getDashboardDataAction')
```

### 封装展示图表的卡片

base-ui下的

**card.vue**

```vue
<template>
  <el-card class="box-card">
    <template #header>
      <div class="card-header">
        <span>{{ title }}</span>
      </div>
    </template>
    <div class="item">
      <slot></slot>
    </div>
  </el-card>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  components: {},

  props: {
    title: {
      type: String,
      default: 'Title'
    }
  },

  setup() {
    return {}
  }
})
</script>

<style lang="less" scoped>
.box-card {
  &:deep(.el-card__header) {
    padding: 10px 20px !important;
  }
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 30px;
}

.item {
  margin-bottom: 10px;
  // border: 1px solid red;
}
</style>

```

### 对echarts的封装

设计一个BaseEchart.vue，根据不同option展示不同图表；

由于echarts图标的展示需要具体宽高，所以BaseEchart需要暴露一个宽高props，以及options这个props；

**base-echart.vue**

```vue
<template>
  <div class="base-echart">
    <div ref="echartDivRef" :style="{ width: width, height: height }"></div>
  </div>
</template>

<script lang="ts" setup>
import { onMounted, ref, defineProps, withDefaults } from 'vue'
import * as echarts from 'echarts'
import { EChartsOption } from 'echarts'

const props = withDefaults(
  defineProps<{
    options: EChartsOption
    width?: string
    height?: string
  }>(),
  {
    width: '100%',
    height: '360px'
  }
)

const echartDivRef = ref<HTMLElement>()

onMounted(() => {
  const echartInstance = echarts.init(echartDivRef.value!)

  echartInstance.setOption(props.options)
})
</script>

<style lang="scss" scoped></style>

```

**dashboard.vue**

```html
<el-col :span="12">
  <sf-card title="分类商品数量">
    <base-echart :options="options"></base-echart>
  </sf-card>
</el-col>    
```

```tsx
import SfCard from '@/base-ui/card'
import BaseEchart from '@/base-ui/echart'

const options = {
  xAxis: {
    type: 'category',
    data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
  },
  yAxis: {
    type: 'value'
  },
  series: [
    {
      data: [120, 200, 150, 80, 70, 110, 130],
      type: 'bar',
      showBackground: true,
      backgroundStyle: {
        color: 'rgba(180, 180, 180, 0.2)'
      }
    }
  ]
}
```

### 抽取echarts初始化部分的逻辑

base-ui下echart里的hooks下的

**useEchart.ts**

```tsx
import * as Echarts from 'echarts'

export default function (el: HTMLElement) {
  const echartInstance = Echarts.init(el)

  const setOptions = (options: Echarts.EChartsOption) => {
    echartInstance.setOption(options)
  }

  return {
    echartInstance,
    setOptions
  }
}

```

**base-echart.vue**

```tsx
import useEchart from '../hooks/useEchart'

onMounted(() => {
  const { setOptions } = useEchart(echartDivRef.value!)
  setOptions(props.options)
})
```

### 响应式适配

当屏幕缩放时，echarts图表部分看不到，可以调用echarts的方法**resize()**；

当然，如果不是浏览器缩放，也需要响应式适配，这时就需要导出一个函数，让使用者**主动调用**；

**useEchart.ts**

```tsx
import * as Echarts from 'echarts'

export default function (el: HTMLElement) {
  const echartInstance = Echarts.init(el)

  const setOptions = (options: Echarts.EChartsOption) => {
    echartInstance.setOption(options)
  }

  // 响应式适配
  window.addEventListener('resize', () => {
    echartInstance.resize()
  })
  const setReszie = () => {
    echartInstance.resize()
  }

  return {
    echartInstance,
    setOptions,
    setReszie
  }
}
```

### 再分一层

#### 饼图

**base-echart.vue**

```tsx
import { onMounted, ref, defineProps, withDefaults, watchEffect } from 'vue'

onMounted(() => {
  const { setOptions } = useEchart(echartDivRef.value!)
  // 当数据刷新时重新传入option
  watchEffect(() => {
    setOptions(props.options)
  })
})
```

**pie-echart.vue**

```vue
<!--
 * @Description: 待编辑
 * @Author: SiFeng Zhai
 * @Date: 2022-09-16 14:58:19
 * @LastEditors: SiFeng Zhai
 * @LastEditTime: 2022-09-16 15:28:01
-->
<template>
  <div class="pie-echart">
    <base-echart :options="options"></base-echart>
  </div>
</template>

<script lang="ts" setup>
import { computed, defineProps } from 'vue'
import BaseEchart from '@/base-ui/echart'
import { IDataType } from '../types'

const props = defineProps<{
  pieData: IDataType[]
}>()
// 防止数据刷新时图表不更新
const options = computed(() => {
  return {
    tooltip: {
      trigger: 'item'
    },
    legend: {
      orient: 'horizontal',
      left: 'left'
    },
    series: [
      {
        name: '分类数据',
        type: 'pie',
        radius: '50%',
        data: props.pieData,
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowColor: 'rgba(0, 0, 0, 0.5)'
          }
        }
      }
    ]
  }
})
</script>

<style lang="scss" scoped></style>

```

**dashboard.vue**

```html
<el-col :span="7">
  <sf-card title="分类商品数量(饼图)">
    <pie-echart :pieData="categoryGoodsCount"></pie-echart>
  </sf-card>
</el-col>
```

```tsx
import { PieEchart } from '@/components/page-echarts'

const categoryGoodsCount = computed(() => {
  return store.state.dashboard.categoryGoodsCount.map((item: any) => {
    return { name: item.name, value: item.goodsCount }
  })
})
```

#### 玫瑰图

**rose-echart.vue**

```vue
<template>
  <div class="rose-echart">
    <base-echart :options="options"></base-echart>
  </div>
</template>

<script lang="ts" setup>
import { computed, defineProps } from 'vue'
import BaseEchart from '@/base-ui/echart'

import { IDataType } from '../types'

const props = defineProps<{
  roseData: IDataType[]
}>()

const options = computed(() => {
  return {
    toolbox: {
      show: true,
      feature: {
        mark: { show: true },
        dataView: { show: true, readOnly: false },
        restore: { show: true },
        saveAsImage: { show: true }
      }
    },
    series: [
      {
        name: '类别数据',
        type: 'pie',
        radius: [10, 100],
        center: ['50%', '50%'],
        roseType: 'radius',
        itemStyle: {
          borderRadius: 5
        },
        data: props.roseData
      }
    ]
  }
})
</script>

<style lang="scss" scoped></style>

```

#### 面积折线图

**line-echart.vue**

```vue
<template>
  <div class="line-echart">
    <base-echart :options="options"></base-echart>
  </div>
</template>

<script lang="ts" setup>
import { computed, defineProps, withDefaults } from 'vue'
import BaseEchart from '@/base-ui/echart'

const props = withDefaults(
  defineProps<{
    title: string
    xLabel: string[]
    values: any[]
  }>(),
  {
    title: ''
  }
)

const options = computed(() => {
  return {
    title: {
      text: props.title
    },
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross',
        label: {
          backgroundColor: '#6a7985'
        }
      }
    },
    legend: {},
    grid: {
      left: '3%',
      right: '4%',
      bottom: '3%',
      containLabel: true
    },
    xAxis: [
      {
        type: 'category',
        boundaryGap: false,
        data: props.xLabel
      }
    ],
    yAxis: [
      {
        type: 'value'
      }
    ],
    series: [
      {
        name: '分类销量',
        type: 'line',
        stack: 'Total',
        areaStyle: {},
        emphasis: {
          focus: 'series'
        },
        data: props.values
      }
    ]
  }
})
</script>

<style lang="scss" scoped></style>

```

**dashboard.vue**

```html
<sf-card title="分类商品数量">
  <line-echart v-bind="categoryGoodsSale"></line-echart>
</sf-card>
```

```tsx
// 面积折线图数据
const categoryGoodsSale = computed(() => {
  const xLabel: string[] = []
  const values: any[] = []

  const categoryGoodsSale = store.state.dashboard.categoryGoodsSale
  for (const item of categoryGoodsSale) {
    xLabel.push(item.name)
    values.push(item.goodsCount)
  }

  return { xLabel, values }
})
```

#### 柱状图

```vue
<template>
  <div class="bar-echart">
    <base-echart :options="options"></base-echart>
  </div>
</template>

<script lang="ts" setup>
import { computed, defineProps, withDefaults } from 'vue'
import BaseEchart from '@/base-ui/echart'
import * as echarts from 'echarts'

const props = withDefaults(
  defineProps<{
    title?: string
    xLabel: string[]
    values: any[]
  }>(),
  {
    title: ''
  }
)

const options = computed(() => {
  return {
    xAxis: {
      data: props.xLabel,
      axisLabel: {
        inside: true,
        color: '#fff'
      },
      axisTick: {
        show: false
      },
      axisLine: {
        show: false
      },
      z: 10
    },
    yAxis: {
      axisLine: {
        show: false
      },
      axisTick: {
        show: false
      },
      axisLabel: {
        color: '#999'
      }
    },
    dataZoom: [
      {
        type: 'inside'
      }
    ],
    series: [
      {
        type: 'bar',
        showBackground: true,
        itemStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: '#83bff6' },
            { offset: 0.5, color: '#188df0' },
            { offset: 1, color: '#188df0' }
          ])
        },
        emphasis: {
          itemStyle: {
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
              { offset: 0, color: '#2378f7' },
              { offset: 0.7, color: '#2378f7' },
              { offset: 1, color: '#83bff6' }
            ])
          }
        },
        data: props.values
      }
    ]
  }
})
</script>

<style lang="scss" scoped></style>

```

**dashboard.vue**

```html
<sf-card title="分类商品的收藏">
  <bar-echart v-bind="categoryGoodsFavor"></bar-echart>
</sf-card>
```

```tsx
// 柱状图数据
const categoryGoodsFavor = computed(() => {
  const xLabel: string[] = []
  const values: any[] = []

  const categoryGoodsFavor = store.state.dashboard.categoryGoodsFavor
  for (const item of categoryGoodsFavor) {
    xLabel.push(item.name)
    values.push(item.goodsFavor)
  }

  return { xLabel, values }
})
```



#### 地图

**map-echart.vue**

```vue
<template>
  <div class="bar-echart">
    <base-echart :options="options"></base-echart>
  </div>
</template>

<script lang="ts" setup>
import { computed, defineProps, withDefaults } from 'vue'
import BaseEchart from '@/base-ui/echart'
import { convertData } from '../utils/convert-data'
import { IDataType } from '../types'

const props = withDefaults(
  defineProps<{
    title?: string
    mapData: IDataType
  }>(),
  {
    title: ''
  }
)
const options = computed(() => {
  return {
    backgroundColor: '#fff',
    title: {
      text: '全国销量统计',
      left: 'center',
      textStyle: {
        color: '#fff'
      }
    },
    tooltip: {
      trigger: 'item',
      formatter: function (params: any) {
        return params.name + ' : ' + params.value[2]
      }
    },
    visualMap: {
      min: 0,
      max: 60000,
      left: 20,
      bottom: 20,
      calculable: true,
      text: ['高', '低'],
      inRange: {
        color: ['rgb(70, 240, 252)', 'rgb(250, 220, 46)', 'rgb(245, 38, 186)']
      },
      textStyle: {
        color: '#fff'
      }
    },
    geo: {
      map: 'china',
      roam: 'scale',
      emphasis: {
        areaColor: '#f4cccc',
        borderColor: 'rgb(9, 54, 95)',
        itemStyle: {
          areaColor: '#f4cccc'
        }
      }
    },
    series: [
      {
        name: '销量',
        type: 'scatter',
        coordinateSystem: 'geo',
        data: convertData(props.mapData),
        symbolSize: 12,
        emphasis: {
          itemStyle: {
            borderColor: '#fff',
            borderWidth: 1
          }
        }
      },
      {
        type: 'map',
        map: 'china',
        geoIndex: 0,
        aspectScale: 0.75,
        tooltip: {
          show: false
        }
      }
    ]
  }
})
</script>

<style lang="scss" scoped></style>

```

坐标数据

**coordinateData.ts**

```tsx
export const coordinateData: any = {
  海门: [121.15, 31.89],
  鄂尔多斯: [109.781327, 39.608266],
  招远: [120.38, 37.35],
  舟山: [122.207216, 29.985295],
  齐齐哈尔: [123.97, 47.33],
  盐城: [120.13, 33.38],
  赤峰: [118.87, 42.28],
  青岛: [120.33, 36.07],
  乳山: [121.52, 36.89],
  金昌: [102.188043, 38.520089],
  泉州: [118.58, 24.93],
  莱西: [120.53, 36.86],
  日照: [119.46, 35.42],
  胶南: [119.97, 35.88],
  南通: [121.05, 32.08],
  拉萨: [91.11, 29.97],
  云浮: [112.02, 22.93],
  梅州: [116.1, 24.55],
  文登: [122.05, 37.2],
  上海: [121.48, 31.22],
  攀枝花: [101.718637, 26.582347],
  威海: [122.1, 37.5],
  承德: [117.93, 40.97],
  厦门: [118.1, 24.46],
  汕尾: [115.375279, 22.786211],
  潮州: [116.63, 23.68],
  丹东: [124.37, 40.13],
  太仓: [121.1, 31.45],
  曲靖: [103.79, 25.51],
  烟台: [121.39, 37.52],
  福州: [119.3, 26.08],
  瓦房店: [121.979603, 39.627114],
  即墨: [120.45, 36.38],
  抚顺: [123.97, 41.97],
  玉溪: [102.52, 24.35],
  张家口: [114.87, 40.82],
  阳泉: [113.57, 37.85],
  莱州: [119.942327, 37.177017],
  湖州: [120.1, 30.86],
  汕头: [116.69, 23.39],
  昆山: [120.95, 31.39],
  宁波: [121.56, 29.86],
  湛江: [110.359377, 21.270708],
  揭阳: [116.35, 23.55],
  荣成: [122.41, 37.16],
  连云港: [119.16, 34.59],
  葫芦岛: [120.836932, 40.711052],
  常熟: [120.74, 31.64],
  东莞: [113.75, 23.04],
  河源: [114.68, 23.73],
  淮安: [119.15, 33.5],
  泰州: [119.9, 32.49],
  南宁: [108.33, 22.84],
  营口: [122.18, 40.65],
  惠州: [114.4, 23.09],
  江阴: [120.26, 31.91],
  蓬莱: [120.75, 37.8],
  韶关: [113.62, 24.84],
  嘉峪关: [98.289152, 39.77313],
  广州: [113.23, 23.16],
  延安: [109.47, 36.6],
  太原: [112.53, 37.87],
  清远: [113.01, 23.7],
  中山: [113.38, 22.52],
  昆明: [102.73, 25.04],
  寿光: [118.73, 36.86],
  盘锦: [122.070714, 41.119997],
  长治: [113.08, 36.18],
  深圳: [114.07, 22.62],
  珠海: [113.52, 22.3],
  宿迁: [118.3, 33.96],
  咸阳: [108.72, 34.36],
  铜川: [109.11, 35.09],
  平度: [119.97, 36.77],
  佛山: [113.11, 23.05],
  海口: [110.35, 20.02],
  江门: [113.06, 22.61],
  章丘: [117.53, 36.72],
  肇庆: [112.44, 23.05],
  大连: [121.62, 38.92],
  临汾: [111.5, 36.08],
  吴江: [120.63, 31.16],
  石嘴山: [106.39, 39.04],
  沈阳: [123.38, 41.8],
  苏州: [120.62, 31.32],
  茂名: [110.88, 21.68],
  嘉兴: [120.76, 30.77],
  长春: [125.35, 43.88],
  胶州: [120.03336, 36.264622],
  银川: [106.27, 38.47],
  张家港: [120.555821, 31.875428],
  三门峡: [111.19, 34.76],
  锦州: [121.15, 41.13],
  南昌: [115.89, 28.68],
  柳州: [109.4, 24.33],
  三亚: [109.511909, 18.252847],
  自贡: [104.778442, 29.33903],
  吉林: [126.57, 43.87],
  阳江: [111.95, 21.85],
  泸州: [105.39, 28.91],
  西宁: [101.74, 36.56],
  宜宾: [104.56, 29.77],
  呼和浩特: [111.65, 40.82],
  成都: [104.06, 30.67],
  大同: [113.3, 40.12],
  镇江: [119.44, 32.2],
  桂林: [110.28, 25.29],
  张家界: [110.479191, 29.117096],
  宜兴: [119.82, 31.36],
  北海: [109.12, 21.49],
  西安: [108.95, 34.27],
  金坛: [119.56, 31.74],
  东营: [118.49, 37.46],
  牡丹江: [129.58, 44.6],
  遵义: [106.9, 27.7],
  绍兴: [120.58, 30.01],
  扬州: [119.42, 32.39],
  常州: [119.95, 31.79],
  潍坊: [119.1, 36.62],
  重庆: [106.54, 29.59],
  台州: [121.420757, 28.656386],
  南京: [118.78, 32.04],
  滨州: [118.03, 37.36],
  贵阳: [106.71, 26.57],
  无锡: [120.29, 31.59],
  本溪: [123.73, 41.3],
  克拉玛依: [84.77, 45.59],
  渭南: [109.5, 34.52],
  马鞍山: [118.48, 31.56],
  宝鸡: [107.15, 34.38],
  焦作: [113.21, 35.24],
  句容: [119.16, 31.95],
  北京: [116.46, 39.92],
  徐州: [117.2, 34.26],
  衡水: [115.72, 37.72],
  包头: [110, 40.58],
  绵阳: [104.73, 31.48],
  乌鲁木齐: [87.68, 43.77],
  枣庄: [117.57, 34.86],
  杭州: [120.19, 30.26],
  淄博: [118.05, 36.78],
  鞍山: [122.85, 41.12],
  溧阳: [119.48, 31.43],
  库尔勒: [86.06, 41.68],
  安阳: [114.35, 36.1],
  开封: [114.35, 34.79],
  济南: [117, 36.65],
  德阳: [104.37, 31.13],
  温州: [120.65, 28.01],
  九江: [115.97, 29.71],
  邯郸: [114.47, 36.6],
  临安: [119.72, 30.23],
  兰州: [103.73, 36.03],
  沧州: [116.83, 38.33],
  临沂: [118.35, 35.05],
  南充: [106.110698, 30.837793],
  天津: [117.2, 39.13],
  富阳: [119.95, 30.07],
  泰安: [117.13, 36.18],
  诸暨: [120.23, 29.71],
  郑州: [113.65, 34.76],
  哈尔滨: [126.63, 45.75],
  聊城: [115.97, 36.45],
  芜湖: [118.38, 31.33],
  唐山: [118.02, 39.63],
  平顶山: [113.29, 33.75],
  邢台: [114.48, 37.05],
  德州: [116.29, 37.45],
  济宁: [116.59, 35.38],
  荆州: [112.239741, 30.335165],
  宜昌: [111.3, 30.7],
  义乌: [120.06, 29.32],
  丽水: [119.92, 28.45],
  洛阳: [112.44, 34.7],
  秦皇岛: [119.57, 39.95],
  株洲: [113.16, 27.83],
  石家庄: [114.48, 38.03],
  莱芜: [117.67, 36.19],
  常德: [111.69, 29.05],
  保定: [115.48, 38.85],
  湘潭: [112.91, 27.87],
  金华: [119.64, 29.12],
  岳阳: [113.09, 29.37],
  长沙: [113, 28.21],
  衢州: [118.88, 28.97],
  廊坊: [116.7, 39.53],
  菏泽: [115.480656, 35.23375],
  合肥: [117.27, 31.86],
  武汉: [114.31, 30.52],
  大庆: [125.03, 46.58]
}

```

坐标匹配工具函数

**convert-data.ts**

**先匹配坐标，再添加数据**

```tsx
import { coordinateData } from './coordinate-data'

export const convertData = function (data: any) {
  const res = []
  for (let i = 0; i < data.length; i++) {
    const geoCoord = coordinateData[data[i].name]
    if (geoCoord) {
      res.push({
        name: data[i].name,
        value: geoCoord.concat(data[i].value)
      })
    }
  }
  return res
}

```

**dashboard.vue**

```html
<sf-card title="不同城市商品数量">
   <map-echart :mapData="addressGoodsSale"></map-echart>
</sf-card>
```

```tsx
const addressGoodsSale = computed(() => {
  return store.state.dashboard.addressGoodsSale.map((item: any) => {
    return { name: item.address, value: item.count }
  })
})
```



## 3.13 额外补充

### 项目中vue版本升级

```
npm install vue@next
```

还需要升级编译vue文件的工具

```
npm install @vue/compiler-sfc
```

