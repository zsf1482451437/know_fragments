# 1 迭代器

**iterator**

- 是个**对象**
- 符合**迭代器协议**

对某种**数据结构**进行**遍历**的**对象**

## 1.1 迭代器协议

iterator protocol

- **有next()**

## 1.2 next()

**无参或有一个参数的函数**

### 返回值

返回值是一个有**2个属性**的**对象**：

- done
- value

**done**

如果迭代器**可以产生下一个值**，则为**false**，否则为true（遍历完）

**value**

js中任何值，done为true可省略

**迭代器例子**

```js
const iterator = {
  next () {
    return {
      done: true,
      value: 123
    }
  }
}// 没啥用的迭代器
```

有用的迭代器

```js
const names = ['abc', 'cba', 'nba']

let index = 0
const namesIterator = {
  next () {
    if (index < names.length) {
      return {
        done: false,
        value: names[index++]
      }
    } else {
      return {
        done: true,
        value: undefined
      }
    }
  }
}

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
```

### 实现通用迭代器

```js
const names = ['abc', 'cba', 'nba']
const nums = [1, 2, 3, 33]

function ArrayIterator(arr) {
  let index = 0
  return {
    next () {
      if (index < arr.length) {
        return {
          done: false,
          value: arr[index++]
        }
      } else {
        return {
          done: true,
          value: undefined
        }
      }
    }
  }
}

const namesIterator = new ArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

const numsIterator = new ArrayIterator(nums)

console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
```

无限迭代器可以了解下~

## 1.3 可迭代对象

当一个**对象**实现了**iterable protocol**（**不是iterator protocol**）时，就是**可迭代对象**

### 可迭代协议

- 实现[Symbol.iterator]函数

### [Symbol.iterator]函数

#### 返回值

返回一个迭代器

**可迭代对象例子**

```js
const iterableObj = {
  names: ['abc', 'cba', 'nba'],

  [Symbol.iterator] () {
    let index = 0

    return {
      next: () => {
        if (index < this.names.length) {
          return {
            done: true,
          value: this.names[index++]
          }
        } else {
          return {
            done: true,
            value: undefined
          }
        }
      }
    }
  }
}

const iterator = iterableObj[Symbol.iterator]()

console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```

**注意:**

这里面的**next是箭头函数**，不然由于**this的隐式绑定**，**调用next**时会指向**return那个对象**，而**不是iterableObj**，从而**this.names**时没有值

这样，当执行这代码时

```js
const iterator1 = iterableObj[Symbol.iterator]()
```

会生成**新的迭代器**，**不受**其它迭代器**影响**

### 应用

- **for(...of...)**
- 展开运算符**...**
- 解构
- 创建一些对象时（比如new Set()传的参数就是要可迭代对象）

补充：

**普通对象**能使用**展开运算符解构**，用的是**别的语法**，普通对象**不是可迭代对象**，**数组解构**才是因为**它是可迭代对象**

遍历的必须是一个**可迭代对象**

```js
const iterableObj = {
  names: ['abc', 'cba', 'nba'],

  [Symbol.iterator] () {
    let index = 0

    return {
      next: () => {
        if (index < this.names.length) {
          return {
            done: false,
            value: this.names[index++]
          }
        } else {
          return {
            done: true,
            value: undefined
          }
        }
      }
    }
  }
}
for (const item of iterableObj) {
  console.log(item)
}
```

### 原生可迭代对象

- String
- Array
- arguments参数
- Set
- Map
- NodeList集合

**Array**

```js
const names = ['abc', 'vvv', 'vcs']

const iterator = names[Symbol.iterator]()

console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```

### 自定义类的可迭代性

需求：

创建出来的对象是个可迭代对象

```js
class Classroom {
  constructor (name, students) {
    this.name = name
    this.students = students
  }

  [Symbol.iterator] () {
    let index = 0

    return {
      next: () => {
        if (index < this.students.length) {
          return {
            done: false,
            value: this.students[index++]
          }
        } else {
          return {
            done: true,
            value: undefined
          }
        }
      }
    }
  }
}

const classroom = new Classroom('zsf', ['james', 'kobe', 'curry'])

for (const stu of classroom) {
  console.log(stu)
}
```

# 2 生成器

- 特殊的迭代器
- es6新增
- 函数控制、使用的方案

可以**灵活控制函数**什么时候执行、暂停执行

es6之前，普通函数之前只能用**return终止**，而**做不到暂停和恢复执行**

## 2.1 生成器函数

- function后面有*
- 可以通过yield暂停
- 返回值是一个Generator（生成器）

```js
function* foo(params) {
  console.log('开始')

  const value1 = 100
  console.log(value1, '第一段代码')
  yield

  const value2 = 200
  console.log(value2, '第一段代码')
  yield

  console.log('结束')
}

const generator = foo()
generator.next()
generator.next()
generator.next()
```

分段执行

### 生成器执行流程

- 遇到**yield暂停**函数的执行
- 遇到**return生成器停止**

**那暂停时想返回值呢？**

```
function* foo(params) {
  console.log('开始')

  const value1 = 100
  console.log(value1, '第一段代码')
  yield value1

  const value2 = 200
  console.log(value2, '第一段代码')
  yield

  console.log('结束')
}

const generator = foo()
console.log('返回值1：', generator.next())// 返回值1： {value: 100, done: false}
```

## 2.2 生成器的next

### 传参

要是想**给一段代码传参数**呢？

**用上一段代码的yield赋值**

```
function* foo(params) {
  console.log('开始')

  const value1 = 100
  console.log(value1, '第一段代码')
  const n = yield value1

  const value2 = 200 * n
  console.log(value2, '第一段代码')
  yield

  console.log('结束')
}

const generator = foo()
console.log('返回值1：', generator.next())
console.log('返回值2：', generator.next(10))
```

## 2.3 生成器的return

终止执行

```js
function* foo(params) {
  console.log('开始')

  const value1 = 100
  console.log(value1, '第一段代码')
  const n = yield value1

  const value2 = 200 * n
  console.log(value2, '第一段代码')
  yield

  console.log('结束')
}

const generator = foo()
console.log('返回值1：', generator.next())
console.log('返回值2：', generator.return(10))// 返回值2： {value: 10, done: true}
```

## 2.4 生成器的throw

```js
function* foo(params) {
  console.log('开始')

  const value1 = 100
  try {
    yield value1
  } catch (error) {
    console.log('捕获到异常：', error)
  }

  const value2 = 200
  yield value2

  console.log('结束')
}

const generator = foo()
console.log(generator.next())
console.log( generator.throw())

```

## 2.5 生成器替代迭代器

通用迭代器

```js
const names = ['abc', 'cba', 'nba']

function ArrayIterator(arr) {
  let index = 0
  return {
    next () {
      if (index < arr.length) {
        return {
          done: false,
          value: arr[index++]
        }
      } else {
        return {
          done: true,
          value: undefined
        }
      }
    }
  }
}

const namesIterator = new ArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

```

生成器替代

```js
const names = ['abc', 'cba', 'nba']

function* ArrayIterator(arr) {
  let index = 0
  // 依次返回元素
  yield arr[index++]
  yield arr[index++]
  yield arr[index++]
  yield arr[index++]
}

const namesIterator = ArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
```

优化

```js
const names = ['abc', 'cba', 'nba']

function* ArrayIterator(arr) {
  for (const item of arr) {
    yield item
  }
}

const namesIterator = ArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

```

再优化

```js
const names = ['abc', 'cba', 'nba']

function* ArrayIterator(arr) {
  yield* arr
}

const namesIterator = ArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
```

### 语法糖

```js
yield* arr
```

就是下面代码的语法糖

```js
for (const item of arr) {
    yield item
}
```

### 其它应用

#### 迭代一个范围的数字

```js
function* NumIterator(start, end) {
  let index = start
  while (index < end) {
    yield index++
  }
}

const numIterator = NumIterator(10, 20)

console.log(numIterator.next())
console.log(numIterator.next())
console.log(numIterator.next())
console.log(numIterator.next())
```

# 3 应用

## 3.1 多步网络请求

**多次发送网络请求**，并且**上一次的返回结果**作为**下一次请求发送**

类似于**累加拼接**

类似实际开发中，需要**多步请求**才能**拿到想要的数据**

### 常规方案

```js
// request.js
function requestData(url) {
  return new Promise((resolve, reject) => {
    // 模拟
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
  
}

// other.js
// 假设url是ok代表请求成功 bad代表不成功
requestData('zsf').then((res) => {
  requestData('zsf' + 'hhh').then((res) => {
    ...
  })
})
```

不难发现，这段代码……

- 回调地狱

### **解决回调地狱**

promise链式调用，promise获取到**结果不处理**，**返回给下一个promise处理**，以此类推，给**最后一个promise处理**

```
// request.js
function requestData(url) {
  return new Promise((resolve, reject) => {
    // 模拟
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
  
}

// other.js
// 假设url是ok代表请求成功 bad代表不成功
requestData('zsf').then((res) => {
  return requestData(res + 'hhh')
}).then((res) => {
  return requestData(res + 'lll')
}).then((res) => {
  console.log(res)
})
```

但是，这种方案的**可读性不好**

### promise+generator实现



1. **generator.next()**拿到**yield requestData('zsf')**的返回值
2. 所以generator.next()返回的是**{value: promise对象, done: ...}对象**
3. **generator.next().value**拿到promise对象，接着**调用then**方法
4. then的回调函数**拿到结果不处理**，通过**generator.next(res)**把结果**传给getData**（const res1 = yield requestData('zsf')）
5. **getData**将**拿到res1**，**处理**，当参数**发送下一次请求**
6. 同理**generator.next(res).value.then**()重复上述1-4操作
7. 。。。

```js
// request.js
function requestData(url) {
  return new Promise((resolve, reject) => {
    // 模拟
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
  
}

// other.js
function* getData() {
  const res1 = yield requestData('zsf')
  yield requestData(res1 + 'hhh')
}

const generator = getData()
generator.next().value.then((res) => {
  generator.next(res).value.then((res) => {
    console.log(res)
  })
})
```

这时，代码**结构变得清晰**了：

**一次yield，发送一次请求**

不过generator部分依然有**多层嵌套**的问题，但是非常**有规律**，因此可以封装成一个函数，然后**递归**，**自动执行**

```js
// request.js
function requestData(url) {
  return new Promise((resolve, reject) => {
    // 模拟
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
  
}

// other.js
function* getData() {
  const res1 = yield requestData('zsf')
  const res2 = yield requestData(res1 + 'aaa')
  console.log(res2)
}

function execGenerator(genFn) {
  const generator = genFn()
  function exec(res) {
    const result = generator.next(res)
    if (result.done) return result.value
    result.value.then((res) => {
      exec(res)
    })
  }
  exec()
}

execGenerator(getData)
```

当然，开发中不会这样写，只是提供一中思路，突然觉得promis的链式调用挺好的~

TJ大神写了一个node的co包，就是这个函数的功能

```js
const co = request('co')
co(getDate)
```

### async+await

es8新增

本质是**generator+promise**的**语法糖**

```js
// request.js
function requestData(url) {
  return new Promise((resolve, reject) => {
    // 模拟
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
  
}

// other.js
async function getData() {
  const res1 = await requestData('zsf')
  const res2 = await requestData(res1 + 'aaa')
  console.log(res2)
}

getData()
```

# 4 async

es8新增

async用于声明一个异步函数

## 4.1 异步函数

### 和普通函数的区别

#### 返回值

返回值一定是个promise

```js
async function foo(params) {
  console.log('start')
  console.log('end')
}

foo().then((res) => {
  console.log(res)// undefined
})
```

foo()返回值是个promise，**函数体没有返回值时**，默认**返回undefined**，然后**执行then里面的回调函数**，将**undefined传给res**

#### 异常

会被**作为返回promise的reject值**，catch捕获，后续代码依旧运行

要是普通函数，就会终止运行，不会运行后续代码

```js
async function foo(params) {
  console.log('start')
  throw new Error('error')

  console.log('end')
}

foo().catch((err) => {
  console.log(err)
})

console.log('后续代码')// start
后续代码
Error: error
  at foo (test.js:3:9)
  at test.js:8:1
```

#### 内部使用await关键字

```js
async function foo() {
  const res = await getData()
  // 当await getData()没结果，后面代码不会执行
  console.log('后面的代码', res)// 111
}

function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(111)
    }, 1000);
  })
}

foo()
```

**getData**返回**promise**，执行**resolve**

但是getData并**没有调用then**方法

所以**getData后面的代码**相当于**在then里面执行**的

**await跟上其他值，分情况，和then返回值一样**
