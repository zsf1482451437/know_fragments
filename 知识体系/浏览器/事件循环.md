# 1 进程和线程

## 1.1 进程

**启动**一个**应用程序**，就会默认**启动一个进程**（也可能多个）

## 1.2 线程

每**一个进程**中，**至少一个线程**来**执行**程序中的**代码**，这个线程被称之为**主线程**

### js的线程

- js是**单线程**的，他的**进程容器**是：**浏览器或node**
- **同一时刻只能做一件事**
- 如果**这件事非常耗时**，意味着当前的线程就会被**阻塞**
- 所以**耗时的操作**，并**不会放在js线程**上（放在其它线程）
- 比如**网络请求、定时器**

# 2 浏览器的事件循环

有三个角色：

- js线程
- 其它线程
- 事件队列

1. **js线程**执行代码
2. 当发现**耗时操作**时
3. 会将这操作（会有回调的函数）交给**其它线程**处理
4. 当**其它线程**处理完，会将**回调函数**放到**事件队列**中
5. **js线程**会定时地来事件队列**执行那些回调函数**

这三个角色形成一个**闭环**，不停地进行这些操作，称之为**事件循环**

## 2.1 事件队列

分2种：

- 微任务队列（microtask queue）
- 宏任务队列（macro queue）

## 2.2 微任务

哪些回调放微任务呢？

- queueMicrotask
- Promise.then()中的回调函数

## 2.3 宏任务

哪些回调放宏任务呢？

- **定时器**
- **ajax**
- **DOM监听**
- **UI Rendering**

## 2.4 执行顺序

原则：

**在执行任何宏任务之前，都需要保证微任务队列已经被清空**

# 3 node事件循环

node有个核心的库libuv（c语言），专注于文件IO，使得js也能进行服务器开发

与浏览器大同小异

## 3.1 阶段

一次完整的时间循环分很多阶段：

- 定时器
- 待定回调
- idle，prepare
- 轮询
- 检测
- 关闭的回调函数

## 3.2 事件队列

node的事件队列分复杂一点

## 3.3 宏任务

- 定时器
- IO事件
- close事件

## 3.4 微任务

- promise的then回调
- process.nexTick（微任务中优先）
- queueMicrotask