## 专题

- 双指针&滑动窗口
- 链表操作&快慢指针
- 单调栈
- 哈希表&快速查找
- 二叉树递归
- 二叉搜索树
- 动态规划

### 双指针&滑动窗口

1. 1. 两数之和 - 哈希表基础

1. 15. 三数之和 - 双指针经典

1. 3. 无重复字符的最长子串 - 滑动窗口

1. 11. 盛最多水的容器 - 双指针

1. 53. 最大子数组和 - 动态规划入门

1. 121. 买卖股票的最佳时机



### 链表操作&快慢指针

1. 206. 反转链表 - 链表基础

1. 21. 合并两个有序链表

1. 141. 环形链表 - 快慢指针

1. 142. 环形链表 II

1. 19. 删除链表的倒数第 N 个结点

1. 2. 两数相加

### 单调栈

1. 20. 有效的括号 - 栈基础

1. 155. 最小栈

1. 739. 每日温度 - 单调栈

1. 84. 柱状图中最大的矩形

1. 232. 用栈实现队列

1. 225. 用队列实现栈

### 哈希表&快速查找

1. 242. 有效的字母异位词

1. 49. 字母异位词分组

1. 128. 最长连续序列

1. 560. 和为 K 的子数组 - 前缀和+哈希

1. 41. 缺失的第一个正数

1. 146. LRU 缓存 - 综合应用

### 二叉树递归

1. 94. 二叉树的中序遍历

1. 102. 二叉树的层序遍历

1. 104. 二叉树的最大深度

1. 226. 翻转二叉树

1. 101. 对称二叉树

1. 543. 二叉树的直径



### 二叉搜索树

1. 98. 验证二叉搜索树

1. 230. 二叉搜索树中第K小的元素

1. 215. 数组中的第K个最大元素 - 堆

1. 347. 前 K 个高频元素

1. 295. 数据流的中位数

1. 236. 二叉树的最近公共祖先

### 动态规划

1. 70. 爬楼梯 - DP入门

1. 198. 打家劫舍

1. 322. 零钱兑换 - 完全背包

1. 300. 最长递增子序列

1. 72. 编辑距离

1. 5. 最长回文子串



## 输入输出

> 多种输入

使用数组解构，分别保存；

比如

```
输入：
8
1 2 4 9 3 55 64 25
0
```

可以这么写

```js
const [len, arrStr, flag] = [await readLine(), await readLine(), await readLine()]; 
```



## 字符串操作

- 拼 join（数组变字符）
- 删 spilt （字符变数组）
- 改 replace
- 查 

### 坐标移动

1. 处理输入（以`;`拆分,`String.split()`）；
2. 过滤合法坐标（正则 `/^[ADWS]\d{1,2}$/`）；
3. 去掉方向（`String.replace(/[ADWS]/g, '')`），xy轴数值累加（AD-x轴，WS-y轴）；

### 密码校验合格程序

- 长度超过8（`String.length`）；
- 包括大小写字母.数字.其它符号,以上四种至少三种（小写`/[a-z]/`、大写`/[A-Z]/`、数字`/\d/`、其他符号`/[^\w\s]/`）；**(`/[^\w\s]/`待理解)**
- 不能有长度大于2的包含公共元素的子串重复（）；**（待理解）**

### **删除字符串中出现次数最少的字符**

1. 用一个对象统计字符出现次数（遍历字符串 `let of`，键存在于该对象，值就++，不存在就=1）；
2. 找出最小次数(`Math.min(...Object.value(对象))`)；
3. 找出这些最小次数的字符（`Array.filter()`）；
4. 删除这些字符（先拆后拼，`String.split` `String.join`）；

### **整数与IP地址间的转换**

1. 判断整数或ip(`String.includes('.')`);
2. 转换（整数转ip，ip转整数）；**（待理解）**

### 截取字符串

1. 解构输入；
2. 字符转数组，根据位置截取（`String.join、Array.slice`）；
3. 输出，数组转字符；

### 字符串匹配KMP算法

1. 计算前缀函数；**（待理解）**
2. kmp搜索；**(待理解**)

### 字符串分割

- 长度大于等于8，切割，并继续同样处理剩下字符串（`String.silce`）；
- 大于0，末尾补0（`String.repeat`）；

## 排序

### 成绩排序

1. 解构输入（`const [num, flag] = [await readline(), await readline()]`）；
2. 根据数据个数循环，姓名-成绩存为数组；
3. 遍历数组，成绩一项排序（`Array.sort`）；
4. 按格式输出（`[name, value].join(' ')`）；

### **输入整型数组和排序标识，对其元素按照升序或降序进行排序**

1. 解构输入；
2. 字符转数组，根据标识排序；
3. 输出，数组转字符；

### **查找兄弟单词**

1. 目标单词；
2. **兄弟单词重组排序后的结果是一样的**，过滤出兄弟单词（`先split、后sort、再join`）；
3. 排序兄弟单词数组（`sort`）；
4. 按照要求输出；

## 动态规划

### **查找两个字符串a,b中的最长公共子串**

