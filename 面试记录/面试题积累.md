# 自我介绍

面试官你好，我叫翟思丰，计算机科学与技术专业，23年毕业，拥有2年多前端工作经验；

在技术栈上，以React和 Next.js为主 ；

在最近一段工作中，主导跨境商城的技术升级，完成 Next.js 15 迁移与 TypeScript 集成工作，提高团队开发效率；

也做过页面的性能优化，把首页的lcp减少1s以上，提高用户体验；

从0到1给团队带来一套shopify应用开发、部署、上架完整解决方案，减少公司支出，目前已上架两款应用；

使用Node.js 做过文件读写服务，简化多语种翻译工作；

同时，也有使用Docker 打包并部署项目的经验；

平时也注意知识沉淀，搭建了一个个人知识体系网站；

以上就是简单的自我介绍，面试官想从那方面开始了解呢？

# 计算机网络



## Http

### Http 协议

Http（超文本传输协议）是一种用于传输超文本（例如 HTML 文档）的**应用层协议**；

Http 是**基于 TCP/IP**协议的，是一种**无状态**的请求-响应协议;

Http/1.1 和 Http/2 是比较常见的版本，其中**Http/2**具有更高的性能；

### Http/1.0 和 Http/1.1 区别

- **连接方面**：1.0 默认使用非持久连接，而 1.1 默认使用持久连接。通过使用持久连接来使用多个 http 请求**复用同一个 TCP 连接**，避免使用非持久连接每次需要建立连接的**时延**
- **资源请求方面**，在 1.0 中存在一些**浪费宽带**的现象，例如客户端只是需要对象的某个部分，而服务器却将整个对象送过来了，并且**不支持断点续传**功能。1.1 则在请求头引入**range 头域**，它允许值请求某个部分，返回码是 206（Partial Control），这样就方便开发者自由的选择以便于充分利用宽带和连接。
- **缓存方面**，在 1.0 主要使用请求头的**If-Modified-Since**、**Expires**来作为缓存判断的标准，而 1.1 引入更多的缓存控制策略，例如**Etag**、**If-UNmodified-Since**、**If-Match**、**If-None-Match**等多种可供选择的字段控制缓存策略

### Http/1.1 和 Http/2.0 区别

- **二进制协议**，2.0 是一个彻底的二进制协议，请求头和请求体都是二进制，在 1.1 中，请求头必须是文本（ASCII 编码），请求体可以是文本，也可以是二进制。
- **多路复用**，2.0 仍然**复用 TCP 连接**，但是在一个连接里，客户端和服务器端都可以同时发送多个请求或响应，而且不用按照顺序发送一一发送，这样就避免了**队头堵塞**的问题
- **服务器推送**，不用客户端请求，可以**主动向客户端发送资源**。主动给客户端推送一些必要的资源，可以相对减少一些延迟时间。不过注意，推送的是静态资源，和 WebSocket 推送的即时数据是不同的。
- **头信息压缩**，由于**1.1 协议不带状态**，每次请求必须携带所有信息，所以请求的**很多字段是重复的**，比如 cookies 和 User-Agent。这样存在**浪费宽带**的问题，也影响响应速度。而 2.0 引入了头信息压缩机制，一方面，头信息使用**gzip**或**compress**压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有的字段都会存入这个表，生成一个**索引号**，以后就不发送同样字段了，**只发送索引号**，这样就能提高速度了。

### http 和 https 区别

- **安全性**：http是明文传输，存在信息窃听、篡改、劫持等风险；而https在http的基础上加入了SSL/TLS协议（在http和tcp中间加了一层），提供了数据加密、服务器认证、消息完整性等安全保障；
- **端口号**：http默认使用80，https默认使用443；
- **证书**：使用https需要购买SSL证书，并服务器上进行配置，而http则不需要；

### Http 请求和响应

客户端通过发送 http 请求向服务器请求资源。请求包括**请求行**、**请求头**和**请求体**；

请求行包括**http 方法**、**请求 url**和**http 版本**；

服务器收到请求后，会处理并返回 http 响应。响应包括**状态行**、**响应头**和**响应体**；

状态行包括**http 版本**、**状态码**和**状态描述**；

### 状态码

常见状态码

### Http 方法

常见的有：

- GET: 获取资源
- POST: 提交资源或数据
- PUT: 更新资源
- DELETE: 删除资源
- HEAD: 类型 GET，但只返回响应头
- OPTIONS: 查询服务器支持的 http 方法

### GET和POST区别

- **参数位置**：get请求的参数附加在**Url之后**，而post将参数放到**请求体**中；
- **幂等性**：get请求是幂等的，无论请求多少次，结果都是相同的；而post则不是，每次请求都可能导致不同结果；
- **历史记录**：get请求的Url会被浏览器保存在历史记录中，post则不会；
- **数据类型**:  get请求只允许发送**ascii字符**，而post则没限制；
- **数据大小**：由于浏览器和服务器对Url长度有限制，因此get的参数大小是有限制的，而post理论上没有；

### 请求头和响应头

请求头和响应头是**键值对**的集合，用于提供其关于请求和响应的**附加信息**；

常见的请求头有：

- Accept：客户端可接受的**MIME 类型**
- Accept-Encoding：客户端可接受的**编码方式**
- Authorization：用于**身份验证**的凭证
- Content-Type：**请求体**的 MIME 类型
- User-Agent：**客户端**的类型和版本信息

常见的响应头有：

- Content-Type：响应体的 MIME 类型
- Content-Length：响应体的字节长度
- Content-Encoding：响应体和编码方式
- Set-Cookie：设置客户端的 cookie
- Cache-Control：**缓存**控制指令

### 跨域

跨域是指客户端请求与资源所在服务器不同源的资源。浏览器的同源政策限制了跨域请求。为了解决跨域问题，可以使用一下方法：

- **CORS**（跨域资源共享）：服务器通过设置**Access-Control-Allow-Origin**等响应头，允许客户端跨域访问；
- **JSONP**（JSON with Padding）：客户端通过添加<script>标签请求资源，服务器返回**包含 JSON 数据的 JavaScript 代码**。不过这种方法**仅适用于 GET 请求**；
- 第三方代理。

### 缓存

HTTP 缓存是浏览器和服务器通过约定的 **HTTP 头字段** 实现的 “本地存储资源、重复请求时复用” 的机制，核心目标是 **减少服务器请求次数、降低带宽消耗、加快页面加载速度**。它分为 **强缓存** 和 **协商缓存** 两类，触发顺序是 “先强缓存，再协商缓存”，整个过程由浏览器自动完成，无需开发者手动干预。

两者的核心区别是 **“是否需要向服务器发请求”**—— 强缓存命中时完全不发请求，协商缓存必须发请求确认资源是否过期。

#### 强缓存：本地直接复用，不发请求

强缓存由 **响应头** 控制，浏览器首次请求资源后，会将资源和缓存规则（如 “有效期”）存到本地（内存 / 磁盘）。再次请求时，先检查本地缓存是否在有效期内：

- 若在有效期内（命中强缓存）：直接从本地读取资源，不向服务器发任何请求，浏览器控制台显示 `200 OK (from memory cache)` 或 `200 OK (from disk cache)`；
- 若已过期（未命中强缓存）：进入协商缓存流程。

**控制强缓存的核心响应头**（优先级：`Cache-Control` > `Expires`）

#### 协商缓存：发请求确认，决定是否复用

强缓存未命中时，浏览器会向服务器发 **带缓存标识的请求**，由服务器判断资源是否有更新：

- 若资源未更新（命中协商缓存）：服务器返回 `304 Not Modified`，不返回资源内容，浏览器直接复用本地缓存；
- 若资源已更新（未命中协商缓存）：服务器返回 `200 OK` 和最新资源，浏览器更新本地缓存。

**控制协商缓存的 “请求头 - 响应头” 配对**（两组标识，优先级：`ETag/If-None-Match` > `Last-Modified/If-Modified-Since`）：

#### HTTP 缓存完整流程（首次请求 → 再次请求）

以 “浏览器请求 `https://xxx.com/style.css`” 为例，完整交互过程如下：

**1.首次请求：无本地缓存，从服务器获取资源**

1. 浏览器发起 HTTP GET 请求 `style.css`，请求头无缓存相关字段；
2. 服务器接收请求，返回 `200 OK`，同时在响应头中携带缓存规则（如 `Cache-Control: max-age=3600`）和协商缓存标识（如 `ETag: "abc123"`、`Last-Modified: ...`）；
3. 浏览器接收响应：
   - 存储 `style.css` 的内容到本地缓存（内存或磁盘，大文件存磁盘，小文件存内存）；
   - 存储响应头中的缓存规则和协商缓存标识，与资源关联；
4. 浏览器渲染页面，使用 `style.css`。

**2.再次请求：先查强缓存，再查协商缓存**

分三种情况：

- 情况 1：强缓存命中（最理想，不发请求）

  - 浏览器检查本地缓存：`style.css` 的缓存有效期（`max-age=3600`）未过；
  - 直接从本地读取 `style.css`，不向服务器发请求；
  - 控制台显示 `200 OK (from memory cache)` 或 `200 OK (from disk cache)`。

- 情况 2：强缓存未命中，但协商缓存命中（发请求，不返回资源）

  - 浏览器检查本地缓存：`style.css` 的 `max-age` 已过（强缓存未命中）；

  - 浏览器发起请求，在请求头中携带协商缓存标识：

    ```http
    GET /style.css HTTP/1.1
    Host: xxx.com
    If-None-Match: "abc123"  # 携带上次的 ETag
    If-Modified-Since: Wed, 25 Sep 2024 10:00:00 GMT  # 携带上次的 Last-Modified
    ```

  - 服务器对比标识：`style.css` 内容未变（ETag 仍为 `"abc123"`）；

  - 服务器返回 `304 Not Modified`，响应头无资源内容，仅可能更新缓存规则（如延长 `max-age`）；

  - 浏览器复用本地缓存的 `style.css`，并更新缓存有效期。

- 情况 3：强缓存、协商缓存均未命中（发请求，返回新资源）

  - 浏览器检查本地缓存：`max-age` 已过（强缓存未命中）；
  - 浏览器发起请求，携带协商缓存标识；
  - 服务器对比标识：`style.css` 内容已变（ETag 变为 `"def456"`）；
  - 服务器返回 `200 OK`，响应头携带新的 `Cache-Control`、`ETag`、`Last-Modified`，响应体是最新的 `style.css`；
  - 浏览器更新本地缓存（覆盖旧资源和缓存规则），使用新资源渲染页面。

#### 常见资源的缓存策略

- 静态资源（JS/CSS/ 图片）：用 **强缓存为主，协商缓存为辅**，设置较长 `max-age`（如 1 年），配合 “文件哈希命名”（如 `style.abc123.css`）—— 资源更新时哈希变，浏览器认为是新资源，自动绕过缓存；
- 动态资源（接口数据、HTML）：用 **协商缓存为主，不启用强缓存**，设置 `Cache-Control: no-cache`，确保每次都向服务器确认是否有更新（如接口返回的商品库存、新闻列表）。

## TCP

- 三次握手

### 3次握手

TCP建立连接需要知道客户端和服务器知道对方准备好通信；

1. SYN发送：客户端发送一个SYN包到服务器，请求建立连接。这个包有**客户端的初始序列号**（就像客户端对服务器说：“你好，我想建立连接”）；
2. SYN收到-ACK发送：服务器收到SYN包后，会发送SYN-ACK包作为响应。这个包有**服务器的初始序列号**和**对客户端初始序列号的确认**（就像服务器对客户端说：“你好，我收到你的请求了，你准备好了吗？”）；
3. ACK发送：客户端收到SYN-ACK包后，会发送一个ACK包到服务器。这个包有**对服务器初始序列号的确认**（就像客户端对服务器说：“我准备好了，我们可以开始了。”）；



## Web 安全

### XXS

**跨站脚本攻击**，攻击者通过**在网站注入恶意脚本**，当用户浏览这个网页时，这些脚本会被执行，从而达到攻击者的目的。

常见的攻击手段包括：

- **存储型**：攻击者将恶意脚本提交到**网站的数据库**中，当用户请求数据时，恶意脚本会被一起返回并执行。
- **反射型**：攻击者将恶意脚本添加到**URL的查询参数**中，当用户点击这个URL时，恶意脚本会被执行。

> 存储型案例

假设有一个论坛网站，用户可以发布帖子，帖子的内容会被保存在数据库中，然后显示在网页上。如果网站没有正确地过滤用户输入，攻击者可以发布一个包含恶意脚本的帖子，如下：

```html
<p>这是一个很有用的帖子！</p>
<script>document.cookie='steal='+document.cookie;</script>
```

当其他用户浏览这个帖子时，恶意脚本会被执行，用户的 cookie 信息就可能被窃取。

> 反射型案例

假设有一个搜索网站，用户可以输入关键词进行搜索，搜索的关键词会被显示在搜索结果页面上。如果网站没有正确地过滤用户输入，攻击者可以创建一个包含恶意脚本的搜索链接，如下：

```html
http://www.example.com/search?keyword=<script>document.cookie='steal='+document.cookie;</script>
```

当用户点击这个链接时，恶意脚本会被执行，用户的 cookie 信息就可能被窃取。

**如何防御**？

- 对用户输入进行过滤或转义，避免直接在网页中插入用户输入的内容；

- 使用**CSP**（内容安全策略），CSP 的本质是建立一个**白名单**，限制网页中脚本的来源。两种方式开启：
  - 1.设置 **http 头部**的 Content-Security-Policy；
  - 2.设置 **Meta 标签**的方式，设置 http-equiv=“Content-Security-Policy”）

- 使用Http-Only属性来保护Cookies，防止被脚本读取。

### CSRF

**跨站请求伪造**，攻击者伪造用户的请求，让用户在无意中执行攻击者的操作。

如果用户在被攻击网站中保存了**登陆状态**，那攻击者就可以利用这个登陆状态，绕过后台用户验证，冒充用户向服务器执行一些操作

本质是利用 cookies 会在**同源请求中**携带发送的特点，以此来实现用户的冒充。

**常见攻击类型**（a链接、img、隐藏form）

- **GET 类型**的 CSRF，比如在网站中的**img**标签里构建一个请求，当用户打开这个网站的时候会自动发起提交。
- **POST 类型**的 CSRF，比如构建一个**表单**，然后隐藏它，当用户进入页面时，自动提交这个表单。
- **链接类型**的 CSRF，比如在**a 标签的 href 属性**里构建一个请求，当然后诱导用户点击。

**如何防御？**

- **验证Referer**，服务器可以验证请求的Referer，只接受来自同一站点的请求；
- **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数**Token**，当网站再次发起请求时，在**请求参数**中加入服务器返回的 Token，然后服务器对这个 Token 进行验证。这种方解决了使用**cookies**单一验证方式时，可能会被冒用的问题。
- **使用SameSite Cookie**：新的Cookie属性，放置Cookie在夸张请求中被发送；

# 浏览器

## 存储

### 浏览器垃圾回收机制

### 哪些情况会导致内存泄漏



## 原理

### 白屏到有内容经历什么，该怎么缩短

整个过程可分为**网络请求→资源处理→渲染渲染**三大阶段，具体步骤如下：

#### 网络请求阶段

- **DNS 解析**：将域名（如`www.example.com`）转换为 IP 地址（如`192.168.1.1`），浏览器需向 DNS 服务器查询。
- 建立连接
  - TCP 握手：客户端与服务器建立 TCP 连接（3 次握手）。
  - 若用 HTTPS，还需 TLS 握手：协商加密算法、交换证书等（额外 1-2 次往返）。
- **服务器处理（TTFB）**：服务器接收请求后，处理业务逻辑（如查数据库、渲染页面），返回首个字节（TTFB，Time to First Byte）。

**优化手段：**

- DNS优化
  - 用**DNS 预解析**：在`<head>`中添加`<link rel="dns-prefetch" href="https://cdn.example.com">`，提前解析第三方域名（如 CDN、接口域名）
  - 缩短 DNS 缓存时间：通过域名服务商设置合理的 TTL（如 5 分钟），减少重复解析

- 链接优化
  - 启用**HTTP/2 或 HTTP/3**：多路复用（多个请求共用一个连接）、减少握手次数（HTTP/3 基于 QUIC，跳过 TCP 握手）。
  - 部署**HTTPS 时优化 TLS**：使用 TLS 1.3（握手次数从 2 次减为 1 次）、启用 OCSP stapling（减少证书验证步骤）。
  - 选择**全球 CDN**：将静态资源（HTML、CSS、JS、图片）部署到离用户最近的 CDN 节点，减少物理距离延迟。
- 减少TTFB
  - 用**静态生成（SSG）**：如 Next.js 的`getStaticProps`，提前在构建时生成 HTML，服务器直接返回（TTFB 接近 0）。
  - 缓存动态内容：对频繁访问的动态页面，用 Redis 等缓存结果（如用户首页数据缓存 10 分钟）。
  - 优化服务器性能：升级服务器配置、减少数据库慢查询（加索引）、用边缘计算（如 Vercel Edge Functions）处理简单请求。

#### 资源下载与解析

- 下载关键资源

  ：浏览器优先下载 HTML（入口文件），再根据 HTML 中的`link`（CSS）、`<script>`（JS）、`<img>`等标签下载其他资源。

  - 注意：CSS 会阻塞渲染（需构建 CSSOM），同步 JS（无`async`/`defer`）会阻塞 HTML 解析和渲染。

- **构建 DOM 树**：解析 HTML，将标签转换为 DOM 节点（树状结构，描述页面内容）。

- **构建 CSSOM 树**：解析 CSS，生成 CSSOM（描述样式规则，用于计算元素最终样式）。

- 优化**执行关键 JS**：若 JS 操作 DOM/CSSOM（如`document.write`、修改样式），会阻塞后续解析 / 渲染（需等待 JS 执行完成）。



**优化手段**：

- 减少资源体积
  - 压缩 HTML/CSS/JS：用 Webpack 的`terser-webpack-plugin`压缩 JS，`css-minimizer-webpack-plugin`压缩 CSS，HTML 用`html-minifier`去除空格。
  - 图片优化：用 WebP/AVIF 格式（比 JPEG 小 50%）、按显示尺寸加载（如`<img src="img-400w.jpg" srcset="img-400w.jpg 400w, img-800w.jpg 800w" sizes="(max-width: 600px) 400px, 800px">`）。
  - 代码分割：用 React 的`React.lazy`、Next.js 的`dynamic`拆分非首屏代码，只加载当前页面必需的 JS。

- 减少阻塞资源
  - 内联**关键 CSS**：将首屏必需的 CSS（如导航、主标题样式）直接写在`<style>`标签中（避免外部 CSS 文件的网络请求阻塞渲染），非关键 CSS（如页脚、弹窗）异步加载（`media="print"`或动态导入）。
  - 延迟非关键 JS：对不影响首屏的 JS（如统计、广告），加`async`（下载不阻塞解析，下载完立即执行）或`defer`（下载不阻塞解析，解析完再执行），或用`requestIdleCallback`在浏览器空闲时加载。
  - 避免同步 JS 阻塞：将`<script>`放在`</body>`前，或用`type="module"`（默认延迟执行，类似`defer`）。



#### 渲染阶段

- **生成渲染树（Render Tree）**：结合 DOM 和 CSSOM，过滤不可见元素（如`display: none`），保留可见元素及其样式。
- **布局（Layout）**：计算渲染树中元素的位置和大小（也称 “重排”），是耗时操作（尤其元素多或嵌套深时）。
- **绘制（Paint）**：根据布局结果，将元素的像素绘制到屏幕（如颜色、阴影，也称 “重绘”）。
- **合成（Composite）**：将绘制的图层合并为最终屏幕图像（浏览器会将复杂页面分层，优化绘制效率）。



**优化手段**：

- **简化首屏 DOM**：首屏只保留必要元素（如导航、主内容），非首屏内容（如评论、推荐）用懒加载（滚动到可视区再渲染）。

- **避免布局抖动**：首屏渲染时，避免 JS 频繁修改 DOM（如多次`offsetHeight`读取 + 样式修改），集中一次修改（用`requestAnimationFrame`批量处理）。

- **优先渲染文本**：若首屏 LCP 元素是文本，确保字体提前加载（如用`font-display: swap`让系统字体先显示，避免无样式文本闪烁）。

- **使用骨架屏**：在内容加载完成前，显示与最终布局一致的骨架屏（减少用户对 “白屏” 的感知），如：

  ```html
  <!-- 骨架屏示例 -->
  <div class="skeleton">
    <div class="skeleton-title"></div>
    <div class="skeleton-content"></div>
  </div>
  ```

- #### 监控与迭代

  - 用**Lighthouse**（Chrome 开发者工具）审计，查看 “首次内容绘制（FCP）”“最大内容绘制（LCP）” 的具体瓶颈（如 “长任务阻塞”“资源下载慢”）。
  - 接入**真实用户监控（RUM）**：如用`web-vitals`库收集用户实际访问数据，针对性优化弱网、低端设备的体验。

## webwork

#### 了解webworker吗？

# 操作系统

- 进程
- 线程

## 进程

**并发执行的程序**在执行过程中分配和管理资源的基本单位，是一个**动态**概念，竞争计算机资源的基本单位

## 线程

是进程的一个执行单元；

**何时使用多进程，何时使用多线程？**

对资源的管理和保护要求高，**不限制开销和效率**时，使用**多进程**；

要求**效率高**，**切换频繁**时，资源的保护管理要求不是很高时，使用**多线程**；

# 数据结构

- 树

## 树

树可以描述现实生活的一些事物，比如**家谱**、**单位组织结构**等等；

### 相关术语

- 节点的度（degree）：节点的**子树个数**
- 树的度：树的所有**节点中最大的度数**
- 叶子节点（leaf）：**度为 0 的节点**，也叫叶子节点

### 二叉树

#### 重要特性

![image-20220316094155986](C:\Users\86131\Desktop\know_fragments\md-img\image-20220316094155986.png)

- 一个二叉树**第 i 层**的**最大节点数**为**2^(i-1)**
- **深度为 k**的二叉树有最大节点总数为**2^k-1**
- 对于任何非空二叉树 T，若 n0 表示**叶子节点的个数**，n2 表示**度为 2 的非叶子节点个数**，两者满足**n0 = n2 + 1**

# 算法

## 3个乘积最大

```js
/**
 * 题目：给定一个整数数组，有负数，求出该数组中任意三个数的乘积最大值
 *
 * 解题思路：
 * 1. 由于存在负数，三个数乘积最大值可能出现在：
 *    - 三个最大正数相乘
 *    - 两个最小负数（绝对值最大）与最大正数相乘
 * 2. 排序后比较两种情况取最大值
 *
 * 时间复杂度：O(n log n) - 主要是排序的复杂度
 * 空间复杂度：O(1) - 只使用常数额外空间
 */

/**
 * 方法一：排序法（推荐）
 * @param {number[]} nums 整数数组
 * @returns {number} 三个数乘积的最大值
 */
function maximumProduct(nums) {
  // 边界条件检查
  if (nums.length < 3) {
    throw new Error("数组长度必须至少为3");
  }

  // 升序排序
  nums.sort((a, b) => a - b);

  const n = nums.length;

  // 比较两种情况：
  // 1. 三个最大数相乘
  const case1 = nums[n - 1] * nums[n - 2] * nums[n - 3];

  // 2. 两个最小数（可能是负数）与最大数相乘
  const case2 = nums[0] * nums[1] * nums[n - 1];

  return Math.max(case1, case2);
}

/**
 * 方法二：一次遍历法（空间优化）
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 * @param {number[]} nums 整数数组
 * @returns {number} 三个数乘积的最大值
 */
function maximumProductOptimized(nums) {
  // 维护最大的三个数和最小的两个数
  let max1 = -Infinity,
    max2 = -Infinity,
    max3 = -Infinity;
  let min1 = Infinity,
    min2 = Infinity;

  for (const num of nums) {
    // 更新最大的三个数
    if (num > max1) {
      max3 = max2;
      max2 = max1;
      max1 = num;
    } else if (num > max2) {
      max3 = max2;
      max2 = num;
    } else if (num > max3) {
      max3 = num;
    }

    // 更新最小的两个数
    if (num < min1) {
      min2 = min1;
      min1 = num;
    } else if (num < min2) {
      min2 = num;
    }
  }

  // 比较两种情况
  return Math.max(max1 * max2 * max3, min1 * min2 * max1);
}

// 测试用例
function testMaximumProduct() {
  const testCases = [
    [1, 2, 3], // 正数：6
    [1, 2, 3, 4], // 正数：24
    [-1, -2, -3], // 全负数：-6
    [-4, -3, -2, -1, 60], // 混合：720 (-4 * -3 * 60)
    [-1, -2, 1, 2, 3], // 混合：6 (-1 * -2 * 3)
    [0, 1, 2], // 包含0：2
    [-10, -10, 5, 2], // 负数较多：500 (-10 * -10 * 5)
  ];

  console.log("=== 测试结果 ===");
  testCases.forEach((nums, index) => {
    const result1 = maximumProduct([...nums]);
    const result2 = maximumProductOptimized([...nums]);
    console.log(`测试${index + 1}: [${nums.join(", ")}]`);
    console.log(`排序法结果: ${result1}`);
    console.log(`优化法结果: ${result2}`);
    console.log(`结果一致: ${result1 === result2}`);
    console.log("---");
  });
}

testMaximumProduct();

```

## 有序数组找索引

```js
/**
 * 二分查找算法 - 在有序数组中查找目标元素的索引
 * @param {number[]} arr - 有序数组（升序）
 * @param {number} target - 目标元素
 * @returns {number} 目标元素的索引，如果不存在返回-1
 */
const binarySearch = (arr, target) => {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1; // 未找到目标元素
};

/**
 * 二分查找算法 - 递归实现版本
 * @param {number[]} arr - 有序数组（升序）
 * @param {number} target - 目标元素
 * @param {number} left - 左边界
 * @param {number} right - 右边界
 * @returns {number} 目标元素的索引，如果不存在返回-1
 */
const binarySearchRecursive = (
  arr,
  target,
  left = 0,
  right = arr.length - 1
) => {
  if (left > right) {
    return -1; // 未找到目标元素
  }

  const mid = Math.floor((left + right) / 2);

  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1);
  }
};

// 测试用例
const testArray = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];

console.log("测试数组:", testArray);
console.log("查找元素 7 的索引:", binarySearch(testArray, 7)); // 应该返回 3
console.log("查找元素 11 的索引:", binarySearch(testArray, 11)); // 应该返回 5
console.log("查找元素 20 的索引:", binarySearch(testArray, 20)); // 应该返回 -1（不存在）

console.log("\n递归版本测试:");
console.log("查找元素 7 的索引:", binarySearchRecursive(testArray, 7)); // 应该返回 3
console.log("查找元素 11 的索引:", binarySearchRecursive(testArray, 11)); // 应该返回 5
console.log("查找元素 20 的索引:", binarySearchRecursive(testArray, 20)); // 应该返回 -1（不存在）
```



# html

1. 重排（回流)和重绘
2. 图片懒加载
3. CSRF
4. iframe优缺点
5. link和@import的区别
6. script中的defer和aysnc的区别

## 重排（回流)和重绘

重排 reflow，元素的**位置与大小**发生变动时叫重排，也叫**回流**。此时在**layout**阶段，计算每个元素在**设备视口**内的确切位置和大小；

重绘 repaint，元素**样式**发生变动，但是位置没有改变。此时在**Paint**阶段，将渲染树中的每个**节点**转换成屏幕上的**实际像素**，这一步通常叫绘制或栅格化；

重排重绘都会让浏览器重新渲染，而重排得代价更高。

**如何避免过多重排重绘？**

- 样式批量修改
- 分离读写操作

## 图片懒加载

有两个关键：

- 如何判断图片出现在当前视口？
- 如何控制图片的加载？

1. 将图片的**真实地址**保存在一个自定义的属性中（比如 **data-src**），将图片的 **src** 属性设置为一个**占位符图片**（比如一张空白的透明图片）；
2. 监听窗口的**滚动事件**，当滚动到图片的**可视区域**时，将图片的真实地址设置为 src 属性，从而触发图片的加载；
3. 为了避免过多的滚动事件，可以使用**节流**技术，限制触发加载的频率；

提供**`IntersectionObserver`**可以去做这些

需要注意的是，对于一些对 **SEO** 比较重要的图片，比如**标题图**等，应该使用正常的图片加载方式，以保证搜索引擎能够正确地获取这些图片。

## CSRF

cross-site-request forgery 跨站请求伪造 通过**恶意引导**用户一次点击劫持**cookie**进行攻击

以下手段可以减少 CSRF：

- 设置 HTTP Referer 字段，限制请求来源

- token 验证，不放 cookie 中，每次请求手动携带 token 进行校验

## iframe 优缺点

优点：

- **隔离性**：iframe中的JavaScript代码运行在自己的执行环境中，不会影响到主页面；
- **灵活性**：可以加载任何外部页面；
- **并行加载**：iframe的内容会与主页面并行加载，不会阻塞主页面的加载；

缺点：

- **性能问题**：每个iframe都有自己的Window和Document对象，这会增加内存和cpu的使用。
- **SEO问题**：搜索引擎可能无法正确地索引iframe中的内容；
- **跨域问题**：浏览器的同源策略，跨越的iframe有许多限制；
- **布局问题**：iframe的布局和样式控制比较困难，还有进度条等等；
- **历史记录问题**：iframe的导航不会改变浏览器历史记录，这会影响到用户的导航体验；

## link和@import区别

|                             link                             |                           @import                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                除了引入CSS外，还可以引入图标                 |                         只能引入css                          |
| 属于html元素，当浏览器解析HTML文档时，它会立即加载和应用`<link>`引入的CSS。 | 外部样式表被下载和解析后才会被加载和应用。这可能会出现未样式化的内容，也就是所谓的FOUC（Flash of Unstyled Content）。 |
|                     可并行加载多个样式表                     |                按照它们在CSS中的顺序依次加载                 |
|    可通过JavaScript动态创建和修改href属性，动态选择样式表    |                              x                               |
|                         支持媒体查询                         |                              x                               |

> link媒体查询案例

```html
<!-- 对于宽度大于600px的设备，加载"styles-large.css" -->
<link rel="stylesheet" media="(min-width: 600px)" href="styles-large.css">

<!-- 对于宽度小于或等于600px的设备，加载"styles-small.css" -->
<link rel="stylesheet" media="(max-width: 600px)" href="styles-small.css">
```



> 应用场景

大部分情况推荐link引入；

样式表中引入另一个样式表时，推荐@import；

## script中的defer和async的区别

> 共同点：

在下载脚本同时继续解析HTML；

> 不同点

defer，延迟，等html解析完后，再按照脚本在文档中出现的顺序执行它们；

async，异步，一旦脚本下载完成，会停止html解析，立即执行脚本（导致有多个async脚本时，执行顺序不能保证，下载完的先执行）；

# css

## BFC

## 布局

### 定位分别有什么作用

## 重绘&重排

## 响应式和自适应

比较直观的不同是：**自适应**需要开发**多套**界面，**响应式**开发**一套**界面；

而**响应式**可以通过**弹性布局**和**媒体查询**去实现；

## 媒体查询

媒体查询包含以下部分：

- @media：用于定义媒体查询规则的**关键字**，通常写在 css 头部；
- 媒体类型，指设备类型，常见有 screen、print、speech 等
- 关键字 and only not
- 媒体特性：指要匹配的属性，如 min-width、max-width 等

**例子**

```css
@media screen and (min-width: 768px) {
  /* 当屏幕宽度大于等于768px时应用的样式 */
  body {
    font-size: 16px;
  }
}

@media screen and (max-width: 767px) {
  /* 当屏幕宽度小于767px时应用的样式 */
  body {
    font-size: 14px;
  }
}
```

## rem、em、vw、vh

- rem：根据根元素的 font-size；
- em：根据父元素的 font-size；
- vw 和 vh：根据视口宽高；

## 垂直水平居中

- **子绝父相+transform**（给自己设置）
- flex 布局（给父盒子设置）

## 三角形实现

> 原理

先上口诀：宽高为0，一边为0，两边透明。

元素的border的形成机制是：

在盒子四边由**4个三角形**拼接而成，最先呈现的是每个三角形**底部**的内容，当border-width变大后，每个三角形的剩余部分会渐渐出现；

当盒子内容有宽高时，会遮住每个三角形底部之外的部分；

比如

```css
width: 40px;
height: 40px;
border-width: 50px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308155813724](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308155813724.png)

当border-width设置过小时，就是平时的场景（只看到每个三角形底部区域）：

```css
width: 40px;
height: 40px;
border-width: 1px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308160134553](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308160134553.png)

当盒子宽高设置为0后，每个三角形全部呈现：

```css
width: 0;
height: 0;
border-width: 30px;
border-style: solid;
border-color: red yellow green blue;
```

![image-20240308160527073](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308160527073.png)

如果有一边不设置border-width，就只有三个三角形：

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: red yellow green #fff;
```

![image-20240308161000975](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308161000975.png)

如果将上下两边的color设置为透明，不就是只看到一个三角形吗：

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: transparent yellow transparent #fff;
```



![image-20240308161318958](C:\Users\86131\Desktop\know_fragments\md-img\image-20240308161318958.png)

不难发现，不设置border-width那一边就是三角形的方向，三角形方向的方向的邻近两边需要设置透明。

> 实现口诀：宽高为0，一边为0，两边透明

```css
width: 0;
height: 0;
border-width: 30px 30px 30px 0;
border-style: solid;
border-color: transparent yellow transparent #fff;
```

## 伪类和伪元素区别

**伪类**用于选择元素特定状态，比如:hover、:active、:nth-child()等

**伪元素**用于选择元素特定部分或添加新元素，比如::before、::after等

# JavaScript

## js怎么判断变量是否是数组

## **什么是闭包？有哪些应用场景？**

-  “函数 + 函数定义时所在的词法环境” 的组合
   - 当一个**内部函数**引用了**外部函数的变量**，且这个内部函数被 “带出” 外部函数（比如被返回、被赋值给全局变量）时，外部函数执行完后，其变量不会被垃圾回收（GC），因为内部函数还在引用它们 —— 这种 “变量被保留、内部函数能持续访问” 的现象，就是闭包。
   - 闭包带来的结果是：**变量持久化**、**作用域隔离**

-  应用场景
   - 模块化，封装私有变量
   - 函数柯里化，参数复用
   - 防抖节流，控制函数执行频率
   - React Hooks，引用当前组件状态，更新时能访问最新状态（setState）

## 线程

> js为什么不能多线程

因为js的**执行环境**（浏览器或node.js）只提供一个执行线程来运行所有js代码。目的是避免复杂的并发问题；

而js提供了一些机制来模拟并发，例如异步回调、promise、async/await等；

此外，HTML5引入了Web Workers API，它允许js创建多个**后台工作线程**来并行处理任务。但是这些工作线程不能访问**DOM和全局变量**，只能通过**消息传递**与主线程进行通信；



## 关键字和它背后

### typeof

可以检测对象和基本类型；

而对于引用类型（**数组、函数、对象**），都返回**object**；

检测 **/abc/** ,返回 **object**；

但检测**Function**，它返回 **function**；

但检测 **window**，返回 **undefined**；

但检测 null 返回 **object**；

原因是这样：

在 JavaScript 最初的实现中，JavaScript 中的值是由一个**表示类型的标签**和实际数据值表示的。对象的类型标签是 **0**。由于 `null` 代表的是**空指针**（大多数平台下值为 0x00），因此，null 的**类型标签**是 0，`typeof null` 也因此返回 `"object"`。

### instanceof

检测**构造函数**的 `prototype` 属性是否出现在某个**实例对象**的**原型链**上。

也就是说，判断一个**实例**是否属于**某种类型**

```js
let person = function () {};
let no = new person();
no instanceof person; //true
```

#### 实现

其实 instanceof 主要的实现原理就是只要右边变量的 **prototype** 在左边变量的**原型链**上即可；

因此，instanceof 在查找的过程中会**遍历**左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

```js
function new_instance_of(leftVaule, rightVaule) {
  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
  while (true) {
    if (leftVaule === null) {
      return false;
    }
    if (leftVaule === rightProto) {
      return true;
    }
    leftVaule = leftVaule.__proto__;
  }
}
```

#### 原型

希望被**原型链下游**的对象继承的**属性和方法**，都被储存在**prototype**；

为什么说只要**构造函数**的**prototype**出现在**实例**的**原型链**上，就知道**实例**属于该**构造函数**创建出来的呢？

在传统的 OOP 中，首先定义“类”，此后创建**对象实例**时，类中定义的所有**属性和方法**都被复制到实例中;

在 JavaScript 中并不如此复制——而是在**对象实例**和它的**构造器**之间建立一个**链接**（它是**proto**属性，是从构造函数的`prototype`属性派生的）;

我们来看看**构造函数**创建出一个**实例**时，发生了什么吧：

1. 在内存中**创建一个新对象**（空）
2. 将**构造函数**的**显式原型 prototype**赋值给前面创建出来的**对象**的**隐式原型****proto**
3. **构造函数**内部的**this**，会**指向**创建出来的**新对象**
4. **执行**函数代码
5. 如果构造函数没有**返回非空对象**，这**返回**创建出来的**新对象**

```js
function foo() {
  // 下面三行代码是内部自动操作的，不用写
  var moni = {}
  this = {}
  this.__proto__ = foo.prototype

  return this
}
new foo()
```

你看，上面**this**便是构造函数**foo()**创建出来的**实例**，因为该**实例**的**原型链**（this.**proto**）上有**构造函数**的**prototype**

#### **原型链**

从一个**对象上获取属性**，如果在当前**对象中没有**获取到就会去**它的原型**上面获取，如果它的原型上还没有，它原型本质是个对象，也有对应的原型，就再**去它原型的原型**上找，以此类推，沿着原型一层一层往上找，像链条一样

#### constructor

**构造函数**的**prototype**属性**指向**了他的**原型对象**，该**原型对象**里面有**constructor**属性；

每个**实例对象**都从**原型**中继承了一个 **constructor** 属性，该属性**指向**了用于构造此实例的**构造函数**；

constructor 的作用便是回答了**实例从哪里来的问题**。

![image-20220305193122666](C:\Users\86131\Desktop\know_fragments\md-img\image-20220305193122666.png)

#### ===

- 如果两个操作数都是**对象**，只有当它们指向同一个对象时才返回 `true`；

- **数字类型**必须拥有相同的数值。`+0` 和 `-0` 会被认为是相同的值;

```js
console.log([1, 2, 3] === [1, 2, 3]); // false, 因为在js中，这两数组是不同对象（你也可以理解为两个独立内存空间），内容相同而已；假设前者的引用是a，后者引用是b，那执行a[0] = 9之后，b[0]依然是1
console.log(+0 === -0); // true
```

### for of 和 for in 区别

`for of`，es6 新增， 语句遍历**可迭代对象**定义要迭代的数据（与 forEach 不同的是，**遍历可中断**）。

`for...in` 语句以**任意顺序**迭代对象的**可枚举属性**。

#### 对于**数组**

- **for in**遍历的是数组的**索引**，包括原型以及原型链上的**可迭代属性**，且遍历**顺序任意**；
- 而**for of**更适合遍历数组

```js
Object.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```

#### 对于**对象**

- **for in**遍历对象的**可枚举属性**，包括原型和原型链上的属性，要是只想遍历**实例属性**，可用**hasOwnProperty()**判断
- 而**普通对象**并不是可迭代对象，不能使用**for of**遍历

```js
Object.prototype.method = function () {};

const myObject = {
  a: 1,
  b: 2,
  c: 3,
};

for (const key in myObject) {
  console.log(key); // a b c method
}

for (var key in myObject) {
  if (myObject.hasOwnProperty(key)) {
    console.log(key); // a b c
  }
}
```

### Object.keys

他也可以遍历对象的实例属性的**键名**，不包括原型上的属性

```js
Object.prototype.method = function () {};

const myObject = {
  a: 1,
  b: 2,
  c: 3,
};

console.log(Object.keys(myObject)); // ['a', 'b', 'c']
```

### 可迭代对象

当一个**对象**实现了**[Symbol.iterator]函数**时，就是**可迭代对象**；

而**[Symbol.iterator]函数**返回的是**迭代器**（有**next()**的**对象**）；

而**next()**返回值是这**done**和**value**两个属性的**对象**；

**done**：如果迭代器**可以产生下一个值**，则为**false**，否则为 true（遍历完）；

**value**：js 中任何值，done 为 true 可省略；

#### 实现迭代器

```js
const names = ["abc", "cba", "nba"];

let index = 0;
const namesIterator = {
  next() {
    if (index < names.length) {
      return {
        done: false,
        value: names[index++],
      };
    } else {
      return {
        done: true,
        value: undefined,
      };
    }
  },
};

console.log(namesIterator.next()); // { done: false, value: 'abc' }
console.log(namesIterator.next()); // { done: false, value: 'cba' }
console.log(namesIterator.next()); // { done: false, value: 'nba' }
console.log(namesIterator.next()); // { done: true, value: undefined }
```

#### 实现迭代对象

原生可迭代对象：

- String
- Array
- arguments 参数
- Set
- Map
- NodeList 集合

```js
const iterableObj = {
  names: ["abc", "cba", "nba"],

  [Symbol.iterator]() {
    let index = 0;

    return {
      next: () => {
        if (index < this.names.length) {
          return {
            done: false,
            value: this.names[index++],
          };
        } else {
          return {
            done: true,
            value: undefined,
          };
        }
      },
    };
  },
};
for (const item of iterableObj) {
  console.log(item);
}
```

## Object

### Object.is()

Object.is(value1, value2)

判断两个是否为同一个值；

```js
Object.is(+0, -0); // false
Object.is(Number.NaN, NaN);
```

#### 注意

- 与 `==` 不同。`==` 运算符在判断相等前对两边的变量（如果它们不是同一类型）进行强制转换（这种行为将 `"" == false` 判断为 `true`），而 `Object.is` 不会强制转换两边的值。
- 与 `===`也不相同。差别是它们对待有符号的零和 NaN 不同，例如，`===` 运算符（也包括 `==` 运算符）将数字 `-0` 和 `+0` 视为相等，而将 `Number.NaN` 与 `NaN`视为不相等。

### Object.assign()

Object.assign(**target**, ...**sources**)

```js
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
```

#### 注意

- 后续的 source 会**覆盖**前面的 source 的同名属性。
- Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是**引用地址**，就会存在引用共享的问题。

## 常见全局函数

### parseInt()

parseInt(**string**, **radix**)

radix 表示要解析的数字的基数：

- 它介于 2 ~ 36 之间；

- 如果**省略**或其**值为 0**，则数字将以 10 进制来解析；

- 如果它以 “0x” 或 “0X” 开头，将以 16 进制来解析；

- 如果它**小于 2** 或者**大于 36**，将返回 **NaN**。

其它没见过的：

- decodeURI()
- decodeURIComponent()
- encodeURI()
- encodeURIComponent()
- escape()
- unescape()
- getClass()
- isFinite()
- isNaN()

## 常见数组方法

### map

map(callbackFn(**Element**, **index**, **array**), thisArg)

#### **返回值**

新数组

#### **易错**

```js
["1", "2", "3"].map(parseInt); // [1, NaN, NaN]
```

parseInt 接收两个参数，也就是 map 传递给他的 Element 和 index

所以实际的效果是

```js
parseInt("1", 0); // 1
parseInt("2", 1); // NaN
parseInt("3", 2); // NaN
```

解决方案

```js
["1", "2", "3"].map((element) => parseInt(element, 10)); // [1, 2, 3]
```

### forEach

forEach(callbackFn(**Element**, **index**, **array**), thisArg)

#### **返回值**

undefined

#### **注意**

- 不会直接改变调用它的数组，该数组可能会被 `callbackFn` 函数改变。
- 除了抛出异常，无法终止或跳出**forEach**循环

### slice

slice(**begin**, **end**)

**不会改变原数组**

#### **返回值**

新数组

例子

```js
console.log([2, 10, 11, 1, 3].slice(2, 2)); // []
```

因为没有提取到元素，所以新数组为空

## 手写

### 实现Events模块

```js
class Events {
  constructor() {
    // 存储事件与回调的映射关系
    // 结构: { eventName: [callback1, callback2, ...] }
    this.events = Object.create(null);
  }

  /**
   * 监听事件
   * @param {string} eventName - 事件名称
   * @param {Function} callback - 事件触发时执行的回调函数
   */
  on(eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('The callback must be a function');
    }
    
    // 如果事件不存在，初始化一个空数组
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    
    // 将回调函数添加到事件队列中
    this.events[eventName].push(callback);
    
    // 返回当前实例，支持链式调用
    return this;
  }

  /**
   * 触发事件
   * @param {string} eventName - 事件名称
   * @param {...any} args - 传递给回调函数的参数
   */
  emit(eventName, ...args) {
    // 如果事件不存在或没有回调函数，直接返回
    if (!this.events[eventName] || this.events[eventName].length === 0) {
      return false;
    }
    
    // 复制一份回调数组，防止在触发过程中修改原数组导致问题
    const callbacks = [...this.events[eventName]];
    
    // 依次执行所有回调函数，并传递参数
    callbacks.forEach(callback => {
      callback.apply(this, args);
    });
    
    return true;
  }

  /**
   * 移除事件监听
   * @param {string} eventName - 事件名称
   * @param {Function} [callback] - 要移除的回调函数，不传递则移除该事件的所有回调
   */
  off(eventName, callback) {
    // 如果事件不存在，直接返回
    if (!this.events[eventName]) {
      return this;
    }
    
    // 如果不传递callback，移除该事件的所有监听
    if (typeof callback === 'undefined') {
      this.events[eventName] = [];
      return this;
    }
    
    // 只移除指定的callback
    if (typeof callback === 'function') {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    }
    
    return this;
  }

  /**
   * 监听事件一次，触发后自动移除
   * @param {string} eventName - 事件名称
   * @param {Function} callback - 事件触发时执行的回调函数
   */
  once(eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('The callback must be a function');
    }
    
    // 创建一个包装函数，执行后自动移除监听
    const wrapper = (...args) => {
      // 先执行原始回调
      callback.apply(this, args);
      // 然后移除当前的包装函数
      this.off(eventName, wrapper);
    };
    
    // 存储原始回调的引用，方便后续可能的off操作
    wrapper.originalCallback = callback;
    
    // 使用on方法注册包装函数
    this.on(eventName, wrapper);
    
    return this;
  }
}

// 导出模块
module.exports = Events;
```



### 数组去重

#### **indexOf 或 includes**

新建一个空的结果数组，for 循环原数组，判断结果数组**是否存在当前元素**，如果有相同的值则跳过，不相同则 push 进数组。

```js
function unique(arr) {
  if (!Array.isArray(arr)) {
    console.log("type error!");
    return;
  }
  const array = [];
  for (let i = 0; i < arr.length; i++) {
    if (array.indexOf(arr[i]) === -1) {
      array.push(arr[i]);
    }
    // includes写法
    // if (!array.includes(arr[i])) {
    //    array.push(arr[i])
    // }
  }
  return array;
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr)); // [ 1, 'true', true, undefined, null, NaN, NaN, {}, {} ]
```

**缺点**

- NaN、{}没有去重

#### es6 Set

```js
function unique(arr) {
  return Array.from(new Set(arr));
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr));
// [1, "true", true, undefined, null, NaN, {}, {}]
// 高级写法
// [...new Set(arr)]
```

**缺点**

- 无法去掉“{}”空对象

#### filter 和 hasOwnProperty

```js
function unique(arr) {
  const obj = {};
  return arr.filter((item) => {
    return obj.hasOwnProperty(typeof item + item)
      ? false
      : (obj[typeof item + item] = true);
  });
}
const arr = [
  1,
  1,
  "true",
  "true",
  true,
  true,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  {},
  {},
];
console.log(unique(arr));
// [1, "true", true, undefined, null, NaN, {}]   //所有的都去重了
```

过程

```js
1. obj { number1: true } arr [1]
3. obj { number1: true, stringtrue: true } arr [1, 'true']
5. obj { number1: true, stringtrue: true, booleantrue: true } arr [1, 'true', true]
7. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true } arr [1, 'true', true, undefined]
9. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true } arr [1, 'true', true, undefined, null]
11. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true, numberNaN: true } arr [1, 'true', true, undefined, null, NaN]
13. obj { number1: true, stringtrue: true, booleantrue: true, undefinedundefined: true, objectnull: true, numberNaN: true, 'object[object Object]': true } arr [1, "true", true, undefined, null, NaN, {}]
```

### 数组转树

## this 指向

## 箭头函数

**箭头函数和普通函数有什么区别?**

- 箭头函数**不会绑定 this、arguments**属性

- 箭头函数**不能作为构造函数**来使用（不能和 new 关键字一起使用）
- 箭头函数**不绑定 this**，而是根据**外层作用域**来决定 this



## **js怎么处理异步操作？什么是宏任务？微任务？**

- 处理异步操作的进化史：

  - 回调函数，回调地狱
  - Promise，链式调用
  - Generator，yield暂停函数
  - async/await

  逐步优化可读性

- 微任务&宏任务

  - **事件循环（Event Loop）**：JS 处理异步任务的机制。主线程执行同步代码→遇到异步任务放入对应队列→同步代码执行完后，先清空所有微任务→再执行一个宏任务→重复此过程（循环）。
  - **宏任务**：优先级较低的异步任务，执行完后会触发页面重绘。（定时器、网络请求、文件读写、DOM 事件）
  - **微任务**：优先级较高的异步任务，在当前宏任务执行完后立即执行，不会触发重绘。（Promise 的回调、async/await、queueMicrotask、MutationObserver）

  > async/await本质是Promise的语法糖

## Set 和 Map 有什么区别？

- Map 是键值对，Set 是值的集合
- Map 有 get(key)方法,而 set 只有值，没有 get(key)方法
- Set 更多用于数组去重，而 Map 更多用于存储数据

## 深拷贝和浅拷贝

**浅拷贝**是创建一个**新对象**，这个对象有着原始对象属性值的拷贝。如果属性是**基本类型**，拷贝的就是基本类型的**值**，如果属性是**引用类型**，拷贝的就是**内存地址** ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。（两个对象依然共享引用类型属性的内存）

**深拷贝**是从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**，（两个对象不再共享引用类型属性的内存）

**如何实现浅拷贝？**

- 展开运算符

**如何实现深拷贝？**

- JSON 的序列化（stringify）和解析（parse），但是这不会对函数进行处理~

# Vue

- v-if 和 v-show
- v-if 和 v-for 优先级
- key 的作用
- 双向数据绑定
- 响应式系统
- 自定义指令
- 在项目中遇到什么困难？怎么解决的？

## v-if 和 v-show

`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建；

`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染‘

相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换；

总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适；

## v-if 和 v-for 优先级

同时使用 `v-if` 和 `v-for` 是**不推荐的**，因为这样二者的优先级不明显；

当它们同时存在于一个节点上时，**`v-if` 比 `v-for` 的优先级更高（vue2 则反过来）。**这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：

```vue
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```

在外新包装一层 `<template>` 再在其上使用 `v-for` 可以解决这个问题 (这也更加明显易读)：

```vue
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

## key

key 会给每个 vnode 唯一 id，是 diff 算法的一种优化策略；

可以根据 key，更准确、更快的找到对应 vnode 节点；

进行 diff 算法的时候，要进行比对虚拟 DOM，当出现大量的相同的标签时，vnode 会根据 key 和标签名是否一致，若一致再去判断子节点；

这样可以提升判断的速度，在页面重新渲染时更快，消耗更少；

## 双向数据绑定

**双向数据绑定是什么？**

把 `model` 绑定到 `view` 上，当使用 `JavaScript` 代码更新 `model` 时，`view` 就会自动更新，这是**单向数据绑定**；

在单向数据绑定的基础上，当用户更新了 `view` ，那 `model` 的数据也自动更新，这就是 **双向数据绑定**。

**原理是什么？**

它主要有三个重要部分构成：

- 数据层（model）
- 视图层（view）
- 业务逻辑层（viewmodel）

viewmodel 主要的职责是：

- 数据变化后更新视图
- 视图更新后更新数据

**如何实现？**

Vue 的双向数据绑定表现为 `v-model` 指令；

而 v-model 其实是 `v-bind` 和 `v-on` 的语法糖：v-bind 绑定数据，将它加入**响应式系统**，而 v-on 当数据变化时会触发某个事件，从而更新数据；

**作用在普通表单元素上**

```html
<input v-bind:value="message" v-on:input="message=$event.target.value" />
```

//$event 指代当前触发的事件对象;
//$event.target 指代当前触发的事件对象的 dom;
//$event.target.value 就是当前 dom 的 value 值;

- **「接收一个 value 属性」**
- **「在 value 值改变时 触发 xxx 事件」**

**在自定义组件中**

v-model 默认会利用名为 **value** 的 **prop** 和名为 **input 的事件**

## 响应式系统

## 自定义指令

自定义指令是**复用**代码的一种方式，主要是为了复用涉及普通元素的**底层 DOM**的访问逻辑；

使用前先**注册**，分全局和局部；

全局注册主要是通过`Vue.directive`方法进行注册

`Vue.directive`第一个参数是指令的名字（不需要写上`v-`前缀），第二个参数可以是对象数据，也可以是一个指令函数

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive("focus", {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus(); // 页面加载完成之后自动让输入框获取到焦点的小功能
  },
});
```

局部注册通过在组件`options`选项中设置`directive`属性

```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```

然后你可以在模板中任何元素上使用新的 `v-focus` property，如下：

```vue
<input v-focus />
```

### 应用场景

- 表单防止重复提交
- 图片懒加载
- 一键 Copy 的功能
- 拖拽指令
- 页面水印
- 权限校验

**表单防止重复提交**

```js
// 1.设置v-throttle自定义指令
Vue.directive('throttle', {
  bind: (el, binding) => {
    let throttleTime = binding.value; // 节流时间
    if (!throttleTime) { // 用户若不设置节流时间，则默认2s
      throttleTime = 2000;
    }
    let cbFun;
    el.addEventListener('click', event => {
      if (!cbFun) { // 第一次执行
        cbFun = setTimeout(() => {
          cbFun = null;
        }, throttleTime);
      } else {
        event && event.stopImmediatePropagation();
      }
    }, true);
  },
});
// 2.为button标签设置v-throttle自定义指令
<button @click="sayHello" v-throttle>提交</button>
```

**图片懒加载**

```js
const LazyLoad = {
  // install方法
  install(Vue, options) {
    // 代替图片的loading图
    let defaultSrc = options.default;
    Vue.directive("lazy", {
      bind(el, binding) {
        LazyLoad.init(el, binding.value, defaultSrc);
      },
      inserted(el) {
        // 兼容处理
        if ("IntersectionObserver" in window) {
          LazyLoad.observe(el);
        } else {
          LazyLoad.listenerScroll(el);
        }
      },
    });
  },
  // 初始化
  init(el, val, def) {
    // data-src 储存真实src
    el.setAttribute("data-src", val);
    // 设置src为loading图
    el.setAttribute("src", def);
  },
  // 利用IntersectionObserver监听el
  observe(el) {
    let io = new IntersectionObserver((entries) => {
      let realSrc = el.dataset.src;
      if (entries[0].isIntersecting) {
        if (realSrc) {
          el.src = realSrc;
          el.removeAttribute("data-src");
        }
      }
    });
    io.observe(el);
  },
  // 监听scroll事件
  listenerScroll(el) {
    let handler = LazyLoad.throttle(LazyLoad.load, 300);
    LazyLoad.load(el);
    window.addEventListener("scroll", () => {
      handler(el);
    });
  },
  // 加载真实图片
  load(el) {
    let windowHeight = document.documentElement.clientHeight;
    let elTop = el.getBoundingClientRect().top;
    let elBtm = el.getBoundingClientRect().bottom;
    let realSrc = el.dataset.src;
    if (elTop - windowHeight < 0 && elBtm > 0) {
      if (realSrc) {
        el.src = realSrc;
        el.removeAttribute("data-src");
      }
    }
  },
  // 节流
  throttle(fn, delay) {
    let timer;
    let prevTime;
    return function (...args) {
      let currTime = Date.now();
      let context = this;
      if (!prevTime) prevTime = currTime;
      clearTimeout(timer);

      if (currTime - prevTime > delay) {
        prevTime = currTime;
        fn.apply(context, args);
        clearTimeout(timer);
        return;
      }

      timer = setTimeout(function () {
        prevTime = Date.now();
        timer = null;
        fn.apply(context, args);
      }, delay);
    };
  },
};
export default LazyLoad;
```

**一键 Copy 的功能**

```js
    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到
    el.handler = () => {
      if (!el.$value) {
      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意
        Message.warning('无复制内容');
        return;
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement('textarea');
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = 'readonly';
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value;
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea);
      // 选中值并复制
      textarea.select();
      // textarea.setSelectionRange(0, textarea.value.length);
      const result = document.execCommand('Copy');
      if (result) {
        Message.success('复制成功');
      }
      document.body.removeChild(textarea);
    };
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener('click', el.handler);
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value;
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener('click', el.handler);
  },
};

export default vCopy;
```

## 在项目中遇到什么困难？怎么解决的？

可以使用**star**法则：

situation（背景信息）：事情是在**什么情况**下发生，比如生产环境 xxx 问题；

target（目标任务）：你的**目标任务**是什么，比如保证线上服务稳定、分析问题产生原因；

action（采取的行动）：针对这样的情况分析，采用了**什么行动**，比如先重启保证服务正常，之后在进行分析；

result（取得的成果）：结果怎样，再这样的情况下**学到了什么**；

比如我遇到的一个问题：

**背景**

下班回家了，当天的功能已经提交，并且已经发布到生产环境的服务器上了（第二天客户要验收），我负责的那个**模块首页一直在加载，一直不出内容**

**目标**

组长叫我尽快解决，然后提交修改后的代码，**重新发布，保证上线服务**。

**行动**

然后我就看看开发环境的代码，分析产生的原因，然后定位到问题是**递归渲染**，导致死循环

我就修改了对某个数据的监听（使用 useEffect 监听某个数据），去掉对它的依赖，然后控制台也没有提示了；

**结果**

最后也能顺利发布到生产环境，这次的经验告诉我，开发环境报的**提示一定要解决**，不然搞不好到生产环境会出问题

# flutter

- Flutter 是什么？Flutter 和其他移动开发框架有什么不同之处？
- Flutter 中的 StatefulWidget 和 StatelessWidget 有什么区别？在什么情况下应该使用它们？
- Flutter 的路由是什么？如何在 Flutter 应用程序中实现导航？
- Flutter 中的 BuildContext 是什么？它有什么作用？
- Flutter 中的 Widget 是什么？它们是如何工作的？
- Flutter 中的 Layout 和 Container Widget 有什么作用？它们是如何使用的？
- Flutter 中的动画是如何实现的？如何创建动画？
- Flutter 中的异步编程是如何工作的？有哪些常用的异步编程模型？
- Flutter 中的插件是什么？如何在 Flutter 应用程序中使用插件？
- Flutter 中的国际化是如何工作的？如何为应用程序添加多语言支持？

## Flutter 是什么？Flutter 和其他移动开发框架有什么不同之处？

flutter 是一个**快速**、**灵活**且具有**高性能**的**移动应用框架**，可以大大提高开发效率和用户体验。

与其他移动开发框架相比，flutter 具有以下不同之处：

- **构建性能**：flutter 使用自己的**渲染引擎**，可以**直接绘制**ui 组件，**无需通过原生控件**控制进行渲染，这使得应用程序具有更高的渲染性能和流畅度；
- **代码复用（跨平台）**：flutter 支持使用**单一代码库**构建应用程序，可以通过 flutter 框架在**不同平台**上构建应用程序，从而实现代码的复用；
- **热重载**：flutter 的热重载功能看在应用程序运行时**快速预览**、**调试**ui 和业务逻辑，使得开发人员可以更快的进行迭代和调试
- **自定性**：flutter 具有丰富的**自定义组件**和**动画库**，可以帮助开发人员构建出具有**高度个性化**的移动应用；

## **Flutter 中的 Widget 是什么？它们是如何工作的？**

是一种用来**构建用户界面**的**基本元素**，类似于**组件**；

widget 是不可变的，一旦创建就不会改变，而是通过构建新的 widget 树来更新用户界面；

flutter 的 widget 分两种类型：

- StatelessWidget（无状态）
- StatefulWidget（有状态）

StatelessWidget 的属性在构建后**不会再改变**；

StatefulWidget 则不然，在构建后可能发生变化。当 StatefulWidget 中的**属性**发生变化时，flutter 会**重新构建 widget 树**，并重新渲染用户界面；

flutter 中的 widget 是根据**用户界面的层次**结构来组织的，每个 widget 可以有一个或多个子 widget，形成 widget 树。当需要更新用户界面时，flutter 会对**整个 widget**进行重建，而不是对发生变化的部分进行局部更新；

在构建 widget 树时，flutter 会使用一种叫做**渲染对象树**的技术，将**widget**转换成对应的**渲染对象**（RenderObject），并通过渲染对象实现用户界面的绘制。**渲染对象树**中的每个**节点**都与 widget 树中的一个 widget 对应，它们负责将 widget 树中的**布局信息**转换成实际的**绘制命令**；

在 flutter 中，widget 和渲染对象是**分离**的，它们之间的转换由框架自动完成，开发者无需关心具体的实现细节。这使得 flutter 可以在不同平台上实现统一的用户界面，**跨平台**；

# React

## react里面什么是高阶组件

## 为什么不能在if或for循环里面写hook？

## **react18有哪些新特性？**

- 并发渲染（解决之前“一旦开始，必须完成”）
  - crateRoot替代ReactDOM.render
- 自动批处理，减少重新渲染次数（合并多个状态更新为一次渲染）
- 过渡API useTransition（标记非紧急更新，避免阻塞用户交互）
- Suspense 增强与服务器组件（Server Components）
  - 允许客户端用suspense等待异步数据
  - 允许服务器直接渲染组件（无需客户端js），减少客户端bundle体积，提升首屏加载速度
  - 两者结合，可实现“流式渲染”

- 严格模式增强
  - 渲染两次，帮助开发者发现副作用问题

## **react19有哪些新特性？**



## **React渲染流程？**

当状态（State）改变时，React 会重新渲染组件树，计算出变化后的虚拟 DOM（React Element Tree）;

上一次的虚拟 DOM 进行对比（Diffing）;

将实际变化的部分应用到真实的浏览器 DOM 上;

主要分为两个阶段：

- **渲染阶段 (Render Phase)**
  - 这个阶段的任务是**计算**和**对比**，但**不会**直接改变真实的 DOM。这个过程可以被中断、暂停或重启，这是 React 实现并发特性（如 Concurrent Mode）的基础。
    1. 触发渲染（Trigger），状态发生了改变，调度一次新的渲染
    2. 虚拟 DOM 的协调，也就是diff。
       - 基于Props 和 State，**重新调用**组件的渲染函数
       - 这次调用会返回一个**新的 React 元素树（即虚拟 DOM）**
       - React 会将这棵新树与上一次渲染的旧树进行**比较（Diffing）**
    3. 生成 Effect 列表
       - 在协调过程中，React 不仅是在找差异，还会为那些需要**副作用（Effects）** 的 Fiber 节点（React 内部的工作单元）打上标签（Effect Tag）
       - **副作用包括：** 需要插入、更新或删除 DOM 节点，需要执行 `useEffect` 或 `useLayoutEffect` 的回调函数等
       - React 会最终生成一个所有带有副作用的 Fiber 节点的列表

- **提交阶段 (Commit Phase)**
  - 这个阶段是**同步的、不可中断的**。React 会一口气将上个阶段计算出的所有变更应用到真实的 DOM 上，确保用户不会看到不一致的界面状态。
    1. **应用 DOM 更新**：
       - React 会遍历在渲染阶段生成的 Effect 列表。
       - 它执行所有必要的 DOM 操作，包括：**插入、更新和删除**真实的 DOM 节点。
       - 此时，浏览器会重新计算页面的样式和布局（Reflow/Layout），但用户还看不到最终结果
    2. **执行生命周期方法和 Effect 钩子**：
       - **DOM 更新完成后，React 会同步执行 `componentDidMount` 和 `componentDidUpdate` 生命周期方法（类组件）。**
       - **然后，它会调度 `useLayoutEffect` 的回调函数。** 这些回调是同步执行的，可以在这里读取最新的 DOM 布局。
       - **最后，React 会异步调度 `useEffect` 的回调函数。** 这意味着它们会在浏览器完成绘制（Paint）之后执行，不会阻塞页面的显示。
    3. **浏览器绘制（Paint）**：
       - 提交阶段的所有操作（DOM 更新、同步钩子）都完成后，浏览器会将最终像素绘制到屏幕上，用户就看到更新后的界面了。

**简单比喻：**

- **渲染阶段** 就像建筑师在**修改蓝图**，计算哪里需要增加一堵墙，哪里需要拆掉一扇窗。
- **提交阶段** 就像施工队**按照最终蓝图施工**，一口气把墙砌好，把窗户拆掉。

## diff理解？

- **对比不同类型的元素：** 如果根元素类型不同（如从 `<div>` 变成 `<span>`），React 会直接拆毁整个旧的 DOM 树并重建新的。
- **对比同类型的元素：** 如果元素类型相同（如 `<div className="before">` 和 `<div className="after">`），React 会保留底层的 DOM 节点，只更新有变化的属性（在这个例子中，只更新 `className`）。
- **对比子元素：** 当递归子节点时，默认情况下 React 会同时遍历新旧子元素列表。当发现差异时，就会生成一个更新。为了高效，**使用 `key` 属性非常重要**。`key` 帮助 React 识别哪些子项是新增、删除或移动的，从而避免不必要的重新创建。

## **Fiber架构了解多少？**

## **react中如何避免组件重复渲染？react.memo如何做到跳过重新渲染？useCallback和useMemo有什么区别？**

- `React.memo` 缓存组件，只关注props，浅比较
- `useCallback` 缓存函数 props，保证其地址不变
  - 父组件传递给子组件的 **函数 props** 若每次渲染都重新创建（如箭头函数），会导致子组件的 props 引用变化，即使 `React.memo` 也会触发重渲染。
- `useMemo` 缓存计算结果 / 对象 props
  - 简单计算不要，增加内存开销

优化须知： 先通过 React DevTools 的 “Highlight Updates” 功能定位重复渲染的组件，再针对性优化（避免过度优化）



## 类组件与函数组件区别

> 基础认知

本质上代表不同的设计思想和心智模式；

- 类组件的根基是oop，面向对象编程，可以实现继承；
- 函数组件的根基是fp，函数式编程；

> 独特点

- 相对于类组件，函数组件更纯粹、易测试；
- 类组件通过生命周期组织业务逻辑，比如请求常放 `componentDidMount`中

> 性能优化

- 类组件依靠 `componentShouldUpdate` 去阻断渲染；
- 函数组件依靠React.memo缓存渲染结果去减少渲染；

> 未来趋势

hook的推出，促进函数组件的发展

## Hook使用有哪些限制

主要有两点：

- 在函数函数式顶层调用hooks；
- 不要在循环、条件判断或者子函数中使用hooks；

只要是因为**React依赖于Hooks的调用顺序来正确地保存和更新状态**；

若在条件或循环中调用hook，可能导致每次渲染时，hook调用顺序不一致，从而导致错误；

hook的工作原理主要是通过一种叫做**fiber的数据结构**来保存和更新状态；

每个组件都有一个与之关联的fiber，每个fiber都有一个保存hooks状态的链表；

当调用例如useState或useEffect这样的hook时，React会在当前fiber的hooks链表中添加一个新状态或副作用；

然后，当组件重新渲染时，React回按照hooks的调用顺序来更新这些状态和副作用；

## useEffect使用场景、坑

> 场景

- **数据获取**：可以在useEffect中获取数据，然后更新组件状态；
- **订阅/取消订阅**：可以在useEffect中订阅一些事件，然后再清理函数中取消订阅；
- **DOM操作**

> 坑

- **清理函数：**useEffect可以返回一个清理函数，用于在组件卸载或useEffect重新执行一些清理操作。如果忘记返回清理函数，可能会导致**内存泄漏**。
- **异步操作：**useEffect不能直接异步，如果需要在useEffect中执行异步操作，你需要再useEffect中定义一个异步函数，然后调用它。

假设你在`useEffect`中发起了一个异步请求，然后在请求完成后更新组件的状态;

如果在请求完成前组件被卸载，当请求完成后**尝试更新已经卸载的组件的状态**时，就会导致错误。

```js
useEffect(() => {
  async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    setData(data);  // 如果此时组件已经卸载，这里会导致错误
  }

  fetchData();
}, []);
```

为了避免这种情况，你可以在`useEffect`的清理函数中设置一个标志，然后在异步操作完成后检查这个标志：

```js
useEffect(() => {
  let isMounted = true;

  async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();

    if (isMounted) {
      setData(data);
    }
  }

  fetchData();

  return () => {
    isMounted = false;
  };
}, []);
```

在这个例子中，如果组件在请求完成前被卸载，清理函数会被执行，`isMounted`会被设置为`false`。然后在异步操作完成后，检查`isMounted`，如果它是`false`，就不更新状态，从而避免了错误。

## Context应用场景、缺陷

Context允许在组件树中共享值，无需通过props层层传递

> 场景

- **主题切换**：可以存储应用的**主题信息**，然后在需要的组件中读取这个信息；
- **多语言**：可以存储当前的**语言设置**，然后在需要的组件中读取；
- **用户认证**：可以存储当前**用户信息**，在需要的组件中读取；

> 缺陷

- **性能问题：**当一个Context值改变时，所有消费这个Context的组件都会**重新渲染**（此时可能需要一些优化手段，比如React.Memo、shouldComponemUpdate）；
- **复杂性增加：**虽然Context可以避免props“逐层传递”，但也可能导致**数据流难以追踪**，增加了应用的复杂性；

## react事件机制

React 的事件机制是对原生 DOM 事件的**封装与优化**，核心目标是实现**跨浏览器兼容性**、**统一事件接口**和**高效的事件处理**。它并非直接使用原生 DOM 事件，而是通过一层 “合成事件（SyntheticEvent）” 系统实现，具体机制可从以下几个核心维度理解：

### 合成事件（SyntheticEvent）

React 不会将事件处理函数直接绑定到 DOM 元素上，而是**自己实现了一套事件系统**，所有通过 `onXxx`（如 `onClick`、`onChange`）绑定的事件，都是 React 合成事件，而非原生 DOM 事件。

**合成事件的特点**：

- 接口与原生事件一致（如 `e.target`、`e.preventDefault()`、`e.stopPropagation()`），开发者无需学习新 API；
- 跨浏览器兼容：React 会自动处理不同浏览器的事件差异（如 IE 的 `attachEvent` 与标准浏览器的 `addEventListener`），开发者无需手动兼容；
- 是原生事件的 “包装器”：合成事件对象内部包含原生事件（可通过 `e.nativeEvent` 获取），但行为可能略有差异（如事件冒泡的控制）。

### 事件委托（Event Delegation）

React 采用**事件委托（事件代理）** 模式处理事件，而非为每个元素单独绑定事件，这是其性能优化的关键：

- **事件绑定到顶层容器**：所有 React 事件的处理函数，最终都会被委托到 **React 应用的根节点**（如 `#root`，在 React 17 之前是 `document`）上，而非具体的 DOM 元素。
  - 例如，给列表项绑定 `onClick`
  - 实际运行时，React 不会给每个 `<li>` 绑定 `click` 事件，而是在 `<ul>` 的父节点（最终到根节点）上绑定一个全局事件处理函数，通过**事件冒泡**统一处理所有子元素的点击。
- **事件分发流程**：
  - 当用户触发某个事件（如点击）时，流程如下：
    - ① 原生 DOM 事件触发，按原生机制冒泡到 React 根节点；
    - ② 根节点的全局事件处理函数捕获到事件，React 内部根据事件类型（如 `click`）和目标元素（`e.target`），找到对应的 React 组件及绑定的事件处理函数；
    - ③ React 创建**合成事件对象**（`SyntheticEvent`），并将其传递给组件的事件处理函数；
    - ④ 事件处理函数执行，完成后合成事件对象会被销毁（无法在异步操作中访问，需提前保存 `e.target` 等属性）。

## 虚拟DOM

虚拟DOM是将真实DOM抽象成js对象。

### 优势

- 跨平台
- 保证性能下限

### diff算法

1. 将真实DOM映射成虚拟DOM；
2. 当虚拟DOM发生变化时，对比新旧两颗虚拟DOM树，计算补丁（patch）；**生成补丁**
3. 根据patch操作真实DOM；**更新差异**
4. 界面更新；

### 3个优化策略

- **基于树进行对比**：两棵树只对**同一层次**的节点进行比较；如果发现节点已经不存在了，则该节点及其子节点会被完全删除，不会进一步的比较。
- **基于组件进行对比**：如果组件的class一致，则默认为相似的树结构。在组件对比的过程中，如果组件是**同一类型**则进行树比对，如果不是则直接放入**补丁**中只要父组件类型不同，就会被重新渲染。
- **基于节点进行对比：**同一层级的子节点，可以通过**标记key**的方式进行列表对比。

## React18新特性

- **并发模式**（Concurrent Mode）: 全新的**渲染模式**，它可以让react在渲染过程中**不阻塞**主线程，从而使应用保持响应。
- **React Server Component**：在服务器上运行的React组件，它们可以生成html并发送到客户端，而无需包含任何JavaScript；
- **新的Root API**：用于创建和管理React树的根，使得并发模式成为可能（ReactDOM.render-> ReactDOM.createRoot）；
- 等等



# Next.js

## 为什么选择next.js?

- **React 生态的深度整合**:作为 React 官方推荐框架，与 React 生态无缝兼容（如 React Router、React Query、Redux 等），支持最新的 React 特性（如 Hooks、RSC），对 React 开发者友好度极高;
- **渲染策略的极致灵活性**:
  - App Router 引入的 React Server Components（RSC）是革命性的渲染模式：服务端组件无需打包到客户端 JS，大幅减少客户端资源体积；
  - ISR（增量静态再生）成熟度高，支持按需 / 定时更新静态页面，平衡性能与动态性（如电商商品页）;

- **性能优化细节拉满**
  - 自动代码分割（按页面 / 组件拆分 JS）；
  - 内置`next/image`组件（自动优化图片尺寸、格式、懒加载）；
  - `next/font`优化字体加载（避免布局偏移）;
  - 边缘渲染（Edge Rendering）支持，降低全球用户访问延迟;

- **部署与规模化能力**
  - 与 Vercel（Next.js 开发者的平台）深度集成，一键部署，支持自动预览、CI/CD；同时兼容 AWS、Docker 等多种部署方式，适合大型项目规模化落地（如 TikTok、Netflix 的部分业务）

## 流式渲染是为了解决什么问题？

## 服务端组件有哪些特性和限制？

## next里面怎么实现服务器缓存？

# 前端工程化

## 构建

### webpack

#### 构建流程

1. **初始化配置**：读取配置文件（如webpack.config.js）,并解析出入口文件、输出路径、loader、plugin等配置信息。
2. **编译**：使用这些配置信息创建一个新的 `Compiler` 对象，然后调用这对象的`run`方法开始编译；
3. **确定入口**：根据配置中的`entry`找出所有的入口文件；
4. **编译模块**： 从**入口文件**开始，调用相应的**loader**对模块进行转换，然后解析出**模块的依赖**，对依赖的模块进行递归处理；
5. **完成模块编译**：在确定了所有模块的依赖关系后，每个模块会被转换成最终的**可执行代码**；
6. **输出**：根据入口和模块之间的**依赖关系**，组装成一个个**包含多个模块的Chunk**，再把每个Chunk转换成一个单独的文件加入到**输出列表**，这步是可以修改输出内容的最后机会；
7. **输出完成**：在确定好初始内容后，根据配置确定的**路径和文件名**，把文件内容写入到**文件系统**。

简单例子：

```js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
```

在这个配置文件中，`entry` 指定了入口文件，`output` 指定了输出路径和文件名，`module.rules` 指定了处理 CSS 文件的 loader，`plugins` 指定了一个插件用于生成 HTML 文件。

#### 热更新原理

1. **编译阶段**：启用HMR插件后，webpack在编译阶段会向**bundle**中注入HMR runtime代码，这些代码主要负责**和服务端进行通信**，当服务端有模块更新时，获取更新的模块代码；
2. **Dev Sever**：轻量级服务器，在服务端监听文件的变化，当文件发生变化时，webpack会重新编译打包那部分的代码，并通过**Socket.js**向浏览器端发送更新的消息；
3. **浏览器处理阶段：**浏览器端的HMR runtime会接收到更新的消息，然后通过**JSONP**向服务端获取更新的模块文件，然后利用HMR runtime对新旧模块进行对比，替换掉旧的模块，最后通知应用代码模块已经更新；

#### 如何提高webpack构建速度

提高 Webpack 构建速度需要从 **“减少重复工作”“并行处理”“缩小处理范围”** 三个核心方向入手，结合构建流程的关键环节（模块解析、Loader 处理、代码优化等）针对性优化。

##### 缓存优化：避免重复编译（核心提速手段）

Webpack 构建中，大量时间消耗在 “重复解析相同模块”“重复执行 Loader 转换” 上，通过缓存可直接复用之前的处理结果，减少 50% 以上的构建时间。

- **开启 Webpack 内置缓存**（Webpack 5+ 推荐）

  - Webpack 5 自带 `cache` 配置，支持将编译结果缓存到**文件系统**（替代 Webpack 4 的 `hard-source-webpack-plugin`），跨构建（如重启终端）也能复用缓存。

  - ```js
    // webpack.config.js
    module.exports = {
      cache: {
        type: 'filesystem', // 缓存到文件系统（默认内存缓存，重启丢失）
        cacheDirectory: path.resolve(__dirname, '.webpack-cache'), // 缓存目录路径
        // 可选：自定义缓存键（如依赖版本变化时失效）
        buildDependencies: {
          config: [__filename] // 当 webpack 配置文件变化时，缓存失效
        }
      }
    };
    ```

- **启用 Loader 缓存（针对耗时 Loader）**

  - 对于 `babel-loader`（转译 ES6+）、`ts-loader`（TypeScript 转译）等耗时 Loader，开启缓存可避免重复处理相同文件。

  - ```js
    // 以 babel-loader 为例
    module.exports = {
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/, // 排除第三方库（通常已转译）
            use: [
              {
                loader: 'babel-loader',
                options: {
                  cacheDirectory: true, // 开启缓存（默认缓存到 node_modules/.cache/babel-loader）
                  cacheCompression: false // 关闭缓存压缩（节省 CPU 时间）
                }
              }
            ]
          }
        ]
      }
    };
    ```

    

##### 多线程并行处理：利用多核 CPU 提速

- 用 `thread-loader` 加速 Loader 执行
- 用 `terser-webpack-plugin` 多线程压缩代码（生产环境）

#### webpack怎么给资源设置hash的

在 Webpack 中，给资源（JS、CSS、图片等）设置哈希（hash）的核心是通过配置 `output` 选项和各类 loader/plugin 的文件名规则，利用 Webpack 提供的哈希占位符（placeholder）生成带哈希的文件名。

##### 哈希类型：3 种常用占位符

Webpack 提供了 3 种哈希生成方式，适用场景不同：

| 占位符          | 生成逻辑                                                     | 适用场景                                     |
| --------------- | ------------------------------------------------------------ | -------------------------------------------- |
| `[hash]`        | 基于**整个项目的构建结果**生成的哈希（项目级）。每次构建只要有文件变化，哈希就会改变（即使目标文件没变）。 | 不常用（粒度太粗，会导致无关文件哈希变化）。 |
| `[chunkhash]`   | 基于**代码块（chunk）** 生成的哈希（chunk 级）。同一 chunk 内的文件哈希相同，只有 chunk 内容变化时哈希才会变。 | JS 文件（代码分割后的 chunk）。              |
| `[contenthash]` | 基于**文件自身内容**生成的哈希（文件级）。只有文件内容变化时，哈希才会变（最精准）。 | CSS、图片、字体等静态资源（推荐）。          |

##### 具体配置：按资源类型设置哈希

- **JS 文件**通过 `output` 配置：JS 文件的哈希通过 `webpack.config.js` 的 `output.filename` 和 `output.chunkFilename` 配置（前者对应入口文件，后者对应异步加载的 chunk）。

  ```js
  // webpack.config.js
  module.exports = {
    output: {
      // 入口 JS 文件：使用 contenthash（推荐，更精准）
      filename: 'js/[name].[contenthash:8].js', 
      // 异步加载的 JS chunk（如路由懒加载）：使用 contenthash
      chunkFilename: 'js/[name].[contenthash:8].chunk.js',
      // 输出目录（可选，统一放在 dist 下）
      path: path.resolve(__dirname, 'dist')
    }
  };
  ```

  - `[name]`：对应入口名称（如 entry 中的 `main`）或 chunk 名称。
  - `[contenthash:8]`：取哈希的前 8 位（默认更长，可简化）。

- **CSS 文件**配合 `mini-css-extract-plugin`：CSS 文件默认会被 `style-loader` 注入到 JS 中，若要生成独立的 CSS 文件并加哈希，需用 `mini-css-extract-plugin` 提取 CSS，再配置其文件名规则。

  ```js
  const MiniCssExtractPlugin = require('mini-css-extract-plugin');
  
  module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/,
          // 用 MiniCssExtractPlugin.loader 替代 style-loader，提取 CSS 为单独文件
          use: [MiniCssExtractPlugin.loader, 'css-loader'] 
        }
      ]
    },
    plugins: [
      new MiniCssExtractPlugin({
        // CSS 文件名：使用 contenthash（只有 CSS 内容变，哈希才变）
        filename: 'css/[name].[contenthash:8].css',
        // 异步加载的 CSS chunk（如通过 splitChunks 拆分的 CSS）
        chunkFilename: 'css/[name].[contenthash:8].chunk.css'
      })
    ]
  };
  ```

- 图片、字体等静态资源通过 `url-loader` 或 `file-loader`：静态资源（如 `png`、`jpg`、`woff` 等）需通过 `url-loader` 或 `file-loader` 处理，在其 `options.name` 中配置哈希。

  ```js
  module.exports = {
    module: {
      rules: [
        {
          test: /\.(png|jpe?g|gif|svg)$/,
          use: [
            {
              loader: 'url-loader',
              options: {
                // 小于 8kb 的图片转 base64（嵌入 JS/CSS，不生成单独文件）
                limit: 8 * 1024, 
                // 大于 8kb 的图片：输出到 images 目录，文件名带 contenthash
                name: 'images/[name].[contenthash:8].[ext]',
                // 输出路径基于 output.path（即 dist/images/...）
                outputPath: 'images'
              }
            }
          ]
        },
        // 字体文件类似
        {
          test: /\.(woff2?|eot|ttf|otf)$/,
          use: [
            {
              loader: 'file-loader',
              options: {
                name: 'fonts/[name].[contenthash:8].[ext]'
              }
            }
          ]
        }
      ]
    }
  };
  ```

  

**注意事项**：

- **哈希长度控制**：通过 `[contenthash:8]` 取前 8 位（默认 20 位），平衡唯一性和文件名长度。

- **避免无关哈希变化**：

  - 若使用 `splitChunks` 拆分公共库（如 React、Vue），需确保公共库的 chunk 哈希稳定（可单独配置 `cacheGroups` 的 `filename`）。

    ```js
    optimization: {
      splitChunks: {
        cacheGroups: {
          vendor: { // 提取 node_modules 中的第三方库
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            filename: 'js/vendors.[contenthash:8].js' // 单独设置哈希
          }
        }
      }
    }
    ```

- **开发环境无需哈希**：哈希主要用于生产环境（`production`），开发环境（`development`）可简化文件名（如 `[name].js`），提升构建速度。

## 测试

### jest

- 主要特性
- 如何编写单元测试

#### 主要特性

- 零配置
- mock函数

#### 如何编写单元测试

1. 使用it或test编写测试用例
2. 测试用例中使用断言（expect）来验证代码的行为
3. 执行测试

假设有个函数：

```js
function add(a, b) {
    return a + b;
}
```

测试用例：

```js
test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
});
```

# 性能优化

## **LCP代表什么？从时间线来说，分成那几段?(TTFB、资源获取、样式计算，首次可绘)**

## 对项目做过哪些性能优化？

# 通用型业务

## 单页面应用要求seo优化，你会怎么做？

## 大文件上传

- **分片上传**：将大文件分割成多个小片，然后逐个上传。这样可以避免**网络问题**导致整个大文件上传失败，只需要重新上传**失败的片段**；
- **断点续传**：记录**已上传**的文件片段，当上传被中断时，可以从上次中断的地方继续上传，而不是重新上传整个文件；
- **并发上传**：同时上传对多个文件片段，可以加快上传速度；

## 长列表渲染

- **分页**：将长列表分成多个页面，每个页面只显示一部分数据，用户可以通过翻页来查看更多数据；

- **虚拟滚动**：只渲染当前视口内的列表项，当用户滚动时，动态更新视口内的列表项。这样大大减少DOM的节点数量，提高渲染性能；

# 项目

## next.js 和 spa项目有什么区别

| 维度     | SPA（纯 React/Vue）          | Next.js                               |
| -------- | ---------------------------- | ------------------------------------- |
| 渲染核心 | 客户端渲染（CSR）            | 多渲染策略（SSR/SSG/CSR/ISR）         |
| 路由     | 第三方库手动配置             | 文件系统自动路由                      |
| 首屏性能 | 较慢（依赖客户端 JS 加载）   | 更快（SSR/SSG 直接返回内容）          |
| SEO      | 差（动态内容难抓取）         | 优（静态 HTML 内容）                  |
| 适用场景 | 后台管理系统、交互密集型应用 | 博客、电商、资讯等需 SEO / 流量的场景 |

若使用 SSR，需服务器支持 **Node.js 环境**（或通过 Vercel、AWS Lambda 等无服务器平台部署），部署成本略高，但生态工具（如 Vercel）已简化流程。

**Next.js**内置更多优化功能：

- API 路由：可直接在 `pages/api` 目录编写后端接口（无需单独搭建服务器）。
- 图像 / 字体优化：自动压缩图片、懒加载、字体预加载等。
- 中间件：支持请求拦截、权限验证等逻辑。

# 场景

## 为什么选用服务端渲染

- **提升首屏加载速度，减少 “白屏时间”**
- **优化 SEO（搜索引擎优化）**
- **改善内容 “首屏可见性”（FCP）**
- **降低客户端设备的性能压力**
- **更可靠的首屏数据加载**

服务端渲染本质是**将 “页面生成的压力” 从客户端转移到服务器**，通过提前生成完整内容的 HTML，解决客户端渲染在 “首屏速度、SEO、低设备兼容性” 上的短板。

它并非 “替代客户端渲染”，而是与客户端渲染结合（如 Next.js 中，首屏用 SSR，后续交互用客户端 JS），平衡性能、体验和开发效率 —— 尤其适合面向公开用户、依赖搜索流量、对首屏体验敏感的场景（如电商、官网、内容平台）。

## 新镜像/版本部署，然后用户访问的可能是旧版本的资源，你会怎么解决这个问题

用户访问到旧版本资源的核心原因是**缓存机制**（浏览器缓存、CDN 缓存、服务器缓存等）导致资源未及时更新。

### **静态资源：通过 “内容指纹” 避免缓存混淆**

静态资源（JS、CSS、图片、字体等）是缓存的重灾区，核心思路是**让 “内容变化” 对应 “资源路径变化”**，使浏览器 / CDN 认为是 “新资源” 而不使用旧缓存。

- **具体实现**：利用构建工具（Webpack、Vite、Rollup 等）为资源文件名添加**内容哈希（content hash）**。例如：
  - 旧版本：`app.js` → 新版本：`app.8f2d71.js`（哈希值随内容变化而变化）。
  - 原理：当资源内容修改时，哈希值自动更新，文件名改变，浏览器 / CDN 会重新请求新文件，而非使用缓存的旧文件。
- **注意**：
  - 仅对**内容频繁变化的资源**（如业务 JS/CSS）添加哈希；对于长期不变的资源（如第三方库、通用图片），可使用版本号（如`lib/v2/jquery.js`）减少哈希计算开销。
  - 确保 HTML 文件不缓存（见下文），因为 HTML 是引用这些带哈希资源的 “入口”，若 HTML 被缓存，会继续引用旧的哈希资源。

### **缓存策略：通过 HTTP 头精准控制缓存行为**

针对不同类型的资源（HTML、静态资源、API 数据）设置差异化的缓存规则，通过`Cache-Control`等 HTTP 响应头告诉浏览器 / CDN “如何缓存”。

| 资源类型         | 缓存需求               | 推荐 HTTP 头配置                                             |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| HTML 文件        | 禁止强缓存，每次验证   | `Cache-Control: no-cache`（强制浏览器每次请求时验证资源是否更新）`ETag: "版本标识"`（服务器返回资源唯一标识，浏览器下次请求携带验证） |
| 带哈希的静态资源 | 长期缓存（内容不变）   | `Cache-Control: public, max-age=31536000, immutable`（缓存 1 年，且标记为 “不可变”，避免重复验证） |
| 无哈希的静态资源 | 短期缓存或不缓存       | `Cache-Control: max-age=300`（缓存 5 分钟）或`no-store`（完全不缓存） |
| API 接口数据     | 按需缓存（视业务而定） | `Cache-Control: max-age=60`（短期缓存，如 1 分钟）+ `Last-Modified`（记录最后修改时间，用于协商缓存） |

**关键逻辑：**

- 对 “内容不变” 的资源（带哈希）设置长缓存，减少重复请求；
- 对 “入口文件（HTML）” 和 “频繁变化的资源” 设置短缓存或强制验证，确保更新能被感知。

### **CDN 缓存：主动刷新或版本隔离**

若使用 CDN（内容分发网络），CDN 节点可能缓存了旧资源，需额外处理：

- **主动刷新 CDN 缓存**：部署新版本后，通过 CDN 控制台或 API 主动 “清除（Purge）” 旧资源的缓存（如指定`*.js`、`*.css`路径）。注意：全量刷新可能影响 CDN 性能，建议只刷新变化的资源路径（如带旧哈希的文件）。

- **版本目录隔离**：将不同版本的资源部署到独立目录（如`/v1/`、`/v2/`），CDN 会自动将新目录的资源视为新内容，无需手动刷新。例如：

  - 旧版本：`https://cdn.example.com/v1/app.js`

  - 新版本：`https://cdn.example.com/v2/app.js`

    部署时只需切换 HTML 中引用的版本目录即可

### **部署策略：避免新旧版本资源共存导致的混合加载**

如果部署过程中存在 “新旧服务器 / 容器同时提供服务” 的窗口期（如滚动更新），可能出现用户请求到旧服务器的 HTML（引用旧资源），但静态资源已更新到新版本，导致 “404 错误” 或 “资源不匹配”。解决方式：

- **蓝绿部署**：先部署新版本到 “绿环境”，验证通过后将流量从 “蓝环境（旧版本）” 切换到 “绿环境”，切换瞬间旧环境直接下线，避免共存。
- **灰度发布**：逐步将部分流量切到新版本，确保新版本资源完全部署后再扩大范围，同时监控是否有旧资源引用错误。
- **资源预部署**：先部署静态资源（带新哈希），再部署引用新资源的 HTML，确保 HTML 上线时，对应的静态资源已在 CDN / 服务器就绪。

### **兜底方案：强制刷新与版本提示**

尽管上述方法可解决大部分问题，仍可能存在极端场景（如用户本地缓存未过期），可补充：

- **前端版本校验**：在页面加载时，通过 API 请求 “最新版本号”，与本地存储的版本号对比，若不一致，提示用户 “有新版本，是否刷新”（如通过`location.reload(true)`强制刷新，忽略缓存）。
- **Service Worker 缓存清理**（PWA 场景）：若使用 Service Worker 缓存资源，需在新版本部署时更新`service-worker.js`的版本标识，触发客户端 SW 更新，清理旧缓存。

### **总结：核心流程**

1. **构建阶段**：静态资源加内容哈希，确保内容变则路径变；
2. **缓存配置**：HTML 禁止强缓存，带哈希资源长缓存，API 按需缓存；
3. **CDN 处理**：部署后刷新旧缓存或用版本目录隔离；
4. **部署策略**：用蓝绿 / 灰度发布避免新旧资源混合；
5. **兜底机制**：前端版本校验 + 强制刷新提示

## 超过多少s请求终止，有哪些方案

### 客户端

#### `XMLHttpRequest` 原生超时控制

通过`timeout`属性设置超时时间，`ontimeout`事件处理超时逻辑：

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data', true);
xhr.timeout = 5000; // 超时时间5秒（单位：毫秒）

xhr.ontimeout = function() {
  console.log('请求超时，已终止');
  xhr.abort(); // 终止请求
};

xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log('请求成功', xhr.responseText);
    }
  }
};

xhr.send();
```



#### `Fetch API` 结合 `AbortController`

Fetch 本身不支持`timeout`参数，需通过`AbortController`的信号（signal）终止请求：

```js
// 创建控制器
const controller = new AbortController();
const { signal } = controller;

// 设置超时：5秒后终止请求
const timeoutId = setTimeout(() => {
  controller.abort(); // 终止请求
  console.log('请求超时，已终止');
}, 5000);

// 发起请求
fetch('/api/data', { signal })
  .then(response => response.json())
  .then(data => {
    clearTimeout(timeoutId); // 清除超时定时器
    console.log('请求成功', data);
  })
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('请求被主动终止（超时）');
    } else {
      console.log('其他错误', error);
    }
  });
```



#### 第三方请求库（如 Axios）

主流库内置超时配置，底层基于`XMLHttpRequest`或`AbortController`实现：

```js
import axios from 'axios';

// 全局配置超时（所有请求生效）
axios.defaults.timeout = 5000; // 5秒超时

// 单个请求配置超时
axios.get('/api/data', { timeout: 5000 })
  .then(response => console.log('成功', response.data))
  .catch(error => {
    if (error.code === 'ECONNABORTED') {
      console.log('请求超时，已终止');
    }
  });
```



# 经典问题

- 项目困难
- 离职原因



## 项目中遇到什么困难，怎么解决的

背景、任务、过程、结果、总结

> 案例一，流程不熟悉

1. 刚接手项目时，需要新增一个组件（**任务**），但是我不怎么了解新增组件的流程，规范等等，时间又不是很充裕（**背景**）；
2. 复制一个已有组件，然后通过对比和反复修改（**过程**），在要求的时间内完成了一个组件的新增；（**结果**）
3. 之后把这个过程记录下来，以后新增组件便不是问题；(**总结**)

> 案例二，优化流程

1. 一般在周五打镜像，每次构建镜像时，发现用时很长，一个1小时左右，导致经常加班（**背景**），我想缩短这个时间（**任务**）；
2. 通过查阅Dockerfile的一些概念，并询问后端的同事相关意见，最终采用搭建基础镜像（将一些安装下载的稳定环境放到该镜像，无需每次重复安装），调整dockerfile文件；（**过程**）
3. 最后，将构建镜像时间缩短至几十秒；（**结果**）
4. 通过这次，了解到Docker的一些基础概念；（**总结**）

> 案例三，调试技巧

1. 在修改一个bug，需要追踪某个状态，当时只会console.log，在传递过程中需要在各个组件打印，效率很低；（**背景**）
2. 我想提高这个过程的效率（**任务**），上网查询相关资料，发现可以：（**过程**）
   1. debugger断点调试；
   2. React Developer tools插件定位组件，然后查看props；
   3. 通过Redux DevTools插件查看action；
   4. 通过浏览器的开发者工具的network一栏，可以找出请求发起的action；
3. 通过这次，学会一些调试技巧（**结果**）

> 案例四，不熟悉某一方案

## 为什么离职

有两方面：

- 前leader跑路了，新的leader变成一个运营；
- 导致我的工作内容发生重大变化，不符合我的职业规划，所以辞职寻求更合适的发展；

## 你还有什么想问的吗

3中情况：

- 部门负责人
- HR
- 高层领导

> 部门负责人

- 团队目前最主要的任务是什么？
- 如果有机会能加入团队，您对我有什么期望？

> HR

- 咱们这儿工作时间是怎么样的？
-  如果顺利入职的话，请问我的试用期是多久,薪资打折吗？
-  请问贵公司在待遇福利方面有哪些呢？

> 高层领导

- 请问团队当下的重点工作是什么呢？
- 对于这个岗位，您对我当下的有什么建议吗？
