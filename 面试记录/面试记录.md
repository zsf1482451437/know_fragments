# 自我介绍

面试官你好，我叫翟思丰，计算机科学与技术专业，23年毕业，拥有2年多前端工作经验；

在技术栈上，以React和 Next.js为主 ；

在最近一段工作中，主导跨境商城的技术升级，完成 Next.js 15 迁移与 TypeScript 集成工作，提高团队开发效率。

同时，对网站首页进行性能指标优化，将首屏加载时间减少1s以上，提高用户体验；

然后，从0到1开发、部署、上架 Shopify 应用，为了替代收费应用，减少公司支出,目前已上架两款应用；

使用Node.js 做过文件读写服务，用于辅助多语言翻译批量操作，简化多语言翻译步骤；

然后，也有使用Docker 打包并部署项目的经验；

平时也注意知识沉淀，搭建了一个个人知识体系网站；

以上就是简单的自我介绍，面试官想从那方面开始了解呢？

# 公司

## 和生创新技术

### 基础技术与规范

标签语义化、布局、es6

- **HTML5 的语义化标签（如`<article>` `<section>`）在电商网站中如何应用？相比 div 有什么优势？**
  - 比如商品详情页，用`<article>`包裹商品主体信息（标题、价格、描述），`<section>`拆分规格选择区、评价区等模块，`<nav>`定义面包屑导航，`<aside>`放相关推荐商品；
  - 相比div，一是提升 SEO，搜索引擎更容易识别商品核心内容；二是代码可读性更高，新同事接手时能快速定位模块结构；三是增强可访问性，屏幕阅读器能按标签层级解析内容，适配残障用户；

- **用 CSS 实现一个商品列表的响应式布局（PC 端 3 列、移动端 1 列），你会选择 Flex 还是 Grid？为什么？**

- **ES6 的 Promise 和 async/await 在处理电商场景中的异步请求（如加入购物车后同步库存）时，你是如何避免回调地狱的？举个项目中的例子。**
  - 比如 ' 加入购物车→更新库存→同步本地缓存 ' 的流程，使用async/await，让代码逻辑更线性，有助于逻辑理解和排查。

### 框架与工具实战

react、next.js、shopify、工程化

- **在 GogoalShop 中，你用 Redux 管理了哪些状态？有没有遇到过状态冗余的问题？如何优化的？**

  - GogoalShop 中，Redux 主要管理三类全局状态：用户信息（登录态、地址）、购物车（商品列表、选中状态）、全局配置（汇率、语言）；

  - 初期确实遇到过状态冗余问题 —— 比如商品详情页和购物车都存了商品价格，导致同步不一致；

  - 用 Redux Toolkit 的`createEntityAdapter`规范化商品数据（以 ID 为 key 存储，避免重复）；

  - 拆分切片（slice）：将购物车、用户、配置拆分为独立切片，各自维护 reducer 和 action；

  - 用`createSelector`做派生状态计算（比如购物车总价 =Σ(商品单价 × 数量)，避免重复计算）;

    改造后，Redux DevTools 调试时能清晰追踪状态变更来源。

- **解释下 Next.js 的 SSR、SSG、ISR 的区别？在你的电商项目中，商品详情页用了哪种渲染方式？为什么？**

  - 先说区别：
    - **SSR（Server-Side Rendering，服务端渲染）**，每次用户请求时，服务器都会动态生成完整的 HTML 页面并返回给客户端，客户端接收后直接渲染。内容**实时性**极高，但**服务器压力**较大，**首屏加载速度**受服务器响应时间影响。
    - **SSG（Static Site Generation，静态站点生成）**，在项目构建（`next build`）时，提前预渲染好所有页面的 HTML 并存储在服务器，用户请求时直接返回静态 HTML，无需动态生成。性能极佳（静态资源可缓存，加载速度快），服务器压力小，但**内容更新不及**时（需重新构建才能更新页面，适合内容长期不变的场景）。
    - **ISR（Incremental Static Regeneration，增量静态再生）**，结合 SSR 和 SSG 的优势，先在构建时预渲染静态 HTML，之后通过配置`revalidate`参数，让页面在指定时间间隔或按需重新生成（无需全量重构），**兼顾性能（静态资源缓存）和实时性（定期 / 按需更新）**，服务器压力小，适合内容有一定更新频率但非实时变动的场景。
  - 所以，商品详情页我们采用的是 ISR：
    - **商品信息**（价格、描述）不会实时变更（每天同步一次），不需要 SSR 的实时性；
    - 但**商品库存**可能频繁变动，可让页面在 1 小时后自动重新生成，既保证内容新鲜度，又避免 SSR 带来的服务器压力。
    - 对于**热销或秒杀商品**，revalidate配置缩短至5-10min，根据业务调整。
  - 综上，对于这三种渲染方式的选取，其实就是权衡**内容新鲜度**和**服务器压力**。

- **Next15 迁移时，最大的挑战是什么？比如旧代码的 TS 类型适配问题，你是如何解决的？迁移后开发效率提升了多少？**

  - 先回答最大挑战：集中在 **React Server Components (RSC) 模型的全面适配** 以及 **TypeScript 类型系统的兼容调整**
    - 旧项目（基于 Next.js 13）混合了 Page Router（客户端为主）和早期 App Router 的写法
    - **组件类型模糊**：旧代码中未明确区分 “客户端组件” 和 “服务器组件”，导致迁移后频繁出现 “服务器组件使用浏览器 API”“客户端组件缺少 `'use client'` 声明” 等 TS 类型报错
    - **数据获取逻辑不兼容**：旧代码依赖 `getServerSideProps`/`getStaticProps`（Page Router），而 Next.js 15 推荐在服务器组件中直接用 `fetch` 或 Server Actions，导致数据类型定义（如 `Props` 类型）与新数据流不匹配，TS 类型推断失效。
    - **第三方库类型冲突**：部分依赖（如旧版 Redux、UI 组件库）未适配 RSC 类型，在服务器组件中引入时 TS 会提示 “客户端依赖不能在服务器组件中使用”
  - 我采取策略是：**渐进式分步迁移**（先迁14，再迁15顺便集成TS），将迁移事项告知组员，严格审查组员代码
    - **路由层：新旧路由共存，从非核心页面开始迁移**
      - 先迁移非核心页面（如帮助中心、关于我们等静态内容页）到`app/`目录，这些页面依赖少、改动风险低，适合验证 RSC 模型的适配逻辑（如服务器组件与客户端组件的拆分）。
      - 核心业务页面（如首页、详情页、购物车、结算页）仍保留在`pages/`目录，通过 Next.js 的**路由优先级机制**（`app/`目录优先于`pages/`）保证新旧路由兼容，避免影响用户下单等核心流程。
      - 待非核心页面迁移稳定后（约 1 周），再逐步将核心页面按 “用户访问频率从低到高” 排序迁移，每迁移一个页面就简单回归测试下单流程，确保无异常后再进行下一个页面迁移。
    - **组件层：先 “标记分类” 再 “改造迁移”，避免批量重构风险** 
      - 第一步：批量扫描旧组件，通过`'use client'`声明和 TS 类型标记（如`ClientComponent`别名）区分组件类型，仅修改 “明显违规” 的组件（如服务器组件中调用`window`的代码），确保现有功能不崩。
      - 第二部：对标记为 “客户端组件” 的模块，逐步重构逻辑（如将数据请求从客户端`useEffect`移到服务器组件的`fetch`），优先改造 “性能敏感型组件”（如商品卡片列表），非关键组件（如 footer、导航栏）延后处理。
      - 过程中保留旧组件的 “兼容版本”，通过条件导入（`import dynamic from 'next/dynamic'`）在新旧路由中复用，避免重复开发。
    - **数据层：中间层兼容新旧数据逻辑，平滑过渡数据流**
      - 封装统一的数据请求中间层（`data-fetchers/`），同时支持旧模式（`getServerSideProps`调用）和新模式（服务器组件`fetch`），内部通过环境变量控制切换逻辑（如`NEXT_PUBLIC_USE_NEW_FETCH`）。
      - 先在非核心页面启用新数据逻辑，验证数据类型适配（如旧`Props`类型与新`ProductData`的转换），待类型稳定后，再在核心页面逐步替换，期间通过日志监控数据一致性。
    - **TS渐进式集成**：用`allowJs: true`渐进式迁移，对于核心页面，先// @ts-ignore跳过，逐步补全类型（从接口返回值开始）
    - **发布策略：小步迭代**：迁移过程中保持 “每周一个小版本” 的节奏，每个版本仅包含 1-2 个页面

- 你开发的 TT-Options 应用是如何实现商品自定义印号功能的？和 Shopify 的商品 API 是如何交互的？了解 Liquid 模板吗？如果要改 Shopify 主题的商品页，你会从哪里入手？

- 你自定义过 Webpack 的 Loader/Plugin，能举个具体场景吗？比如实现了什么功能，解决了什么问题？

### 电商项目与性能优化

性能优化、项目

- 你说 GogoalShop 首屏加载减少 1.2S，具体用了哪些手段？比如图片优化用了 WebP 还是懒加载？代码分割是按路由还是组件？能说说每个手段的提升数据吗？

- 电商网站中，购物车的实时更新（如添加商品后数量同步）你是如何实现的？如何避免频繁请求导致的性能问题？

### 跨团队协作与业务理解

- 作为半个组长，你是如何分配任务的？如果团队成员对需求理解有分歧，你会怎么协调？
- 和设计师合作时，遇到过复杂动画或兼容问题吗？比如某款浏览器不支持渐变，你是怎么解决的？
- 在 Pageplug 项目中，为京东、顺丰定制组件时，客户需求不明确时你是怎么处理的？如何平衡技术实现和客户体验？

### 新技术与团队推动

- 你是如何快速学会 Shopify 应用开发的？有没有总结过学习方法？比如参考了哪些文档或社区资源？
- 你编写的新员工入职文档包含哪些内容？如何帮助新员工快速上手项目？有没有收到过反馈？
- 如果团队要引入一个新技术（如 Headless 架构），你会如何预研并推动落地？

## 欢与

### **LCP代表什么？从时间线来说，分成那几段?(TTFB、资源获取、样式计算，首次可绘)**



### **react有哪些特性？useTransition用途？**

- 并发渲染（解决之前“一旦开始，必须完成”）
  - crateRoot替代ReactDOM.render
- 自动批处理，减少重新渲染次数
- useTransition（标记非紧急更新）
- 严格模式增强
  - 渲染两次，帮助开发者发现副作用问题

### **React渲染流程？**

当状态（State）改变时，React 会重新渲染组件树，计算出变化后的虚拟 DOM（React Element Tree）;

上一次的虚拟 DOM 进行对比（Diffing）;

将实际变化的部分应用到真实的浏览器 DOM 上;

主要分为两个阶段：

- **渲染阶段 (Render Phase)**
  - 这个阶段的任务是**计算**和**对比**，但**不会**直接改变真实的 DOM。这个过程可以被中断、暂停或重启，这是 React 实现并发特性（如 Concurrent Mode）的基础。
    1. 触发渲染（Trigger），状态发生了改变，调度一次新的渲染
    2. 虚拟 DOM 的协调，也就是diff。
       - 基于Props 和 State，**重新调用**组件的渲染函数
       - 这次调用会返回一个**新的 React 元素树（即虚拟 DOM）**
       - React 会将这棵新树与上一次渲染的旧树进行**比较（Diffing）**
    3. 生成 Effect 列表
       - 在协调过程中，React 不仅是在找差异，还会为那些需要**副作用（Effects）** 的 Fiber 节点（React 内部的工作单元）打上标签（Effect Tag）
       - **副作用包括：** 需要插入、更新或删除 DOM 节点，需要执行 `useEffect` 或 `useLayoutEffect` 的回调函数等
       - React 会最终生成一个所有带有副作用的 Fiber 节点的列表

- **提交阶段 (Commit Phase)**
  - 这个阶段是**同步的、不可中断的**。React 会一口气将上个阶段计算出的所有变更应用到真实的 DOM 上，确保用户不会看到不一致的界面状态。
    1. **应用 DOM 更新**：
       - React 会遍历在渲染阶段生成的 Effect 列表。
       - 它执行所有必要的 DOM 操作，包括：**插入、更新和删除**真实的 DOM 节点。
       - 此时，浏览器会重新计算页面的样式和布局（Reflow/Layout），但用户还看不到最终结果
    2. **执行生命周期方法和 Effect 钩子**：
       - **DOM 更新完成后，React 会同步执行 `componentDidMount` 和 `componentDidUpdate` 生命周期方法（类组件）。**
       - **然后，它会调度 `useLayoutEffect` 的回调函数。** 这些回调是同步执行的，可以在这里读取最新的 DOM 布局。
       - **最后，React 会异步调度 `useEffect` 的回调函数。** 这意味着它们会在浏览器完成绘制（Paint）之后执行，不会阻塞页面的显示。
    3. **浏览器绘制（Paint）**：
       - 提交阶段的所有操作（DOM 更新、同步钩子）都完成后，浏览器会将最终像素绘制到屏幕上，用户就看到更新后的界面了。

**简单比喻：**

- **渲染阶段** 就像建筑师在**修改蓝图**，计算哪里需要增加一堵墙，哪里需要拆掉一扇窗。
- **提交阶段** 就像施工队**按照最终蓝图施工**，一口气把墙砌好，把窗户拆掉。

### diff理解？

- **对比不同类型的元素：** 如果根元素类型不同（如从 `<div>` 变成 `<span>`），React 会直接拆毁整个旧的 DOM 树并重建新的。
- **对比同类型的元素：** 如果元素类型相同（如 `<div className="before">` 和 `<div className="after">`），React 会保留底层的 DOM 节点，只更新有变化的属性（在这个例子中，只更新 `className`）。
- **对比子元素：** 当递归子节点时，默认情况下 React 会同时遍历新旧子元素列表。当发现差异时，就会生成一个更新。为了高效，**使用 `key` 属性非常重要**。`key` 帮助 React 识别哪些子项是新增、删除或移动的，从而避免不必要的重新创建。

### **Fiber架构了解多少？**



### **react中如何避免组件重复渲染？react.memo如何做到跳过重新渲染？useCallback和useMemo有什么区别？**

- `React.memo` 缓存组件，只关注props，浅比较
- `useCallback` 缓存函数 props，保证其地址不变
  - 父组件传递给子组件的 **函数 props** 若每次渲染都重新创建（如箭头函数），会导致子组件的 props 引用变化，即使 `React.memo` 也会触发重渲染。
- `useMemo` 缓存计算结果 / 对象 props
  - 简单计算不要，增加内存开销

优化须知： 先通过 React DevTools 的 “Highlight Updates” 功能定位重复渲染的组件，再针对性优化（避免过度优化）



### **什么是闭包？有哪些应用场景？**

-  “函数 + 函数定义时所在的词法环境” 的组合
  - 当一个**内部函数**引用了**外部函数的变量**，且这个内部函数被 “带出” 外部函数（比如被返回、被赋值给全局变量）时，外部函数执行完后，其变量不会被垃圾回收（GC），因为内部函数还在引用它们 —— 这种 “变量被保留、内部函数能持续访问” 的现象，就是闭包。
  - 闭包带来的结果是：**变量持久化**、**作用域隔离**

- 应用场景
  - 模块化，封装私有变量
  - 函数柯里化，参数复用
  - 防抖节流，控制函数执行频率
  - React Hooks，引用当前组件状态，更新时能访问最新状态（setState）

### **js怎么处理异步操作？什么是宏任务？微任务？**

- 处理异步操作的进化史：

  - 回调函数，回调地狱
  - Promise，链式调用
  - Generator，yield暂停函数
  - async/await

  逐步优化可读性

- 微任务&宏任务

  - **事件循环（Event Loop）**：JS 处理异步任务的机制。主线程执行同步代码→遇到异步任务放入对应队列→同步代码执行完后，先清空所有微任务→再执行一个宏任务→重复此过程（循环）。
  - **宏任务**：优先级较低的异步任务，执行完后会触发页面重绘。（定时器、网络请求、文件读写、DOM 事件）
  - **微任务**：优先级较高的异步任务，在当前宏任务执行完后立即执行，不会触发重绘。（Promise 的回调、async/await、queueMicrotask、MutationObserver）

  > async/await本质是Promise的语法糖

### 了解webworker吗？

### 客户端发请求到服务端响应，这是什么样的过程？







