# ？端到端测试Cypress

## 案例解析

看一段代码

```bash
#!/bin/bash

# By default we assume that the target for the CI is local
target=local

while :; do
    case $1 in
        -e|--env)
            if [ "$2" ]; then
                target=$2
                shift
            else
                die 'ERROR: "--env" requires a non-empty option argument. Allowed values local/ci'
            fi
            ;;
        --env=?*)
            target=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        *) # Default case: No more options, so break out of the loop.
          break
    esac
    shift
done

echo "Got the target: $target"
if [ "$target" == "ci" ]; then
    # On the CI server run the tests in parallel
    # This requires the projectId and the record_key to be configured in your environment variables. By default this is defined on the CI server
    echo "Got the Build ID: $BUILD_ID"
    yarn cypress run --headless \
    --record --key "$CYPRESS_RECORD_KEY" --ci-build-id $BUILD_ID \
    --parallel --group "Electrons on Gitlab CI" \
    --spec "cypress/integration/Regression_TestSuite/**/*.js"
else
    yarn cypress run --headless --browser chromium --spec "cypress/integration/Regression_TestSuite/**/*.js"
fi

```

解析：

```bash
target=local
```

标识测试环境，默认local；

```bash
while :; do
...
done
```

开启一个无限循环，开始处理命令行参数。

```bash
case $1 in
-e|--env)
    if [ "$2" ]; then
        target=$2
        shift
    else
        die 'ERROR: "--env" requires a non-empty option argument. Allowed values local/ci'
    fi
    ;;
--env=?)
    target=${1#=} # Delete everything up to "=" and assign the remainder.
    ;;
*)
    break
    ;;
esac
```

使用 `case` 语句处理**命令行参数**，检查参数是否是 `-e` 或 `--env`。如果是的话，它会将 `target` 变量设置为命令行参数的下一个值（`$2`）；

如果下一个值**不存在**，则会输出错误消息并**退出**脚本；

如果命令行参数是 `--env=`，则会将 `target` 变量设置为 `=` 后面的值。否则，如果命令行参数不是 `-e` 或 `--env`，则会跳出循环。

```bash
shift
```

将命令行参数向左移动一位，以便读取下一个参数。

```bash
echo "Got the target: $target"
```

输出 `target` 变量的值，以帮助你确认设置是否正确。

```bash
if [ "$target" == "ci" ]; then
    # On the CI server run the tests in parallel
    # This requires the projectId and the record_key to be configured in your environment variables. By default this is defined on the CI server
    echo "Got the Build ID: $BUILD_ID"
    yarn cypress run --headless \
    --record --key "$CYPRESS_RECORD_KEY" --ci-build-id $BUILD_ID \
    --parallel --group "Electrons on Gitlab CI" \
    --spec "cypress/integration/Regression_TestSuite/**/*.js"
else
    yarn cypress run --headless --browser chromium --spec "cypress/integration/Regression_TestSuite/**/*.js"
fi
```

如果target标识是ci，则在ci服务器上运行cypress；

使用 `yarn cypress run` 命令运行 Cypress 测试，并传递一些参数。这些参数包括：

- `--headless`：在无头模式下运行 Cypress 测试。
- `--record`：将测试结果上传到 Cypress Dashboard。
- `--key`：Cypress Dashboard 的记录密钥。
- `--ci-build-id`：CI 构建 ID，用于标识测试结果。
- `--parallel`：在 CI 服务器上并行运行测试。
- `--group`：将测试结果分组。
- `--spec`：指定要运行的测试文件。

如果 `target` 变量的值不是 `ci`，则表示要在本地运行测试，并且只需使用以下参数：

- `--headless`：在无头模式下运行 Cypress 测试。
- `--browser chromium`：指定要使用的浏览器。
- `--spec`：指定要运行的测试文件。

# bash

## 构建镜像和pull到远程仓库

```bash
#!/bin/bash

push_image() {
  # 获取参数
  registry="$1"
  repository="$2"
  password="$3"

  # 获取当前时间戳
  timestamp=$(date '+%Y%m%d%H%M%S')

  # 构建 Docker 镜像
  docker build -t "$registry/$repository:$timestamp" .
  if [ $? -eq 0 ]; then
    echo "Docker 镜像构建成功！"
  else
    echo "Docker 镜像构建失败！"
    exit 1
  fi

  # 登录到 Harbor 仓库
  echo "$password" | docker login -u admin --password-stdin "$registry"
  if [ $? -eq 0 ]; then
    echo "登录 Harbor 仓库成功！"
  else
    echo "登录 Harbor 仓库失败！"
    exit 1
  fi

  # 推送镜像到 Harbor 仓库
  docker push "$registry/$repository:$timestamp"
  if [ $? -eq 0 ]; then
    echo "镜像推送成功！"
  else
    echo "镜像推送失败！"
    exit 1
  fi
}

# 获取用户输入
read -p "请输入 Harbor 仓库地址： " registry
read -p "请输入镜像仓库名称： " repository
read -p "请输入登录密码： " password

echo # 换行

# 调用函数，并传递用户输入的参数
push_image "$registry" "$repository" "$password"

```



# linux

## 查看端口进程

1.netstat

```
netstat -tuln | grep 7777
```

这将显示所有正在监听（LISTEN）该端口的进程以及相关的详细信息。

- `-t`：只显示 TCP 协议相关的连接信息。
- `-u`：只显示 UDP 协议相关的连接信息。
- `-l`：只显示正在监听（LISTEN）的连接信息。
- `-n`：以数字形式显示 IP 地址和端口号，而不进行反向解析。
- `-a`：显示所有连接，包括正在监听（LISTEN）和已建立的连接。
- `-p`：显示与连接关联的进程/程序的PID和名称。
- `-s`：显示统计信息，如接收和发送的数据包数量。
- `-r`：显示路由表信息。
- `-c`：连续输出，持续显示连接信息。

**例子**

执行 `netstat -aln | grep 7777`

输出

```
tcp  0 0 0.0.0.0:7777 0.0.0.0:* LISTEN
tcp6 0 0 :::7777      :::*      LISTEN
```

输出结果说明了以下情况：

1. 第一行输出显示了一个 TCP 连接，它正在监听（LISTEN）0.0.0.0:7777 这个地址。这表示该主机上的所有**网络接口**都可以通过 **TCP 协议**连接到端口 7777。IP 地址 0.0.0.0 是一个通配符，表示所有可用的网络接口。
2. 第二行输出显示了一个 **TCP6** 连接，它也在监听（LISTEN）端口 7777。`:::` 是 IPv6 的通配符地址，表示所有可用的 IPv6 网络接口。

综上所述，这两行输出表明有两个不同的监听连接，一个是通过 IPv4（tcp） 监听 0.0.0.0:7777，另一个是通过 IPv6（tcp6） 监听 :::7777。这意味着有一个正在运行的进程在这两个地址上监听 7777 端口，等待来自**其他计算机**的连接。

2.lsof

```
lsof -i :7777
```

这将列出正在使用该指定端口的进程信息，包括进程ID（PID）和进程名称。

3.ss  需要安装 `iproute2` 包

```
ss -tuln | grep 7777
```

## 查看文件或目录路径

```
find / -name <文件或目录名称>
```

## 查看docker存储路径

如果你的服务器上有 Docker 运行，请使用以下命令来查找 Docker 的存储路径：

```
docker info --format '{{.DockerRootDir}}'
```

无论 Docker 的存储路径是什么，镜像文件通常位于该路径下的子目录中。例如，在默认路径 `/var/lib/docker/` 下，镜像文件将位于 `image/overlay2` 或类似的子目录中。

## 查看镜像存储路径

```
docker inspect --format='{{.GraphDriver.Data.MergedDir}}' <镜像名称或ID>
```

## 查找容器名称

查找**正在运行**的容器的名称

```
docker ps --format "{{.Names}}"
```

所有**包括停止状态**的容器的名称，可以加上 `-a` 或 `--all` 选项：

```
docker ps -a --format "{{.Names}}"
```

## 根据容器名称查看容器信息

```
docker inspect <容器名称或容器ID>
```

## 停止正在运行的容器

```
docker ps
```

可查看容器id

```
docker stop <container_id>
```

## 删除容器

```
docker rm <container_id>
```

## 查看某个进程

```
ps -ef | grep nginx
```

## 终止进程

```
sudo kill -s TERM 进程号
```

以[超级用户]权限向进程ID为14391的进程发送[终止信号]，请求该进程正常退出。

## 删除镜像

```
docker rmi myimage:tag
```

## 重启容器

```
docker restart 4e2b35a0d417
```

## 进去容器修改文件

```
docker exec -it 容器id bash
```

## 容器日志

```
docker logs <container_id>
```



## 查看命令日志

```
history | grep 关键词
```



# webpack插件

|     plugin     |                             作用                             |
| :------------: | :----------------------------------------------------------: |
| SentryWebpack  | 集成 `Sentry` **错误日志**收集服务，`Sentry` 是一个开源的错误日志**收集和分析**服务，可以帮助开发人员更快地定位和修复错误。该插件主要用于在**生产环境**中收集应用程序的错误日志，并将其与特定的 **Git 提交**关联起来，以便更方便地进行错误分析和调试。 |
|    Workbox     | `WorkboxPlugin` 是一个用于生成 `Service Worker` 的插件，用于实现**离线缓存**和**资源预缓存**等功能。`Service Worker` 是在**浏览器**和**网络**之间运行的**脚本**，用于提供**离线访问**和**缓存资源**。该插件主要用于优化应用程序的性能和用户体验，特别是在网络不稳定或者没有网络的情况下。 |
|  Compression   | 该插件支持多种压缩算法，如 `gzip`、`brotli` 等。压缩构建**输出文件**可以有效地减小文件大小，从而提高应用程序的加载速度和性能。 |
| RetryChunkLoad | 用于重试加载 `Webpack` **拆分代码块**的插件。该插件主要用于处理**网络不稳定**或者网络超时等情况下的**代码块加载失败**问题。通过配置该插件，可以让应用程序在网络不稳定的情况下更加健壮和稳定。 |

## 使用打包进度条插件demo

创建一个新的项目**目录webpack**

1.添加**package.json**

```bash
npm init -y
```

2.安装webpack和progress-bar-webpack-plugin插件

```bash
npm install webpack webpack-cli progress-bar-webpack-plugin --save-dev
```

3.创建一个src/index.js文件

```bash
console.log("hello");
```

4.创建一个webpack.config.js文件

```js
const path = require('path');
const ProgressBarPlugin = require('progress-bar-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  plugins: [
    new ProgressBarPlugin()
  ]
};
```

5.使用**插件**打包

```bash
npx webpack --progress
```

--progress参数以**百分比**的形式显示打包进度，如果添加了插件才会以其他形式显示进度

Webpack将会编译你的项目，并在命令行中显示打包进度条。完成后，你可以在dist目录下找到生成的bundle.js文件。

## craco打包添加进度条

以下是一个简单的**示例项目**，演示如何在**React应用程序**中添加`webpackbar`插件来显示进度条。

1. 创建React应用程序

首先，你需要创建一个React应用程序。你可以使用`create-react-app`工具来快速创建一个React应用程序。在命令行中执行以下命令：

```bash
npx create-react-app my-app
cd my-app
```

2. 安装webpackbar插件

在应用程序目录中，使用以下命令安装`webpackbar`插件：

```
npm install webpackbar --save-dev
```

这个命令会将`webpackbar`插件安装到应用程序中，并将其添加到`package.json`文件的`devDependencies`部分中。

3. 修改craco配置文件

在应用程序目录中，创建一个名为`craco.config.js`的新文件，并添加以下代码：

```javascript
const WebpackBar = require('webpackbar');

module.exports = {
  plugins: [
    {
      plugin: {
        overrideWebpackConfig: ({webpackConfig, cracoConfig, pluginOptions, context: {env, paths}}) => {
          webpackConfig.plugins.push(new WebpackBar());
          return webpackConfig;
        },
      },
    },
  ],
};
```

这个配置文件使用`webpackbar`插件来显示构建进度条。在Webpack配置中添加`webpackbar`插件的代码是通过`overrideWebpackConfig`函数实现的。

4. 启动应用程序

在应用程序目录中，使用以下命令启动React应用程序：

```
npm start
```

这个命令会启动开发服务器，并在浏览器中打开React应用程序。在构建过程中，`webpackbar`插件会显示构建进度条和其他信息。

5. 构建应用程序

在应用程序目录中，使用以下命令构建React应用程序：

```
npm run build
```

这个命令会生成一个生产环境的构建，并将其输出到`build`目录中。在构建过程中，`webpackbar`插件会显示构建进度条和其他信息。

# 命令行

## 查看最新修改或新增文件

```bash
dir /O-D /T:W
```

## 查看主机ip

Windows 系统：

1. 打开命令提示符（Command Prompt）或 PowerShell。

2. 运行以下命令：

   ```
   ipconfig
   ```

   这将显示主机的网络配置信息，包括 IP 地址、子网掩码、默认网关等。在输出中找到 "IPv4 地址"，即可查看主机的 IP 地址。

Linux 系统：

1. 打开终端。

2. 运行以下命令之一：

   - 对于使用 ifconfig 命令的旧版 Linux 发行版：

     ```
   ifconfig
     ```

   - 对于使用 ip 命令的较新 Linux 发行版：
   
     ```
     ip addr show
     ```

   这将显示主机的网络接口信息，包括 IP 地址、子网掩码、广播地址等。在输出中找到与你的网络接口相关的部分，即可查看主机的 IP 地址。

请注意，在 Linux 中，你可能需要以管理员权限（使用 sudo 命令）运行上述命令才能查看完整的网络信息。

## 查看ip地址

```
ipconfig | findstr "IPv4"
```

# 技巧

系统的**临时文件**存放位置配置在非C盘，通过**环境变量**配置，当磁盘内存紧缺时可以去那里清理



## 不同系统换行符

Visual Studio Code 编辑器中，你可以按 `Ctrl + Shift + H` 打开批量替换面板，然后启用正则表达式，并使用以下搜索和替换模式：

```
\r\n -> \n
```

包含的文件

```
./b_d/app/client/src
```

这将将所有回车符替换为 Unix 风格的换行符。

本地vscode编辑器也需要在eol设置中选择lf，

团队要是使用不同系统开发，需要在git配置设置

```bash
git config --global core.autocrlf false
```

高级写法：

```bash
git ls-files -z | xargs -0 perl -i -pe 's/\r$//g'
```

修改所有文件！

## 正则替换

**给img元素添加/**

搜索

```
<img\b([^>]*)src="([^"]*)"([^>]*)>
```

替换

```
<img$1src="$2"$3 />
```

可以将没有/的img替换成有/

比如

```
<img src="../.gitbook/assets/image (5).png" alt="">
```

替换成

```
<img src="../.gitbook/assets/image (5).png" alt="" />
```

**删除文件名间的空格**

```
| 需求描述                                              | 需求描述/展示                                                                                            | 参与者 |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------- | --- |
| Mysql数据源汉化翻译                                      | ![](</img/image (13) (3).png>)                                                    |     |
| Elasticsearch数据源汉化翻译                              | ![](</img/image (39).png>)                                                        |     |
| redis数据源汉化翻译                                      | ![](</img/image (18) (1) (2).png>)                                                |     |
| DynamoDB数据源汉化翻译                                   | ![](</img/image (37).png>)                                                        |     |
| Microsoft SQL Server数据源汉化翻译                       | ![](</img/image (16) (4).png>)                                                    |     |
| Firestore数据源汉化翻译                                  | ![](</img/image (28) (1) (3).png>)                                                |     |
| Redshift数据源汉化翻译                                   | ![](</img/image (3) (1) (4).png>)                                                 |     |
| S3数据源汉化翻译                                         | ![](</img/image (20) (4).png>)                                                    |     |
| Snowflake数据源汉化翻译                                  | ![](</img/image (44).png>)                                                        |     |
| ArangoDB数据源汉化翻译                                   | ![](</img/image (14) (5).png>)                                                    |     |
| SMTP数据源汉化翻译                                       | ![](</img/image (9) (1) (1).png>)                                                 |     |
| 发布页面后，在 table 单元格中使用 select 组件，进入编辑状态时，下拉框位置定位不正确 | [https://github.com/cloudtogo/pageplug/issues/22](https://github.com/cloudtogo/pageplug/issues/22) |     |
```

```
原始文本
(</img/image (39).png
查找表达式
\((<\/img\/image) \((\d+)\)(\.png)
替换表达式
($1($2)$3
原始文本
(</img/image (13) (3).png
查找表达式
\((<\/img\/image) \((\d+)\) \((\d+)\)*(\.png)
替换表达式
($1($2)($3)$4
原始文本
(</img/image (18) (1) (2).png
查找表达式
\((<\/img\/image) \((\d+)\) \((\d+)\) \((\d+)\)(\.png)
替换表达式
($1($2)($3)($4)$5
```



# yarn

## 查看当前的镜像源：

```
yarn config get registry
```

## 修改为淘宝镜像源：

```
yarn config set registry http://registry.npm.taobao.org
```

## 查看有效配置：

```
yarn config -v
```

## 疑问

**1.为什么执行 `yarn add xxx` 也会有project valid、resolution、fetch、link这些step？**

Yarn 包管理器会执行一系列步骤来确保顺利安装所需的包，并处理依赖关系。以下是这些步骤的简要说明：

1. **Project Validation（项目验证）**：Yarn 首先会验证项目根目录下的 `package.json` 文件，并检查是否存在有效的项目配置。这个步骤是为了确保你在正确的项目目录下执行命令，并且项目配置正确。
2. **Resolution（依赖解析）**：Yarn 接下来会解析你要安装的包（例如 `xxx`）及其版本号，并确定所需的依赖关系。它会检查项目的 `yarn.lock` 文件（如果存在）以获取准确的依赖版本，并确保解析的依赖关系与当前项目的其他部分兼容。
3. **Fetch（依赖下载）**：一旦依赖解析完成，Yarn 将开始从网络上下载所需的包及其依赖项。它会检查本地缓存，如果已经下载过这些包，就会直接使用缓存，否则会从远程仓库下载它们。
4. **Link（依赖链接）**：在下载完成后，Yarn 会将这些包链接到项目的 `node_modules` 目录中。这意味着它会在正确的位置创建符号链接，以使这些包可以被项目的其他部分引用。

这些步骤的目的是确保包的正确安装，并处理依赖关系以避免冲突或版本不兼容的问题。此外，执行这些步骤还可以提高包的安装速度，因为它们允许 Yarn 在安装过程中利用缓存和链接的特性。

# node

## nrm

- `nrm ls`：列出当前可用的注册表。
- `nrm use <registry>`：切换到指定的注册表。
- `nrm add <registry> <url>`：添加一个自定义的注册表。
- `nrm del <registry>`：删除指定的注册表。

nrm 是一个用于管理 Node.js 包管理器（如 npm 和 Yarn）的注册表（registry）的工具。

## nvm

**node version manger**

查询当前已安装

```
nvm list
```

下载指定版本

```
nvm install xxx
```

使用指定版本

```
nvm use xxx
```



# package.json

## 格式化脚本

```json
"prettify": "prettier --write \"src/**/*.ts\" \"src/**/*.tsx\" \"src/**/*.js\""
```

自动格式化 `src` 目录下的所有 `.ts`、`.tsx` 和 `.js` 文件

# lodash

## **sortedByUniqBy**

排除了经过**迭代函数**处理后相等的相邻元素，同时保留第一个出现的元素。该方法会先对数组进行排序，然后再进行处理。

```js
const ff = [{label: 'aaa',value: 'A'},{label: 'aaa1',value: 'A'},{label: 'bbb',value: 'B'}]
_.sortedUniqBy(ff, (i) => i.value)
// 返回
{label: 'aaa', value: 'A'}
{label: 'bbb', value: 'B'}
```

对于下拉菜单的**options**，**value要唯一**；

对于不唯一的数据，有三种思路处理：

- 数据库去重；
- 后端去重；
- 前端去重；



# nginx

## conf中定义变量

```bash
server {
    listen 80;
    server_name dev.appsmith.com;
    return 301 https://$host$request_uri;
}

server {
    listen 3600;
    location / {
        proxy_pass http://localhost:80;
    }
    return 301 https://$host$request_uri;
}

server {
	set $backend_url "http://10.10.14.135:8080";
	
    listen 443 ssl http2;
    server_name dev.appsmith.com;
    client_max_body_size 100m;

	# 证书跟本配置文件，均放在conf.d目录下
    ssl_certificate conf.d/dev.appsmith.com.pem;
    ssl_certificate_key conf.d/dev.appsmith.com-key.pem;

    # include /etc/letsencrypt/options-ssl-nginx.conf;
    # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    gzip on;

    proxy_ssl_server_name on;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header Accept-Encoding "";

    sub_filter_once off;
	
	# 前端服务
    location / {
        proxy_pass http://localhost:3000;
		# sub_filter __BMAP_AK__ '';
        # sub_filter __APPSMITH_BMAP_AK__ '';
    }

    location /favicon.ico {
        proxy_pass http://localhost:3000/favicon.ico;
    }

    location /f {
       proxy_pass https://cdn.optimizely.com/;
    }

	# 后端服务
    location /api {
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_pass $backend_url;
    }
	
	# 后端服务
    location /oauth2 {
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_pass $backend_url;
    }

	# 后端服务
    location /login {
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_pass $backend_url;
    }
}


```

## 域名转发

**步骤 1：安装 Nginx**

首先，确保你已经安装了 Nginx。如果没有安装，可以使用适用于你的操作系统的包管理工具进行安装。例如，在 Ubuntu 上可以使用以下命令：

```
sudo apt update
sudo apt install nginx
```

**步骤 2：获取 SSL 证书**

要启用 HTTPS，你需要获取一个有效的 SSL 证书。你可以从证书颁发机构（CA）购买，也可以使用免费的证书颁发机构（如 Let's Encrypt）获取证书。

如果你使用 Let's Encrypt，可以按照以下步骤安装 Certbot 工具并获取证书：

1. 安装 Certbot：

   ```
   sudo apt install certbot python3-certbot-nginx
   ```
   
2. 获取证书（假设你的域名是 example.com）：

   ```
   sudo certbot --nginx -d example.com -d www.example.com
   ```

**步骤 3：配置 Nginx 支持 HTTPS**

1. 打开 Nginx 的站点配置文件，通常位于 `/etc/nginx/` 目录下。选择你想配置 HTTPS 的站点，并编辑配置文件：

   ```
   sudo nano /etc/nginx/sites-available/your_site_config_file
   ```
   
2. 在配置文件中添加以下内容，以启用 HTTPS：

   ```nginx
server {
       listen 80;
       server_name example.com www.example.com;
   
       # Redirect HTTP to HTTPS
       return 301 https://$host$request_uri;
   }
   
   server {
       listen 443 ssl;
       server_name example.com www.example.com;
   
       ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
       ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
   
       # SSL settings
       ssl_protocols TLSv1.2 TLSv1.3;
       ssl_prefer_server_ciphers off;
   
       location / {
           # Your other server configuration directives
       }
   }
   ```
   
   注意替换 `example.com` 和配置文件的路径，确保 ssl_certificate 和 ssl_certificate_key 的路径正确指向你的 SSL 证书。

3. 保存并关闭文件。

**步骤 4：测试配置并重新加载 Nginx**

1. 检查 Nginx 配置是否正确：

   ```
   sudo nginx -t
   ```
   
2. 如果没有错误，重新加载 Nginx 配置：

   ```
   sudo systemctl reload nginx
   ```

**步骤 5：设置自动续签**

Let's Encrypt 证书的有效期为 90 天。为了避免证书过期，你可以设置自动续签。可以创建一个 cron 作业来定期续签证书。

编辑 crontab 文件：

```
sudo crontab -e
```

在文件末尾添加以下行（每天凌晨续签）：

```
0 0 * * * /usr/bin/certbot renew --quiet
```

保存并关闭文件。

## 防火墙规则查看

```
sudo iptables -L
```

## 查看端口已经被占用

```
sudo netstat -tuln | grep 81
```

## 杀死所有nginx进程

```
sudo pkill nginx
```



## 报错

想重启nginx

执行`nignx -s stop`时

1.nginx: [error] invalid PID number "" in "/run/nginx.pid"

nginx -s reload 仅用于告诉正在运行的 nginx 进程重新加载其配置。停止后，没有正在运行的 nginx 进程来发送信号。只需运行nginx（可能使用-c /path/to/config/file）

2.执行`sudo systemctl reload nginx`日志

```bash
Failed to reload nginx.service: Connection timed out
See system logs and 'systemctl status nginx.service' for details.
```

可并不是是用systemctl管理nginx的，可以试试
`nginx -s reload`

# 样式积累

## 子元素写>与不写的区别

```css
li>a
```

表示li的直接子元素a

```css
li a
```

表示li的**间距**子元素（有可能是子孙）

## flex控制顺序

**order**，数字越小越靠前；

## hint效果

```css
.hint {
  background-color: #f5f7f9;
  border-radius: 4px;
  border: 1px solid #dcdcdc;
  border-left: 4px solid #346ddb;
  padding: 20px;
  margin: 10px 0;
}
```

使用

```html
<div class="hint" markdown="1">

</div>
```

## 白天/黑夜模式切换，匹配内容不同样式

**方案一**

两种文件，监听切换事件，切换link的href

假设是react

```jsx
import React, { useState } from 'react';

const ExamplePage = () => {
  const [isDarkMode, setIsDarkMode] = useState(false);

  const handleModeChange = () => {
    setIsDarkMode(!isDarkMode);
    const themeLink = document.getElementById('theme-link');
    themeLink.href = isDarkMode ? '/path/to/light.css' : '/path/to/dark.css';
  };

  return (
    <div>
      <h1>Example Page</h1>
      <button onClick={handleModeChange}>
        {isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
      </button>
    </div>
  );
};

export default ExamplePage;
```

使用了 React 的 `useState` 钩子来管理当前的模式状态，初始状态为白天模式（`isDarkMode` 为 `false`）；

`handleModeChange` 函数会在按钮点击时触发，它会根据当前模式状态切换到相应的模式，并更新样式文件的链接。

接下来，你需要在你的项目中的某个布局文件（比如说是 `src/theme/Layout.js`）中添加以下代码，以引入样式文件：

```jsx
import React from 'react';

const Layout = () => {
  return (
    <div>
      <head>
        <link id="theme-link" rel="stylesheet" href="/path/to/light.css" />
      </head>
      {/* 布局的其他内容 */}
    </div>
  );
};

export default Layout;
```

在上述代码中，我们在 `<head>` 元素中添加了一个带有 `id` 为 `"theme-link"` 的链接标签，初始时它的 `href` 属性指向白天模式的样式文件。

现在，当你在浏览器中打开该示例页面时，你会看到一个标题和一个切换模式的按钮。点击按钮时，样式文件的链接将会根据当前模式状态切换。

需要将 `/path/to/light.css` 和 `/path/to/dark.css` 替换为实际的样式文件路径。

**方案二**

使用html的属性切换（data-theme）

这是light模式下

```css
.hint {
  background-color: #f5f7f9;
  border-radius: 4px;
  border: 1px solid #dcdcdc;
  border-left: 4px solid #346ddb;
  padding: 20px;
  margin: 10px 0;
}
```

这是dark模式

```
html[data-theme='dark'] .hint {
  background-color: #a1bba8;
  border-radius: 4px;
  border: 1px solid #dcdcdc;
  border-left: 4px solid #346ddb;
  padding: 20px;
  margin: 10px 0;
}
```

## 修改滚动条背景

```css
::-webkit-scrollbar-track: transparent;
```

## 样式文件

- 如果在元素里找不到应该出现的类，那很有可能没有导入样式文件；

## 背景图

1. **JPEG（.jpg）**:
   - 适用于照片和图像，特别是具有丰富颜色和渐变的图像。
   - 支持压缩，可以减小文件大小，但可能会降低图像质量。
   - 不支持透明度。适用于不需要透明背景的情况。
2. **PNG（.png）**:
   - 适用于具有透明度（透明背景）需求的图像，如图标和图形。
   - 支持无损压缩，图像质量不会受损。
   - 文件大小通常较大，对于复杂的图像可能不是最佳选择。
3. **GIF（.gif）**:
   - 适用于简单的动画和图像，如小图标和动画徽标。
   - 支持透明度和动画。
   - 文件大小相对较小，但色彩深度有限。
4. **WebP（.webp）**:
   - 一种现代的图像格式，支持无损和有损压缩。
   - 通常提供较小的文件大小和较好的图像质量。
   - 适用于网页性能优化。
5. **SVG（.svg）**:
   - 适用于矢量图形，如图标和简单的图形，而不是照片。
   - 可无限缩放而不失真，因为它们是基于矢量的。
   - 通常是文本文件，因此文件大小较小。

当选择背景图像格式时，考虑图像的内容、质量需求和性能要求。对于照片背景，JPEG通常是一个不错的选择。对于需要透明度的图像，PNG可能更合适。对于图标和图形，SVG或WebP可能是更好的选择，以提供较小的文件大小和高质量。根据您的具体需求，您还可以选择其他格式。

# window

## 滚动到顶部--整个页面的顶部

```html
<!DOCTYPE html>
<html lang="ch-ZN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js实现页面滚动返回顶部</title>
  <style>
    * {
      padding: 0px;
      margin: 0px;
    }

    div {
      width: 1200px;
      height: 300px;
      margin: 50px auto;
      font-size: 120px;
      line-height: 300px;
      text-align: center;
      color: #ffffff;
      background-color: #999999;
    }

    button {
      position: fixed;
      bottom: 40px;
      right: 40px;
      width: 60px;
      height: 60px;
      border: 0px;
      border-radius: 10px;
      font-size: 24px;
      line-height: 30px;
      text-align: center;
      color: #000;
      background-color: #c5e4ff;
      outline: none;
      cursor: pointer;
    }

    button:hover {
      color: #fff;
      background-color: #5fb4ff;
    }
  </style>
</head>

<body>
  <div>模块1</div>
  <div>模块2</div>
  <div>模块3</div>
  <div>模块4</div>
  <div>模块5</div>
  <div>模块6</div>
  <div>模块7</div>
  <div>模块8</div>
  <div>模块9</div>
  <button>返回顶部</button>
  <script>
    var btn = document.querySelector('button'); // 获取元素
    var timer; // 用来储存计时器的变量
    btn.addEventListener('click', function () {
      clearInterval(timer); // 先停止上次的计时器（防止连点）
      timer = setInterval(function () {
        // 判断是否已经滚动到了顶部
        if (window.pageYOffset != 0) {
          // 如果没到顶部就再移动一点距离（我这里是一次移动了50像素）
          window.scroll(0, Math.max(window.pageYOffset - 50, 0));
        } else {
          // 如果到顶部了就停止计时器
          clearInterval(timer);
        }
      }, 10);
    })
  </script>
</body>

</html>

```

## 滚动到顶部--容器内

```js
function toTop() {
  var sidebar = document.querySelector('.sidebar-nav');
  var content = document.querySelector('.markdown-section');

  sidebar.addEventListener('click', function () {
    content.scroll(0, -content.scrollHeight)
  });
}
```

## 打开新窗口

```ts
const features =
        "height=400,width=300,left=100,top=100,status=yes,toolbar=no,menubar=no,location=no";
      const newWindow: any = window.open(url, "_blank", features);
      newWindow.opener = null; // 设置新窗口的 opener 为 null，使其半开状态
      newWindow.focus();
```

# git

## 修改remote

先用

```
git remote -v
```

检查下现有的远程出库地址

确认之后修改

```
git remote set-url origin https://gitee.com/zhai-sifeng/docs.git
```

## 删除

```
git remote rm origin
```

# md语法

```
[desc](url) 链接
[https://blog.csdn.net](https://blog.csdn.net)这样可以显示该站点预览信息
> 左边涂料，类似hint效果

```





# 网络

## 域名对应的ip

想知道域名映射的ip

ping一下，

比如

```
ping docs.pageplug.cn
```

输出结果就可以看到了

## 代理

执行 netstat 可以显示本地地址和端口、外部地址和端口、协议、状态：

```
C:\Users\86131>netstat

活动连接


  协议  本地地址          外部地址        状态
  TCP    127.0.0.1:49956        dev:49957              ESTABLISHED
  TCP    127.0.0.1:49957        dev:49956              ESTABLISHED
  TCP    192.168.110.198:54126  113.219.178.241:https  CLOSE_WAIT
  TCP    192.168.110.198:62264  203.119.145.218:https  ESTABLISHED
  TCP    192.168.110.198:62271  20.198.162.76:https    ESTABLISHED
  TCP    192.168.110.198:62314  183.60.15.170:https    ESTABLISHED
  TCP    192.168.110.198:63694  203.107.1.1:http       CLOSE_WAIT
  TCP    192.168.110.198:63695  123.182.51.64:https    CLOSE_WAIT
  TCP    192.168.110.198:64726  49.79.227.161:https    TIME_WAIT
  TCP    192.168.110.198:64729  182.247.225.49:https   ESTABLISHED
  TCP    192.168.110.198:64731  183.47.103.43:36688    TIME_WAIT
  TCP    192.168.110.198:64732  202.89.233.96:https    TIME_WAIT
  TCP    192.168.110.198:64734  144.123.124.3:https    TIME_WAIT
  TCP    192.168.110.198:64735  144.123.124.3:https    TIME_WAIT
  TCP    192.168.110.198:64736  144.123.124.3:https    TIME_WAIT
  TCP    192.168.110.198:64737  144.123.124.3:https    TIME_WAIT
  TCP    192.168.110.198:64738  144.123.124.3:https    TIME_WAIT
  TCP    192.168.110.198:64739  14.116.192.195:44001   ESTABLISHED
  TCP    192.168.110.198:64743  14.116.192.195:44001   ESTABLISHED
  TCP    192.168.110.198:64744  183.60.15.198:https    TIME_WAIT
  TCP    192.168.110.198:64745  180.163.210.217:8081   TIME_WAIT
```

## 回环地址

0.0.0.0

要想通过ip访问下另一台计算机运行的项目，需要那台机器运行时指定host为0.0.0.0

```
yarn start --host 0.0.0.0
```



# React

## React.createRef()

## useImperativeHandle()

## useLocation()

## React.lazy

## style-component

```tsx
export const TreeSelectContainer = styled.div<{
  allowClear?: boolean;
  compactMode: boolean;
  isValid: boolean;
  labelPosition?: LabelPosition;
  borderRadius: string;
  boxShadow?: string;
  accentColor: string;
}>`

样式规则
`
```

`styled` 函数接受一个参数，该参数是一个对象字面量，用于定义组件的样式规则；

上述几个变量是可以在css使用的props；

以下是一个示例，展示如何使用这个样式化的组件：

```tsx
import React from 'react';
import { TreeSelectContainer } from './TreeSelectContainer';

const MyComponent = () => {
  return (
    <TreeSelectContainer
      allowClear={true}
      compactMode={false}
      isValid={true}
      labelPosition="left"
      borderRadius="4px"
      boxShadow="0 2px 4px rgba(0, 0, 0, 0.1)"
      accentColor="#ff0000"
    >
      {/* 组件的内容 */}
    </TreeSelectContainer>
  );
};

export default MyComponent;
```

## react中使用svg

- import导入
- 组件导入

导入 SVG 文件并在 React 组件中使用时，SVG 文件内容通常会被解析为一个字符串，而不是直接渲染为图像。这是因为在 React 中，SVG 文件通常被视为一种特殊的 XML 数据，而不是普通的图像。

**使用 `import` 导入 SVG 文件**

导入 SVG 文件并将其分配给一个变量，就像正常导入其他模块一样：

```ts
import React from 'react';
import mySvg from './my-svg-file.svg';

function MyComponent() {
  return (
    <div>
      {/* 使用导入的 SVG 文件 */}
      <img src={mySvg} alt="My SVG" />
    </div>
  );
}

export default MyComponent;

```

**将 SVG 作为组件使用：** 还可以将 SVG 文件作为 React 组件使用，而不是将其直接呈现为图像。为此，需要将 SVG 文件的内容包装在一个组件中，然后在应用程序中使用该组件。这可以更灵活地操作 SVG 内容。以下是一个示例：

```ts
javascriptCopy codeimport React from 'react';
import MySvgComponent from './MySvgComponent';

function MyComponent() {
  return (
    <div>
      {/* 使用 SVG 组件 */}
      <MySvgComponent />
    </div>
  );
}

export default MyComponent;
```

**注意：svg当组件时记得将有连接符-的属性换成驼峰**

# TS

```tsx
class SingleSelectTreeWidget extends BaseWidget<
SingleSelectTreeWidgetProps,
WidgetState>
```

这段代码是 TypeScript 中的类定义，它定义了一个名为 `SingleSelectTreeWidget` 的类，该类继承自 `BaseWidget` 并接受两个**泛型参数：**`SingleSelectTreeWidgetProps` 和 `WidgetState`;

- `BaseWidget`：这是 `SingleSelectTreeWidget` 类的父类或基类，通过 `extends` 关键字将其作为父类进行继承。继承允许子类继承父类的属性和方法，并且可以在子类中添加自己的属性和方法，或者覆盖父类的属性和方法。
- `SingleSelectTreeWidgetProps`：这是一个泛型参数，用于指定 `SingleSelectTreeWidget` 类接受的属性的类型。泛型参数允许在类或函数**定义中**使用**不具体**指定类型的占位符，以便在实际**使用时**指定**具体**类型。
- `WidgetState`：这是另一个泛型参数，用于指定 `SingleSelectTreeWidget` 类的状态的类型。状态通常用于存储组件内部的数据，并在组件渲染和交互过程中进行管理和更新。

通过使用泛型参数，`SingleSelectTreeWidget` 类可以在实例化时指定具体的属性和状态类型，以符合特定的需求和使用场景。这样可以增加代码的可复用性和类型安全性，同时提供更好的开发和维护体验。

**举例**

```ts
class Container<T> {
  private value: T;

  constructor(initialValue: T) {
    this.value = initialValue;
  }

  getValue(): T {
    return this.value;
  }

  setValue(newValue: T): void {
    this.value = newValue;
  }
}
```

- `Container` 类有一个私有属性 `value`，其类型是泛型参数 `T`。这意味着 `value` 可以是任意类型，具体的类型由在实例化时传入的参数决定。
- 构造函数 `constructor` 接受一个初始值 `initialValue`，类型为 `T`，并将其赋值给 `value` 属性。
- `getValue` 方法返回 `value` 属性的值，类型为 `T`。
- `setValue` 方法接受一个新值 `newValue`，类型为 `T`，并将 `value` 属性更新为新值。

```ts
const numberContainer = new Container<number>(10);
console.log(numberContainer.getValue()); // 输出：10
numberContainer.setValue(20);
console.log(numberContainer.getValue()); // 输出：20

const stringContainer = new Container<string>("Hello");
console.log(stringContainer.getValue()); // 输出：Hello
stringContainer.setValue("World");
console.log(stringContainer.getValue()); // 输出：World
```

在这个示例中，我们首先创建了一个 `Container` 实例 `numberContainer`，并指定泛型参数为 `number`。然后，我们使用 `getValue` 方法打印出初始值。接着，我们使用 `setValue` 方法将值更新为 20，并再次打印出新值。

类似地，我们还创建了一个 `Container` 实例 `stringContainer`，并指定泛型参数为 `string`，然后进行相应的操作。

```ts
export interface TreeSelectProps
extends Required<
Pick<
SelectProps,
"disabled" | "placeholder" | "loading" | "dropdownStyle" | "allowClear"
>
```

- `Required<T>` 是 TypeScript 中的类型操作符，用于将接口或类型 `T` 中的所有属性标记为必需属性，即不能为 `undefined` 或 `null`。
- `Pick<SelectProps, "disabled" | "placeholder" | "loading" | "dropdownStyle" | "allowClear">` 表示从 `SelectProps` 接口中选择特定的属性，形成一个新的类型。在这里，我们选择了 `"disabled"`、`"placeholder"`、`"loading"`、`"dropdownStyle"` 和 `"allowClear"` 这些属性。

# Redux

```ts
[ReduxActionTypes.SAVE_ADMIN_SETTINGS]: (state: SettingsReduxState) => ({
    ...state,
    isSaving: true,
  })
```

**对象字面量**中，`[ReduxActionTypes.SAVE_ADMIN_SETTINGS]` 是一个**属性**名，它是一个Redux的动作类型（action type）。这个属性名使用了方括号括起来的写法，这是一种动态地使用变量或表达式作为属性名的方式。

## **如何确定函数调用顺序？**

- debugger
- 性能分析器
- 调用栈

## Redux Saga

# 业务

## 上传文件

前端负责文件选择、验证和发送请求，后端负责接收、验证和处理文件。

**前端：**

```html
<!DOCTYPE html>
<html>

<head>
  <title>文件上传示例</title>
</head>

<body>
  <h1>文件上传</h1>
  <form id="uploadForm" enctype="multipart/form-data">
    <input type="file" id="fileInput" name="file" />
    <button type="submit">上传</button>
  </form>

  <script>
    const form = document.getElementById('uploadForm');
    const fileInput = document.getElementById('fileInput');

    form.addEventListener('submit', (e) => {
      e.preventDefault(); // 阻止表单默认提交行为

      const files = fileInput.files;
      if (files.length === 0) {
        alert('请选择要上传的文件！');
        return;
      }

      const file = files[0];
      const formData = new FormData();
      formData.append('file', file);

      // 发送文件上传请求到服务器
      const xhr = new XMLHttpRequest();
      xhr.open('POST', 'http://localhost:8000/upload', true);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          // 文件上传成功
          alert('文件上传成功！');
        } else if (xhr.readyState === 4 && xhr.status !== 200) {
          // 文件上传失败
          alert('文件上传失败！');
        }
      };
      xhr.send(formData);
    });
  </script>
</body>

</html>

```

**后端：**

```js
const express = require('express');
const multer = require('multer');

const app = express();
const upload = multer({ dest: 'uploads/' }); // 指定上传文件的存储目录

// 添加允许跨域请求的响应头
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

// 处理单个文件上传的路由
app.post('/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).send('No file uploaded.');
  }

  // 文件上传成功，可以在这里对文件进行进一步处理或保存到数据库
  res.send('File uploaded!');
});

// 启动服务器
app.listen(8000, () => {
  console.log('Server is running on port 8000');
});

```

## oidc单点登录

### 使用keycloak验证oidc登录流程及原理解析

### 过程

使用 [keycloak平台](https://www.keycloak.org/getting-started/getting-started-docker)

#### 1.拉取并运行keycloak提供的镜像

```
docker run -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:22.0.3 start-dev
```

*注意端口号别和后端冲突*，

启动容器之后就可以访问 [keycloak控制台 ](http://localhost:8080/admin) 了

#### 2.创建realm

填写**name，创建**

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-25-57.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-25-57.png?version=1&modificationDate=1695281133256&api=v2)

#### 3.创建user

填写用户名，创建

账号：user3

密码： 123456

这里的邮箱，对应的是你在Pageplug邮箱账号，比如，你使用这个账号密码第三方登录验证通过后，登录Pageplug的邮箱账号是123@qq.com

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_16-59-37.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_16-59-37.png?version=1&modificationDate=1695286753455&api=v2)

创建之后可以在**Credentials**设置密码；**Temporary**设置关闭

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-29-5.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-29-5.png?version=1&modificationDate=1695281321576&api=v2)

#### 4.创建client 

client id：client3

client secret： 123456

返回 [管理员后台](http://localhost:8080/admin)，切换刚刚创建的realm（默认新建时就会切换了）

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-30-48.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-30-48.png?version=1&modificationDate=1695281424299&api=v2)

创建client,填写**client id**，**client type**选择OpenID Connect

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-31-43.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-31-43.png?version=1&modificationDate=1695281479476&api=v2)

**Standard flow**设置打开

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-35-51.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-35-51.png?version=1&modificationDate=1695281727859&api=v2)

设置**回调url**和**域名**，回调url复制Pageplug中提供的

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-41-5.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-41-5.png?version=1&modificationDate=1695282041801&api=v2)

#### 5.在Pageplug中填写配置

点击 **realm settings**，打开 [OpenID Endpoint Configuration](http://localhost:8080/realms/pageplug/.well-known/openid-configuration)

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-45-1.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-45-1.png?version=1&modificationDate=1695282277847&api=v2)

根据对应信息对号入座

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-44-37.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-44-37.png?version=1&modificationDate=1695282253026&api=v2)

信息清单

```
Client ID：client3
Client Secret：123456
Authorization URL：http://localhost:8081/realms/pageplug2/protocol/openid-connect/auth
Token URL：http://localhost:8081/realms/pageplug2/protocol/openid-connect/token
User Info URL：http://localhost:8081/realms/pageplug3/protocol/openid-connect/userinfo
JWK Set URL：http://localhost:8081/realms/pageplug3/protocol/openid-connect/certs
Logout URL：http://localhost:8081/realms/pageplug3/protocol/openid-connect/logout
Scope：openid 
Username Attribute：email 
```



#### 6.测试oidc单点登录

保存重启，右上角头像退出登录

在登录页点击oidc登录

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_15-47-31.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_15-47-31.png?version=1&modificationDate=1695282427457&api=v2)

填写第3步创建的user账号密码

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_20-39-14.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_20-39-14.png?version=1&modificationDate=1695299929471&api=v2)

登录成功会重定向到首页

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_16-9-36.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_16-9-36.png?version=1&modificationDate=1695283752008&api=v2)

### 原理解析

1.进入oidc单点登录

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-3-15.png](http://docs.cloudtogo.local/download/thumbnails/105644499/image2023-9-21_17-3-15.png?version=1&modificationDate=1695286970807&api=v2)

会跳转至*https://dev.appsmith.com/oauth2/authorization/oidc，这是Pageplug写的一个接口*

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-8-0.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-8-0.png?version=1&modificationDate=1695287255725&api=v2)

根据该接口返回的响应字段location可知：会重定向到 

http://localhost:8081/realms/pageplug3/protocol/openid-connect/auth

也就是配置信息中的 **Authorization URL**，并且，带上了以下参数：

- response_type
- client_id
- scope
- state
- redirect_uri
- nonce

查看下一个请求也可以看出
![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-16-4.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-16-4.png?version=1&modificationDate=1695287739939&api=v2)
这些参数有什么作用呢？

**response_type**：表示客户端应用向身份提供者认证用户的身份时，期望的响应类型，响应类型有code、token、id token;

**client_id：**用户在身份提供者那里可以有很多客户端应用（Pageplug只是其中之一），用来标识应用；

**scope：**指定请求的范围或权限，范围是openid表示请求是OIDC请求，还有profile、email等用于请求用户个人信息；

**state：**客户端应用（Pageplug）生成的随机字符串，在响应中可以验证其一致性，确保请求的完整性，防止token被篡改；

**redirect_uri**：身份提供者（keycloak）认证完之后，返回的地址；

**nonce：**客户端应用（Pageplug）生成的随机值，类似state，收到id token时验证其一致性，防止id token被篡改；


2.填入user的账号密码，登录
![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-18-56.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-18-56.png?version=1&modificationDate=1695287912274&api=v2)

这时会跳转至 *http://localhost:8081/realms/pageplug3/login-actions/authenticate，*这是身份提供者（keycloak）提供的一个接口，验证用户的身份
![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-27-5.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-27-5.png?version=1&modificationDate=1695288400917&api=v2)

会带上以下参数：

- session_code
- execution
- client_id
- tab_id
- username
- password

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-37-13.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-37-13.png?version=1&modificationDate=1695289009423&api=v2)

根据该接口返回的响应字段location可知：会重定向到 

https://dev.appsmith.com/login/oauth2/code/oidc

也就是配置信息中的**Redirect URL，**并且带上以下参数：

- state
- session_state
- code

从下一个请求可以看出：

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-51-40.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-51-40.png?version=2&modificationDate=1695299787429&api=v2)

这三个参数是上一个请求（*http://localhost:8081/realms/pageplug3/login-actions/authenticate*）响应返回的，**state**没变，表示请求没被更改；

**code**是用户经过身份提供者（keycloak）认证成功之后返回的，用于后续客户端应用（Pageplug）从身份提供者那里获取用户的token，进而获取用户的其他信息；

而**session_state**就很关键了：它是由身份提供者（keycloak）生成和维护的，每当用户通过身份提供者登录认证或者与身份提供者进行其他交互的时，身份提供者将生成一个新的session_state值。客户端应用（Pageplug）可以在每个认证请求中将session_state传递给身份提供者，并在响应中检查它，这样使得客户端应用可以了解用户的会话状态是否处于活动状态；

同时，通过比较不同认证请求中的**session_state**值，客户端应用可以检测用户是否已经通过**单点登录**进行了认证。如果session_state值在不同认证请求之间保持不变，那么用户可能已经登录并且会话处于活动状态。这允许客户端应用为已认证的用户提供**访问权限**，而无需用户重新登录；

还有，session_state还可以防止**会话劫持**。通过将session_state与token一起传递给客户端应用程序，并在每个认证请求中验证它，客户端应用可以确保用户的会话没有被劫持或篡改。


最后，用户身份认证成功，会重定向到 /application

![PagePlug > OIDC单点登录流程及原理解析 > image2023-9-21_17-55-10.png](http://docs.cloudtogo.local/download/attachments/105644499/image2023-9-21_17-55-10.png?version=1&modificationDate=1695290086516&api=v2)

那先前配置的**Token URL、UserInfo URL、JWK Set URL、Logout URL**有何作用呢？

当客户端应用（Pageplug）获取到上述的code时，可以去Token URL向身份提供者（keycloak）请求用户的Token，而拿到用户的Token之后，就可以去UserInfo URL请求用户的更多信息；

而JWK Set URL是客户端应用（Pageplug）向身份提供者（keycloak）发起解析和检查Token是否正确、是否被篡改请求的；

而Logout URL是客户端应用告知身份提供者将用户的会话状态取消活动的；

### 总结

这个过程，有三个角色：

- 用户
- 实现单点登录的客户端应用
- 身份提供者

这个例子中，

实现oidc单点登录的**客户端应用**是Pageplug；
身份提供者是keycloak平台；

简言之就是：用户想使用身份提供者给的身份，进入实现了单点登录的客户端应用。

类似的，微信扫码登录也大差不差，找出三个角色，过程基本一样。

### 参考链接

https://www.keycloak.org/getting-started/getting-started-docker

## 修改昵称

**前端**

1.**dispatch**(action), action: {ReduxActionTypes.UPDATE_USER_DETAILS_INIT, name}

2.**userSagas**()下的**takelatest**(ReduxActionTypes.UPDATE_USER_DETAILS_INIT,updateUserDetailsSaga)

3.**updateUserDetailsSaga**: **callAPI**(UserApi.**updateUser**, {email, name, role, useCase})、**validateResponse**(response)、**put**(ReduxActionTypes.UPDATE_USER_DETAILS_SUCCESS, response.data)

**callAPI**

```ts
export function* callAPI(apiCall: any, requestPayload: any) {
  try {
    const response: ApiResponse = yield call(apiCall, requestPayload);
    return response;
  } catch (error) {
    return error;
  }
}
```

**validateResponse**

```ts
export function* validateResponse(
  response: ApiResponse | any,
  show = true,
  logToSentry = false,
) {
  if (!response) {
    throw Error("");
  }

  // letting `apiFailureResponseInterceptor` handle it this case
  if (response?.code === axiosConnectionAbortedCode) {
    return false;
  }

  if (!response.responseMeta && !response.status) {
    throw Error(getErrorMessage(0));
  }

  if (!response.responseMeta && response.status) {
    throw Error(getErrorMessage(response.status, response.resourceType));
  }

  if (response.responseMeta.success) {
    return true;
  }

  if (
    SERVER_ERROR_CODES.INCORRECT_BINDING_LIST_OF_WIDGET.includes(
      response.responseMeta.error.code,
    )
  ) {
    throw new IncorrectBindingError(response.responseMeta.error.message);
  }

  yield put({
    type: ReduxActionErrorTypes.API_ERROR,
    payload: {
      error: response.responseMeta.error,
      logToSentry,
      show,
    },
  });
  throw Error(response.responseMeta.error.message);
}
```

**updateUser**

```ts
static updateUser(request: UpdateUserRequest): AxiosPromise<ApiResponse> {
    return Api.put(UserApi.usersURL, request);
  }
```

**Api.put**

```ts
static put(
    url: string,
    body?: any,
    queryParams?: any,
    config: AxiosRequestConfig = {},
  ) {
    return axiosInstance.put(
      url + convertObjectToQueryParams(queryParams),
      body,
      {
        ...apiRequestConfig,
        ...config,
      },
    );
  }
```

**convertObjectToQueryParams**

```ts
import _ from "lodash";
export function convertObjectToQueryParams(object: any): string {
  if (!_.isNil(object)) {
    const paramArray: string[] = _.map(_.keys(object), (key) => {
      return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
    });
    return "?" + _.join(paramArray, "&");
  } else {
    return "";
  }
}
```

**apiRequestConfig**

```ts
export const apiRequestConfig = {
  baseURL: "/api/",
  timeout: REQUEST_TIMEOUT_MS,
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true,
};
```

**axiosInstance**

```ts
const axiosInstance: AxiosInstance = axios.create();
```



以上**takelatest**、**call**、**put** 由Redux-saga封装，**axiosInstance.put**由axios封装；

**疑惑**

**userSagas调用时机？**

## 微信扫码登录

发起获取二维码请求；

网页端服务器会生成一个uuid，存储在Redis服务器，之后使用uuid生成对应二维码；

用户扫码获取uuid（扫描之前会进行轮询）；

之后手机携带uuid和用户信息向手机的服务器发送请求，手机服务器收到之后携带uuid去redis服务器查询用户，并把uuid与用户信息绑定在一起；

查询成功之后返回一个token给网页服务器，通过解析这个token可以拿出用户的信息；

## 下载接口响应的文件

```js
function downloadFileFromAPI () {
    // 获取当前日期和时间
    const currentDate = new Date();
    const formattedDate = moment(currentDate).utcOffset(8).format('YYYY-MM-DDHHmmss');
    // 发起HTTP请求以获取文件的Blob响应
    fetch(`api/v1/server/agent/inspection/html/${index}/${id}`, {
      method: 'GET',
      // 可以添加适当的请求标头或其他选项
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.blob(); // 获取Blob响应
      })
      .then((blob) => {
        // 创建Blob URL
        const blobUrl = URL.createObjectURL(blob);

        // 创建一个隐藏的<a>标签用于下载
        const a = document.createElement('a');
        a.href = blobUrl;
        a.download = `${info.clusterName}[${info.clusterCode}](${formattedDate}).html`; // 设置下载文件的名称

        // 模拟点击链接来触发下载
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();

        // 清理Blob URL和<a>标签
        URL.revokeObjectURL(blobUrl);
        document.body.removeChild(a);
      })
      .catch((error) => {
        console.error('Error:', error);
      });
  }
```



# react问题

## Objects are not valid as a React child

Uncaught Error: Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead.

这个错误通常发生在使用 React 进行渲染时，尝试将一个对象作为 React 子元素进行渲染，而不是有效的 React 元素或组件。

以下是一个导致该错误的示例：

```js
const data = {
  name: 'John',
  age: 30,
};

function App() {
  return (
    <div>
      {data} {/* 错误的用法 */}
    </div>
  );
}
```

为了解决这个问题，你需要将对象转换为有效的 React 元素或组件，或者将对象中的特定属性提取出来进行渲染。以下是两个修正的示例：

将对象转换为字符串进行渲染：

```js
const data = {
  name: 'John',
  age: 30,
};

function App() {
  return (
    <div>
      {JSON.stringify(data)} {/* 将对象转换为字符串进行渲染 */}
    </div>
  );
}
```

提取对象属性进行渲染：

```js
const data = {
  name: 'John',
  age: 30,
};

function App() {
  return (
    <div>
      <p>Name: {data.name}</p>
      <p>Age: {data.age}</p>
    </div>
  );
}
```

## Warning: validateDOMNesting(...): <div> cannot appear as a descendant of <p>.

这个警告是由 React 提供的 DOM 结构验证机制触发的。它表示在 HTML 中，`<div>` 元素不能作为 `<p>` 元素的子元素出现。

以下是一个示例，展示了触发该警告的情况：

```html
<p>
  这是一个段落。
  <div>这是一个 div。</div>
</p>
```

以下是一个修改后的示例，修复了这个警告：

```html
<div>
  <p>这是一个段落。</p>
  <div>这是一个 div。</div>
</div>
```

# git

## 切换remote

```
git remote set-url origin <new-url>
```

## 查看配置

```bash
查看全局配置信息：
git config --global --list
这将显示全局配置的所有信息，包括用户名、电子邮件、默认编辑器等。

查看当前仓库的配置信息：
git config --list
在仓库目录下执行此命令，将显示当前仓库的配置信息。

查看特定配置项的值：
git config <key>
将 <key> 替换为要查看的特定配置项的名称，例如：
git config user.name
git config core.editor
查看 Git 的所有配置信息：

git config --list --show-origin
此命令将显示所有 Git 配置项及其来源（配置文件和命令行选项等）。
```

## 团队协作

私仓+公仓+merge request模式

1.在公仓那fork出来，此时创建了私仓；

2.clone私仓到本地，添加私仓和公仓的remote；

```
git remote add origin 私仓地址
git remote add upstream 公仓地址
```

tip: origin 和 upstream命名看团队要求或者个人习惯；

3.执行 `git remote -v` 查看验证；

4.每次负责模块开发完，fetch公仓的更新，若有conflict得解决再merge；

```
git fetch upstream
git merge upstream/分支名
```

5.提交更新到私仓

```
git push origin 分支名
```

6.接着去公仓提交merge request，由项目的maintainer合并你的跟新（一般是developer，当然，优秀的你迟早maintainer）

# 建站工具

## docsaurus+algolia搜索引擎

1. 首先，确保你已经在 Algolia 上创建了一个帐户并设置了一个新的搜索索引。获得 Algolia 的 Application ID 和 Search-Only API Key。

2. 在你的 Docusaurus 项目中，安装 `@docusaurus/plugin-search-algolia` 插件。运行以下命令：

   shell

   Copy

   ```
   npm install @docusaurus/plugin-search-algolia
   ```

3. 打开 `docusaurus.config.js` 文件，并添加以下配置：

   javascript

   Copy

   ```
   module.exports = {
     // ...
     plugins: [
       [
         '@docusaurus/plugin-search-algolia',
         {
           apiKey: 'YOUR_API_KEY',
           indexName: 'YOUR_INDEX_NAME',
           // Optional: 搜索结果页面的路径，默认为 '/search'
           // searchResultPagePath: '/search',
           // Optional: 定制 Algolia 搜索配置
           // algoliaOptions: {},
         },
       ],
     ],
     // ...
   };
   ```

   在上述配置中，将 `'YOUR_API_KEY'` 替换为你的 Algolia Search-Only API Key，将 `'YOUR_INDEX_NAME'` 替换为你的搜索索引名称。

4. 保存并关闭 `docusaurus.config.js` 文件。

5. 运行 Docusaurus 以构建和启动你的文档网站：

   shell

   Copy

   ```
   npm run start
   ```

   Algolia 插件将会在构建过程中执行索引生成操作，并将索引上传到 Algolia 服务器。

6. 在你的 Docusaurus 网站上，你可以通过在导航栏或其他适当的位置添加搜索框来启用搜索功能。示例代码如下：

   jsx

   Copy

   ```
   import React from 'react';
   import { useDocsSearch } from '@docusaurus/theme-common';
   
   const SearchBar = () => {
     const { isOpen, openSearchBar, closeSearchBar } = useDocsSearch();
   
     return (
       <div>
         {isOpen ? (
           <input type="text" placeholder="Search" onBlur={closeSearchBar} autoFocus />
         ) : (
           <button onClick={openSearchBar}>Search</button>
         )}
       </div>
     );
   };
   
   export default SearchBar;
   ```

全文搜索步骤：

1.申请Algolia DocSearch服务

2.回复确认邮件

```
Thanks!

I am the maintatiner of the website, I can modify the code.
```

3.启动搜索服务

4.后台管理数据

# 原理了解

## algolia搜索插件原理



# 问题&解决方案

## @sentry/cli

执行yarn，link步骤出现 `@sentry/cli@npm:1.75.2 couldn't be built successfully (exit code 1, logs can be found here: D:\temp\xfs-0d7a820d\build.log)`

```
[sentry-cli] Downloading from https://downloads.sentry-cdn.com/sentry-cli/1.75.2/sentry-cli-Windows-x86_64.exe
Error: Unable to download sentry-cli binary from https://downloads.sentry-cdn.com/sentry-cli/1.75.2/sentry-cli-Windows-x86_64.exe.
Error code: ECONNRESET
```

**解决**：

发现是**@sentry/webpack-plugin**依赖了**@sentry/cli**

1.根目录下新建.yarnrc

```
npmRegistryServer: "http://registry.npm.taobao.org/"
strict-ssl: false
```

单独安装@sentry/webpack-plugin

```
yarn add @sentry/webpack-plugin@1.18.9
```

## msys-crypto-1.1.dll

执行bash ./build.sh -DskipTests

日志有这条信息：D:/devTools/git/Git/usr/bin/rsync.exe: error while loading shared libraries: msys-crypto-1.1.dll: **cannot open shared object file**: No such file or directory

找到这个文件，放到**D:/devTools/git/Git/usr/bin**下就好了

## window提示你需要xxx的权限才能删除？

修改文件夹名称，再删

## 页面变模糊？

和浏览器缩放比例有关

## playwright安装慢

执行yarn，link 步骤第三方库playwright安装慢

# nginx

## 配置

设置变量时，不要用localhost，直接用127.0.0.1；

```
set $backend_url "http://127.0.0.1:8080";
```



# js常见算法

## 树的扁平化

## 计算属性个数

```js
const obj = {
  name: 'John',
  age: 30,
  city: 'New York'
};

const propertyCount = Object.keys(obj).length;

console.log(propertyCount); // 输出 3
```

`Object.keys()`方法只会返回对象**自身的可枚举属性**，不包括继承的属性。如果需要计算包括继承属性在内的属性个数，可以使用`for...in`循环结合计数器进行计算。

```js
const obj = {
  name: 'John',
  age: 30,
  city: 'New York'
};

let count = 0;
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    count++;
  }
}

console.log(count); // 输出 3
```

## 优雅写法

检查是否有值

```js
!!a
```

有值返回true，否则false

## 时间格式化

2023-09-08T03:46:42.06938545Z
格式化成24小时

使用dayjs库处理

```js
moment(info.inspectTime).utcOffset(8).format('YYYY-MM-DD HH:mm:ss')
// 输出 "17:46:42"
```



# html

## img

```html
<img src="https://cdn.nlark.com/yuque/0/2023/png/293024/1695120594066-6fa7d888-5be5-4c80-ae6a-d22d9283d873.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0" referrerpolicy="no-referrer"/>
```

x-oss-process=image%2Fresize%2Cw_750%2Climit_0 有什么作用呢

**有什么作用呢**

1. `image/resize`：这部分指定了要进行的操作，即对图片进行调整大小的操作。
2. `w_750`：这是调整图片宽度的参数，将图片宽度调整为 750 像素。这个参数告诉 OSS 在显示这张图片时将其宽度限制为 750 像素。
3. `limit_0`：这个参数表示不对图片的文件大小进行限制。通常，OSS 会根据图片的处理操作和质量设置来控制文件大小，但 `limit_0` 表示不进行额外的限制。

综合来说，这个参数的作用是将图片调整为指定宽度，并且不对文件大小进行限制。这在网页设计中常用于确保图片在页面上的显示大小一致，并且不会因为文件大小而导致加载速度变慢。

这种方式允许你通过在图片 URL 中包含参数来对图片进行处理，而不必事先创建不同尺寸的图片副本。相同的原始图片可以通过不同的参数进行处理，以满足不同设备或布局的需求。

# 技术清单

| 技术      | 分类标签      | 说明                   | 复现 |
| --------- | ------------- | ---------------------- | ---- |
| docSearch | *文档*        | 文档的**全文搜索**功能 |      |
| Auth2.0   | *协议* *鉴权* | 用户**单点登录**功能   |      |
| strapi    | *后端低代码*  | 模拟**简单接口**       |      |

# 项目清单

| 项目             | 职责                                                   | 技术 | 收获 |
| ---------------- | ------------------------------------------------------ | ---- | ---- |
| Pageplug         | 1.树形组件开发<br />2.OIDC单点登录<br />3.微信扫码登录 |      |      |
| Pageplug使用文档 |                                                        |      |      |
|                  |                                                        |      |      |



# 后端

1. 一般地，请求有返回**302**状态码才是后端重定向，否则是前端处理的
2. 
