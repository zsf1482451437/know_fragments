# 性能优化方向

## HTML性能考虑

每个网站都以HTML文档的请求开始，这个请求在你的网站加载速度中起着很大的作用。这个模块涵盖了重要的概念，如**HTML缓存**，**解析器阻塞**，**渲染阻塞**，等等，所以你可以确保你的网站的HTML的第一个请求是正确的。

### 最小化重定向

1. **HTTP重定向**：当客户端请求一个资源时，服务器可能会返回一个重定向响应，告诉客户端资源已经被移动到新的位置。重定向有两种类型：永久重定向（301 Moved Permanently）和临时重定向（302 Found）。永久重定向表示资源已经被永久地移动到新的位置，而临时重定向表示资源只是暂时地移动到新的位置。
2. **重定向的影响**：重定向会减慢页面加载速度，因为它需要浏览器在新的位置发起额外的HTTP请求来获取资源。
3. **重定向的类型**：有两种类型的重定向：同源重定向和跨源重定向。同源重定向是在你的源（origin）内部发生的，你可以完全控制这种重定向。跨源重定向是由其他源发起的，你通常无法控制这种重定向。
4. **跨源重定向**：跨源重定向通常被广告、URL缩短服务和其他第三方服务使用。虽然你无法控制跨源重定向，但你仍然应该避免多次重定向，例如，一个广告链接到一个HTTP页面，然后该页面又重定向到其HTTPS等价物，或者一个跨源重定向到达你的源，但然后触发了一个同源重定向。

常见的同一原始重定向模式是将用户从尾声结尾的URL重定向到非拖动斜线等效或vice-versa，例如，将用户从example.com/page/重定向到example.com/page。在页面之间创建内部链接时，您需要避免链接到以重定向响应的页面，并直接链接到正确的位置。

**措施：**

1. **避免不必要的重定向**：首先，你应该检查你的网站是否有不必要的重定向。例如，如果你有一个页面 A，它重定向到页面 B，然后页面 B 又重定向到页面 C，那么你应该直接将页面 A 重定向到页面 C，避免中间的重定向。
2. **使用 HTTP/2**：HTTP/2 支持服务器推送，这意味着服务器可以在浏览器请求资源之前就将资源发送给浏览器。这可以减少由于重定向而产生的额外 HTTP 请求。
3. **预加载资源**：你可以使用 `<link rel="preload">` 标签来预加载重定向后的资源。这样，当浏览器遇到重定向时，它已经预加载了重定向后的资源，从而减少了加载时间。
4. **使用 HSTS**：如果你的网站支持 HTTPS，你可以使用 HTTP Strict Transport Security (HSTS) 来避免 HTTP 到 HTTPS 的重定向。HSTS 告诉浏览器只使用 HTTPS 来访问你的网站，从而避免了重定向。
5. **优化广告和第三方服务**：如果你的网站使用了广告或第三方服务，你应该确保它们不会产生不必要的重定向。你可以与这些服务的提供商联系，要求他们优化他们的重定向。

### 缓存HTML响应

缓存**HTML**响应很困难，因为响应可能包括指向其他关键资源（例如**CSS**，**JavaScript**，**图像**和**其他资源**类型）的链接。这些资源可能在其各自的文件名中包含独特的**指纹**，该指纹根据文件的内容更改。这意味着您的缓存的HTML文档可能会在部署后变成陈旧，因为它将包含对过时的子资源的引用。

尽管如此，较短的缓存生命周期比不缓存更有好处，比如允许在**CDN**上缓存资源，减少来自源服务器和浏览器的请求数量，允许重新验证资源，而不是再次下载资源。此方法最适合在任何上下文中都不会更改的**静态内容**，并且可以将缓存资源的适当时间设置为您认为合适的分钟数。5分钟的静态HTML资源是一个安全的赌注，并确保定期更新不会被忽视。

如果页面的HTML内容以某种方式**个性化**（例如对身份验证的用户）进行个性化，那么您很可能根本不想缓解（安全性和新鲜度）。如果用户的浏览器缓存HTML响应，则无法使缓存无效。因此，最好避免在这种情况下完全缓存HTML。

缓存HTML的一种谨慎的方法是使用ETag或Last-Modified响应头。ETag也被称为实体标记头，它是唯一表示所请求资源的标识符，通常使用资源内容的散列

每当资源发生变化时，必须生成一个新的ETag值。在后续请求中，浏览器通过If-None-Match请求头发送ETag值。如果服务器上的ETag与浏览器发送的ETag匹配，则服务器响应304 Not Modified响应，浏览器使用缓存中的资源。虽然这仍然会导致网络延迟，但304 Not Modified响应比整个HTML资源要小得多。

但是，重新验证资源的新鲜度所涉及的网络延迟仍然是它自己的缺点。与web开发的许多其他方面一样，权衡和妥协是不可避免的。以这种方式缓存HTML的额外努力是否值得，或者最好是保持安全，根本不需要缓存HTML内容，这取决于您。

### 测量服务器响应时间

如果未缓存响应，则服务器的响应时间高度依赖于托管服务提供商和后端应用程序堆栈。提供动态生成响应（例如从数据库获取数据）的网页很可能比静态网页具有更高的 TTFB，静态网页可以立即提供，而无需在后端花费大量计算时间。显示加载微调器，然后在客户端获取所有数据，将工作从更可预测的服务器端环境转移到可能不可预测的客户端环境。最小化客户端工作量通常会导致改进以用户为中心的指标。

如果用户在现场遇到缓慢的 TTFB，您可以通过使用 `Server-Timing` 响应标头来公开有关在服务器上花费时间的信息：

```bash
Server-Timing: auth;dur=55.5, db;dur=220
```

`Server-Timing` 标头的值可以包含多个指标，以及每个指标的持续时间。然后，可以使用导航计时 API 从现场用户那里收集这些数据，并进行分析以查看用户是否遇到延迟。在前面的代码片段中，响应标头包括两个计时：

- 对用户进行身份验证的时间 （ `auth` ），耗时 55.5 毫秒。
- 数据库访问时间 （ `db` ），耗时 220 毫秒。

> 可以在优化 TTFB 指南中找到有关 `Server-Timing` 响应标头的更多信息。
>
> https://web.dev/articles/optimize-ttfb#understanding_high_ttfb_with_server_timing

您可能还想查看您的托管基础设施，并确认您有足够的资源来处理您的网站收到的流量。共享主机提供商通常容易受到高 TTFB 的影响，而提供更快响应时间的专用解决方案可能成本更高。

> 可以在 ismyhostfastyet.com 比较热门托管服务提供商的 TTFB。这些数据由从 Chrome 用户体验报告 （CrUX） 数据集中收集的真实用户体验组成。

### 压缩

基于文本的响应（如 HTML、JavaScript、CSS 和 SVG 图像）应进行压缩，以减少其在网络上的传输大小，以便更快地下载。使用最广泛的压缩算法是 gzip 和 Brotli。Brotli 比 gzip 提高了大约 15% 到 20%。

压缩通常由大多数网络托管服务提供商自动设置，但如果您能够自己配置或调整压缩设置，则需要考虑一些重要事项：

- 尽可能使用 Brotli。如前所述，Brotli 比 gzip 提供了相当明显的改进，并且所有主流浏览器都支持 Brotli。尽可能使用 Brotli，但如果您的网站在旧版浏览器上被大量用户使用，请确保使用 gzip 作为后备，因为任何压缩都比完全没有压缩好。
- 

## 关键路径

**关键渲染路径**是web性能中的一个概念，用于处理页面在浏览器中初始呈现的速度。本模块将介绍关键渲染路径背后的理论，涵盖诸如**渲染阻塞**和**解析器阻塞**资源等概念，以及它们如何在页面在浏览器中显示的速度中发挥关键作用。

## 资源加载

当页面加载时，它的HTML中引用了许多资源，这些资源通过CSS提供了页面的外观和布局，并通过JavaScript提供了其交互性。在本模块中，将介绍与这些资源相关的一些重要概念，以及它们如何影响页面的加载时间。

## 资源提示

资源提示是HTML中可用的一组特性，可以帮助浏览器更早地加载资源，甚至可能具有更高的资源优先级。在这个模块中，介绍了一些资源提示，可以帮助您更快地加载页面。

## 图片

如今，在许多网页上传输的数据中，图像占了很大一部分。本模块涵盖了如何优化图像，以及如何有效地为它们提供服务，以便无论用户的设备如何，都可以最大限度地减少浪费的字节。

## 视频

视频是一种经常在网页上使用的媒体类型，但知道如何有效地为它们提供服务是性能的一个方面，你不应该忽视。本模块涵盖了一些嵌入视频的关键技术，以使您的网站保持快速，以及使用视频时可能出现的相关性能考虑。

## 网站字体

网页字体是一种常用的网页资源，它们理所当然地为网站的设计增添了其他资源无法比拟的元素。即便如此，网页字体仍然有性能成本。在这个模块中，我们将探讨一些关于web字体的性能考虑和技术。

##  js代码切分

有些资源对网页的初始加载并不重要。JavaScript就是这样一种资源，它可以通过一种称为代码分割的技术延迟到需要的时候。通过这样做，您可以通过降低带宽和CPU争用来提高性能，这是在启动期间提高初始页面加载速度和输入响应性的关键考虑因素。

## 懒加载图片和iframe元素

image和<iframe>元素会消耗大量的带宽和CPU处理时间。但是，并不是所有的图像和<iframe>元素都需要在初始页面加载期间加载，可以推迟到用户最有可能看到它们的时候。这种技术被称为惰性加载。在本模块中，解释了延迟加载图像和<iframe>元素，以便您可以更快地加载页面，并且仅在需要时才消耗带宽和处理时间。

## prefetch&prerender&service worker

尽管大部分绩效都涉及您可以采取的优化和消除不必要的资源，但建议在需要之前加载某些资源似乎有些自相矛盾。但是，在某些情况下，提前加载某些资源可能是适当的。在此模块中，讨论了预摘要，预处理和服务工作者的探索性能的这一方面。

## web worker

用户在浏览器中看到的大部分内容都在称为主线程的单个线程上发生。但是，您可以在某些机会上启动新线程来进行计算昂贵的工作，以便主线程可以容纳重要的用户任务。执行此操作的API被称为Web Worker API，在此模块中，它的基础是涵盖的。

## web worker用例

现在您已经对web worker及其功能和限制有了基本的了解，是时候来看看web worker的具体用例了。在这个演示中，使用web worker获取JPEG文件，提取其元数据，并将其发送回主线程，以便用户可以在浏览器中看到它。

## 性能指标

常见：

- `TPM`: 每分钟事务数（**Transactions Per Minute**）
- `FCP`：首次内容绘制（浏览器第第一次开始渲染 dom节点的时间点）（**First Contentful Paint**）
- `LCP`：最大内容渲染，代表 `viewpoint` 中最大页面元素的加载时间（**Largest Contentful Paint**）
- `FID`：用户首次输入延迟，可以衡量用户首次与网站交互的时间（**First Input Delay**）
- `CLS`：累计布局偏移，一个元素初始时和消失前的数据（**Cumulative Layout Shift**）
- `TTFB`：首字节时间，测量用户浏览器接收页面的第一个字节的时间（可以判断缓慢来自网络请求还是页面加载问题）
- `USER`：`uv` 数字
- `USER MISERY`: 对响应时间难以忍受的用户指标，由 `sentry` 计算出来，阈值可以动态修改

| 指标 | 衡量         |
| ---- | ------------ |
| FCP  | 首次看到内容 |
| FID  | 首次交互     |
| CLS  | 页面稳定性   |



## 用户体验方面

### prefetch和preload

**prefetch**，link元素的rel属性值，提示浏览器用户未来有可能需要加载的目标资源，所以浏览器有可能**事先获取**和**缓存**对应资源，优化用户体验；

**preload**，link元素的rel属性值，表示用户十分有可能需要在当前路由加载目标资源，所以浏览器**必须**预先获取和缓存对应资源，不会阻塞**onload**事件；

## 减少js体积

- 使用变量名丑化插件，如uglify；
- gzip压缩
- 使用 `webpack-bundle-analyzer` 分析打包体积，**替换**占用较大体积的库，如 `moment` -> `dayjs`
- 使用支持 **Tree-Shaking** 的库，对无引用的库或函数进行删除，如 `lodash` -> `lodash/es`

## 项目中常用的性能优化方式是什么？

- 减少HTTP请求
- 静态资源使用 CDN托管
- 将样式表放在顶部，将脚本放在底部
- 善用缓存，不重复加载相同的资源
- 图片懒加载，滑动到可视区域再加载
- webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
- 压缩代码（利用插件js丑化、html和css也有相应的压缩插件，还有就是gzip）
- 等等

参考：https://segmentfault.com/a/1190000022205291

## 重排重绘

页面生成的过程：

html被html解析器解析成**DOM**树；

css被css解析器解析成**CSSOM**树；

结合DOM树和CSSOM树，生成一棵渲染树（**render tree**），这一过程成为attachment；

生成布局（**flow**），浏览器在屏幕上画出渲染树中所有节点；

将布局绘制（**paint**）在屏幕上，显示出整个页面；

**重排：**

元素布局发生改变，重新排列元素；

**重绘：**

元素外观改变，重新绘制；

元素外观的改变，不会引起元素的布局发生改变；但元素布局改变，将会重新绘制受到此次重排影响的部分，比如元素高度改变，这个元素乃至周边DOM节点都需要重新绘制。所以，**重绘不一定重排，但重排一定导致重绘**

下面情况会发生重排：

- 页面初识渲染，开销最大的一次重排
- 添加、删除可见的DOM元素
- 改变元素位置
- 改变元素尺寸
- 改变元素内容
- 改变浏览器窗口大小，比如resize事件发生时
- 激活css伪类（例如：hover）
- **设置style属性的值，每一次设置都会触发重排**
- **查询某些属性或者调用某些计算方法：offsetWidth、offsetHeight等**

**重排优化建议**

- 减少重排范围 （尽量在层级较低的DOM节点重排）
- 减少重排次数 

**减少重排次数** 

- 样式集中改变 （更改类名而不是修改样式）
- 分离读写操作
- 将DOM离线
- 使用 absolute 或 fixed 脱离文档流
- 优化动画

**样式集中改变** 

```js
// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top = top + "px";

// 当top和left的值是动态计算而成时...
// better 
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";

// better
el.className += " className";
```

**分离读写操作**

```js
// bad 强制刷新 触发四次重排+重绘
div.style.left = div.offsetLeft + 1 + 'px';
div.style.top = div.offsetTop + 1 + 'px';
div.style.right = div.offsetRight + 1 + 'px';
div.style.bottom = div.offsetBottom + 1 + 'px';


// good 缓存布局信息 相当于读写分离 触发一次重排+重绘
var curLeft = div.offsetLeft;
var curTop = div.offsetTop;
var curRight = div.offsetRight;
var curBottom = div.offsetBottom;

div.style.left = curLeft + 1 + 'px';
div.style.top = curTop + 1 + 'px';
div.style.right = curRight + 1 + 'px';
div.style.bottom = curBottom + 1 + 'px';
```

浏览器的**渲染队列机制**：当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。

**将DOM离线**

- **使用 display:none**

  一旦我们给元素设置 `display:none` 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 display属性显示（另一次重排重绘）。通过这种方式即使**大量变更**也只触发**两次重排**。另外，`visibility : hidden` 的元素只对重绘有影响，不影响重排。

- 通过 [documentFragment](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocumentFragment) 创建一个 `dom` 碎片,在它上面批量操作 `dom`，操作完成之后，再添加到文档中，这样只会触发一次重排。

- 复制节点，在副本上工作，然后替换它！

**使用 absolute 或 fixed 脱离文档流**

使用**绝对定位**会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。

**优化动画**

可以把动画效果应用到 `position`属性为 `absolute` 或 `fixed` 的元素上，这样对其他元素影响较小。

动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多